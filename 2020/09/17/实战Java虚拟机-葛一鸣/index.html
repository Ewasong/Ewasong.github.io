<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java虚拟机," />










<meta name="description" content="第1章 初探Java虚拟机略 第2章 认识Java虚拟机的基本结构本章 涉及 的 主要 知识 点 有：   认识 Java 虚拟 机 中的 堆。  了解 有关 栈 的 概念 和 使用。  了解 存放 类型 描述 的 永久 区 和 元 数据区。  2.1 谋全局者才能成大器：看穿Java虚拟机的架构 ​     ​    类加载子系统负责从文件系统或网络中加载Class信息，加载的类信息存放于一块称">
<meta property="og:type" content="article">
<meta property="og:title" content="实战Java虚拟机(葛一鸣)">
<meta property="og:url" content="http://yoursite.com/2020/09/17/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%91%9B%E4%B8%80%E9%B8%A3/index.html">
<meta property="og:site_name" content="宋二的小窝">
<meta property="og:description" content="第1章 初探Java虚拟机略 第2章 认识Java虚拟机的基本结构本章 涉及 的 主要 知识 点 有：   认识 Java 虚拟 机 中的 堆。  了解 有关 栈 的 概念 和 使用。  了解 存放 类型 描述 的 永久 区 和 元 数据区。  2.1 谋全局者才能成大器：看穿Java虚拟机的架构 ​     ​    类加载子系统负责从文件系统或网络中加载Class信息，加载的类信息存放于一块称">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f635904160a154a67efeade.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f635f97160a154a67f1a941.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6362d4160a154a67f2a435.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f636489160a154a67f323c5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6365e5160a154a67f37a5b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f636661160a154a67f39849.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6366f0160a154a67f3bc4e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6367fa160a154a67f4095b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f63695e160a154a67f46726.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f636951160a154a67f4639b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66e6e7160a154a67dc971d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66e7b0160a154a67dcc91a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66e837160a154a67dce821.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66eb10160a154a67dd99aa.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66eda5160a154a67de3862.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f076160a154a67df1f02.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f3b0160a154a67dff7df.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f3f6160a154a67e00800.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f48f160a154a67e02703.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f79a160a154a67e0c6d6.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f8cd160a154a67e10eed.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f8f3160a154a67e1195a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f952160a154a67e12fd9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f983160a154a67e13bb6.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66f9ed160a154a67e15329.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66fa5e160a154a67e16d56.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f66fb8a160a154a67e1b492.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f68960a160a154a679c2ec7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f68996a160a154a679f1344.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f689a09160a154a679f960f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f689c3c160a154a67a169f9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f689ca0160a154a67a1bbb9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f689e46160a154a67a313df.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f689ead160a154a67a3738c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f68a036160a154a67a46732.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f68a826160a154a67aaf771.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f69f9e2160a154a67573d4c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f69fabc160a154a6757a32c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f69fd2a160a154a6758af56.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f69fddf160a154a6759083d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f69ff4a160a154a6759d87c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6a016c160a154a675b1bc4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6a02a1160a154a675bd3d5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6a02b2160a154a675bdddd.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6a0303160a154a675c110f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6a0320160a154a675c2354.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6b3d5d160a154a67d76a1d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6b414d160a154a67d971aa.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c85c9160a154a677455d5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8684160a154a6774a1e3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c86c7160a154a6774bc13.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8747160a154a6774ee89.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c875c160a154a6774f69d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8791160a154a67750dcb.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c87cd160a154a677526ab.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c894a160a154a6776421e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8968160a154a67765eff.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8a74160a154a677720f2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8ad8160a154a67774a5d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8b10160a154a677764e6.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8c8f160a154a67780c9d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8da0160a154a677885b2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8e09160a154a6778b7c7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8e2a160a154a6778c526.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8e4e160a154a6778d3b3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8e6f160a154a6778e19d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8fbc160a154a67797641.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8fde160a154a677987a7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c8ff6160a154a6779934d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9039160a154a6779b405.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9059160a154a6779c3ba.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9066160a154a6779c923.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9094160a154a6779dd14.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c90c4160a154a6779f127.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c913e160a154a677a2d58.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9224160a154a677a9675.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9322160a154a677b04fe.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c934b160a154a677b16ae.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9427160a154a677b747d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c946a160a154a677b9196.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9480160a154a677b9ae8.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c949a160a154a677ba6d8.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c95cd160a154a677c2942.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c95dc160a154a677c3071.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c95f4160a154a677c3a49.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9612160a154a677c4897.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9648160a154a677c5a33.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9676160a154a677c6a5e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c96b5160a154a677c7fef.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9755160a154a677cbdb1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9868160a154a677d326f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9968160a154a677da8b3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c99b0160a154a677dcfee.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c99d7160a154a677de40b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6c9a07160a154a677e006e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ed9df160a154a6745d7c7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6eee02160a154a674bd9e1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6eefca160a154a674c682e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef1de160a154a674d2671.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef43f160a154a674e18d4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef5cf160a154a674e85bc.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef60e160a154a674e9814.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef65c160a154a674eafa6.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef90b160a154a674f5f4e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef93c160a154a674f6bf9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef975160a154a674f7aee.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6ef9e3160a154a674f960a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6efafc160a154a674fe351.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6efb18160a154a674feac6.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6efb69160a154a674ffd46.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6eff6a160a154a67511272.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6f0173160a154a6751a7b1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6f01c2160a154a6751d4f3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6f026e160a154a67520dd3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6f039a160a154a67526e07.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f6f0476160a154a6752b65a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709101160a154a67c8bd7a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f70911d160a154a67c8c9bc.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f7091da160a154a67c91f6f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709386160a154a67c9bad4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709417160a154a67c9ef46.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709576160a154a67ca6cc0.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f7095ab160a154a67ca831c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709665160a154a67cad823.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f7096b8160a154a67cafad9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f70972e160a154a67cb322c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709757160a154a67cb4595.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f70987b160a154a67cbc7b3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709965160a154a67cc37d7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709a68160a154a67ccb0ee.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709a86160a154a67ccc1e1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709c3a160a154a67cda807.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709c80160a154a67cdc902.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709cc3160a154a67cde87c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709d16160a154a67ce1dd2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709d38160a154a67ce2fd9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709d9d160a154a67ce65ac.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709e26160a154a67cea364.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709e5b160a154a67ceb932.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709ea2160a154a67ced659.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709eed160a154a67cef4a5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709f33160a154a67cf18bb.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709f53160a154a67cf2501.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f709faf160a154a67cf537a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71d354160a154a672bcd00.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71d3b3160a154a672be445.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71d837160a154a672d0fc2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71d99d160a154a672d64c3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71dd60160a154a672e9ed2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71ddcb160a154a672ec4ec.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71de71160a154a672f0456.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e091160a154a672fa450.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e10e160a154a672fc848.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e2bf160a154a67302c7f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e2ce160a154a67303010.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e458160a154a6730a6c9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e492160a154a6730b668.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e88b160a154a6731f85a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e899160a154a6731fc90.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e9af160a154a67325139.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71e9cc160a154a6732587e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71ec6b160a154a67334faa.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71ec94160a154a67336000.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71eea6160a154a673404f1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71eeb7160a154a673408cf.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f71f493160a154a6735ca01.jpg">
<meta property="article:published_time" content="2020-09-17T12:35:22.000Z">
<meta property="article:modified_time" content="2020-09-28T14:53:01.609Z">
<meta property="article:author" content="宋梓立 sorie">
<meta property="article:tag" content="Java虚拟机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/5f635904160a154a67efeade.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/17/实战Java虚拟机-葛一鸣/"/>





  <title>实战Java虚拟机(葛一鸣) | 宋二的小窝</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Ewasong" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">宋二的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/17/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%91%9B%E4%B8%80%E9%B8%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宋梓立 sorie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宋二的小窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">实战Java虚拟机(葛一鸣)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-17T20:35:22+08:00">
                2020-09-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/17/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%91%9B%E4%B8%80%E9%B8%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/17/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%91%9B%E4%B8%80%E9%B8%A3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第1章-初探Java虚拟机"><a href="#第1章-初探Java虚拟机" class="headerlink" title="第1章 初探Java虚拟机"></a>第1章 初探Java虚拟机</h1><p>略</p>
<h1 id="第2章-认识Java虚拟机的基本结构"><a href="#第2章-认识Java虚拟机的基本结构" class="headerlink" title="第2章 认识Java虚拟机的基本结构"></a>第2章 认识Java虚拟机的基本结构</h1><p>本章 涉及 的 主要 知识 点 有： </p>
<ul>
<li>认识 Java 虚拟 机 中的 堆。 </li>
<li>了解 有关 栈 的 概念 和 使用。 </li>
<li>了解 存放 类型 描述 的 永久 区 和 元 数据区。</li>
</ul>
<h2 id="2-1-谋全局者才能成大器：看穿Java虚拟机的架构"><a href="#2-1-谋全局者才能成大器：看穿Java虚拟机的架构" class="headerlink" title="2.1 谋全局者才能成大器：看穿Java虚拟机的架构"></a>2.1 谋全局者才能成大器：看穿Java虚拟机的架构</h2><p><img src="https://pic.imgdb.cn/item/5f635904160a154a67efeade.jpg" alt=""></p>
<p>​    </p>
<p>​    类加载子系统负责从文件系统或网络中加载Class信息，加载的类信息存放于一块称为方法去的内存空间中。除了类信息，方法去还会存放运行时常量池信息，包括字符串字面量和数字常量。</p>
<p>​    Java堆在虚拟机启动的时候建立，是Java程序最主要的工作区域。几乎所有的Java实例都存放在Java堆中。堆空间是所有线程共享的。</p>
<p>​    Java的NIO库允许Java程序使用直接内存。是存在与Java堆外、直接向系统申请的内存区域。通常，访问直接内存的速度会优先于Java堆。受限于系统的最大内存。</p>
<p>​    垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、Java堆和直接内存进行回收。其中，Java堆是垃圾收集器的工作重点。</p>
<p>​    每一个Java虚拟机线程都有一个私有的Java栈。一个线程的Java栈在线程启动的时候被创建。Java栈中保存着帧信息，Java栈中保存着局部变量、方法参数，同时和Java方法的调用、返回密切相关。</p>
<p>​    本地方法栈和Java栈特别类似，最大不同在于Java栈用于Java方法的调用，本地方法栈则用于本地方法的调用。</p>
<p>​    PC寄存器也是每个线程私有的空间，Java虚拟机会为每一个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个方法被称为当前方法。如果当前方法不是本地方法，就会指向被执行的命令，如果是，值就是undefined。</p>
<h2 id="2-2-小参数能解决大问题：学会设置Java虚拟机参数"><a href="#2-2-小参数能解决大问题：学会设置Java虚拟机参数" class="headerlink" title="2.2 小参数能解决大问题：学会设置Java虚拟机参数"></a>2.2 小参数能解决大问题：学会设置Java虚拟机参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java [-options] class [args...]</span><br></pre></td></tr></table></figure>

<p>-options表示Java虚拟机的启动参数， args表示传递给主函数main()的参数。</p>
<p>如果需要设定特定的Java虚拟机参数，在options处指定即可。</p>
<h2 id="2-3-对象去哪儿：辨清Java堆"><a href="#2-3-对象去哪儿：辨清Java堆" class="headerlink" title="2.3 对象去哪儿：辨清Java堆"></a>2.3 对象去哪儿：辨清Java堆</h2><p>​    几乎所有对象都是存放在堆中，通过垃圾回收机制，垃圾对象会被自动清理。</p>
<p>​    垃圾回收机制不同，可能有不同的结构，最常见的如下:</p>
<p><img src="https://pic.imgdb.cn/item/5f635f97160a154a67f1a941.jpg" alt=""></p>
<p>​    绝大多数情况下，对手首先在eden区分配，在一次新生代回收后，如果对象还存活，则会进入s0或s1。每次经过一次新生代回收，如果对象存活，年龄就+1。到达一定条件后，进入老年代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sorie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My ID is"</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap s1 = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        s2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    SimpleHeap实例本身在堆中分配，描述SimpleHeap类的信息存放在方法区，main()函数中的s1和s2局部变量存放在Java栈中，并且指向堆中的两个实例。</p>
<p><img src="https://pic.imgdb.cn/item/5f6362d4160a154a67f2a435.jpg" alt=""></p>
<h2 id="2-4-函数如何调用：出入Java栈"><a href="#2-4-函数如何调用：出入Java栈" class="headerlink" title="2.4 函数如何调用：出入Java栈"></a>2.4 函数如何调用：出入Java栈</h2><p>​    Java栈是一块线程私有的内存空间。线程执行的基本行为是函数调用，每次函数调用都是通过Java栈传递的。</p>
<p>​    是一块先进后入的数据结构，只支持出栈和入栈两种操作。Java栈中保存的主要内容为栈帧。当前正在执行的函数所对应的帧就是当前的帧(位于栈顶)，它保存着当前函数的局部变量、中间运算结果等数据。</p>
<p>​    函数返回时，栈帧从Java栈中被弹出。Java有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。</p>
<p>​    一个栈帧中，至少要包含局部变量表、操作数栈和帧数据区几部分。</p>
<p><img src="https://pic.imgdb.cn/item/5f636489160a154a67f323c5.jpg" alt=""></p>
<p>​    如果栈空间不足，那么函数调用自然无法继续进行。当前请求的栈深度大于最大可用栈深度，就会抛出StackOverflowError栈溢出错误。</p>
<p>​    通过参数-Xss128K，可以调整栈大小。</p>
<h3 id="2-4-1-局部变量表"><a href="#2-4-1-局部变量表" class="headerlink" title="2.4.1 局部变量表"></a>2.4.1 局部变量表</h3><p>​    是栈帧的重要组成部分一直，用于保存函数的参数及局部变量、局部变量表中的变量只在函数调用中有效，调用结束，栈帧就销毁，局部变量表也会销毁。</p>
<p>​    如果函数的参数和局部变量较多，会使局部变量表膨胀，最终导致函数嵌套次数减少。</p>
<p><img src="https://pic.imgdb.cn/item/5f6365e5160a154a67f37a5b.jpg" alt=""></p>
<p>局部变量表的变量也是重要的垃圾回收根节点，被局部变量表中直接或间接引用的对应都不会被回收。</p>
<h3 id="2-4-2-操作数栈"><a href="#2-4-2-操作数栈" class="headerlink" title="2.4.2 操作数栈"></a>2.4.2 操作数栈</h3><p>​    栈帧中重要内容之一，用于保存计算中间结果，通识作为计算过程中变量临时的计算存储空间。</p>
<p><img src="https://pic.imgdb.cn/item/5f636661160a154a67f39849.jpg" alt=""></p>
<h3 id="2-4-3-帧数据区"><a href="#2-4-3-帧数据区" class="headerlink" title="2.4.3 帧数据区"></a>2.4.3 帧数据区</h3><p>​    除了局部变量表和操作数栈，Java栈帧还需要一些数据来支持常量池解析、正常方法返回和异常处理操作。大部分Java字节码指令需要进行常量池访问，在帧数据区中国保存着访问常量池的指针，方便访问常量池。</p>
<p>​    此外，函数如果出现异常，虚拟机必须回复调用者函数的栈帧，并且让调用者函数继续执行。对于异常处理，虚拟机必须有一个异常处理表，方便在异常时找到处理异常的代码。</p>
<p><img src="https://pic.imgdb.cn/item/5f6366f0160a154a67f3bc4e.jpg" alt=""></p>
<p>​    第一行表示4到16字节可能抛出任意异常，如果遇到则跳转到字节码偏移19处执行。</p>
<h3 id="2-4-4-栈上分配"><a href="#2-4-4-栈上分配" class="headerlink" title="2.4.4 栈上分配"></a>2.4.4 栈上分配</h3><p>​    是Java虚拟机提供的一项优化技术，基本思想是，对于那些线程私有(不会被其他线程访问的对象)，可以将它们打散分配在栈上，而不是在堆上。好处是可以自行销毁，不需要垃圾回收器的接入。</p>
<p>​    一个技术基础是进行逃逸分析。目的是判断对象的作用于是否有可能逃出函数体。</p>
<p>​    对于没有逃逸的对象，虚拟机可能将其分配在栈上。</p>
<p>​    在Server模式(-server)下，才可以启用逃逸分析。参数-XX:+DoEscapeAnalysis启用逃逸分析。</p>
<p><img src="https://pic.imgdb.cn/item/5f6367fa160a154a67f4095b.jpg" alt=""></p>
<p>​    关闭逃逸分析或标量替换中的任何一个，就会看到大量日志。栈上分配依赖逃逸分析和标量替换的实现。</p>
<p>​    对于大量零散的小对象，栈上分配提供了一种很好的对象分配优化策略，栈上分配速度很快，并且可以有效避免垃圾回收带来的负面影响。大对象无法也不合适在栈上分配。</p>
<h2 id="2-5-类去哪儿了：识别方法区"><a href="#2-5-类去哪儿了：识别方法区" class="headerlink" title="2.5 类去哪儿了：识别方法区"></a>2.5 类去哪儿了：识别方法区</h2><p>​    所有线程共享。保存类信息，比如字段、方法、常量池。大小决定系统可以保存多少个类，如果定义了太多类，导致方法区溢出，会抛出内存溢出错误。</p>
<p>​    JDK1.6,1.7中，方法去可以理解为永久区。永久区可以使用参数-XX:PermSize和-XX:MaxPermSize指定。默认-XX:MaxPermSize为64MB。如果系统使用了一些动态大力，这是需要设置一个合适的永久区大小，确保不会发生内存溢出。</p>
<p>​    JDK1.8之后，永久区已经被彻底移除，取而代之的是元数据区，通过参数-XX:MaxMetaspaceSize指定，默认情况下会耗尽所有系统内存。</p>
<p><img src="https://pic.imgdb.cn/item/5f63695e160a154a67f46726.jpg" alt=""></p>
<p>​    元数据区发生溢出会抛出异常。</p>
<p><img src="https://pic.imgdb.cn/item/5f636951160a154a67f4639b.jpg" alt=""></p>
<h1 id="第3章-常用Java虚拟机参数"><a href="#第3章-常用Java虚拟机参数" class="headerlink" title="第3章 常用Java虚拟机参数"></a>第3章 常用Java虚拟机参数</h1><p>本章知识点：</p>
<ul>
<li>跟踪Java虚拟机的垃圾回收和类加载等信息。</li>
<li>配置Java虚拟机的堆空间</li>
<li>配置永久区和Java栈</li>
<li>学习虚拟机的服务器和客户端模式</li>
</ul>
<h2 id="3-1-一切运行都有迹可循：掌握跟踪调试参数"><a href="#3-1-一切运行都有迹可循：掌握跟踪调试参数" class="headerlink" title="3.1 一切运行都有迹可循：掌握跟踪调试参数"></a>3.1 一切运行都有迹可循：掌握跟踪调试参数</h2><p>​    如果可以跟踪系统的运行状态，对故障排查会有一定帮助。</p>
<h3 id="3-1-1-跟踪垃圾回收——读懂虚拟机日志"><a href="#3-1-1-跟踪垃圾回收——读懂虚拟机日志" class="headerlink" title="3.1.1 跟踪垃圾回收——读懂虚拟机日志"></a>3.1.1 跟踪垃圾回收——读懂虚拟机日志</h3><p>​    Java一大特色就是支持自动垃圾回收(GC)。但是垃圾回收频繁，或者占用了太长CPU时间，就要引起重视。</p>
<p>​    最简单的一个GC参数就是-XX:+PrintGC(在JDK9, JDK10中建议使用-Xlog:gc), 加了参数后，只要遇到GC，就会打印日志。如下：</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66e6e7160a154a67dc971d.jpg" alt=""></p>
<p>​    日志显示，一共进行了4次GC，每次GC占一行。GC前，堆空间使用量4MB，在GC后，堆空间使用量为377K, 当前可用给的堆空间总和约为16MB(15935KB)。最后显示的是本次GC所花的时间。</p>
<p>​    JDK9, JDK10默认使用G1作为垃圾回收器。使用参数-Xlog:gc来打印GC日志。</p>
<p><img src="https://pic.imgdb.cn/item/5f66e7b0160a154a67dcc91a.jpg" alt=""></p>
<p>​    一共进行了1次GC，GC前，堆空间使用量16MB，GC后，堆空间使用量7MB。当前可用堆空间综合34MB。最后显示GC耗时，23.511。</p>
<p>​    如果需要更详尽的信息，可以使用-XX:+PrintGCDetails。JDK8(JDK9和JDK10建议使用-Xlog:gc*)的输出如下：</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66e837160a154a67dce821.jpg" alt=""></p>
<p>​    经历了3次GC，第一次仅为新生代GC，回收效果是新生代回收前从8MB左右降到了1MB。整个堆从22MB左右降低到17MB。</p>
<p>​    第2次(加粗部门)为Full GC，它同时回收了新生代、老年代和永久区。新生代在这次GC中没有释放空间(严格来说是GC日志的一个小bug事实上，这次Full GC后，新生代被清空，由于GC日志输出的时机，各个版本JDK日志多多少少有些不太精确的地方), 老年代从16MB降低到13MB。整个堆大小从26MB左右降低到13MB左右(大小完全与老年代时机大小相等，因此可以推断，新生代实际上已经被清空)。永久区没有发生变化。日志最后显示了GC所花时间，user表示用户态耗时，sys表示系统CPU耗时，real表示GC实际经历的时间。</p>
<p>​    该参数还会使虚拟机在退出前打印对的详细信息。详细信息描述了各个区间的使用情况。如上输出所示，当前新生代(new generation)总大小为9792KB, 已使用4586KB。紧跟其后的3个16进制数字表示新生代的下界、当前上界和上界。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66eb10160a154a67dd99aa.jpg" alt=""></p>
<p>​    使用上界减去下界就能得到当前堆空间的最大值，使用当前上界减去下界，就是当前虚拟机已经为程序分配的空间。如果当前上界等于下界，说明当前的堆空间已经没有扩大的可能性。</p>
<p>​    可能性。 在 本例 中（ 0x00000000f98a0000- 0x00000000f8e00000）/ 1024= 10880KB。 这块 空间 正好 等于 eden+ from+ to 的 总和。 而可 用的 新生代 9792KB 为 eden+ from（ to） 的 总和， 对于 两者 出现 差异 的 原因， 可以 参考 本书 第 4 章。</p>
<p>​    JDK9、JDK10使用参数-Xlog:gc*来打印更详细的GC日志，如下所示：</p>
<p><img src="https://pic.imgdb.cn/item/5f66eda5160a154a67de3862.jpg" alt=""></p>
<p>​    从输出中可以看到，堆最大可用大小为32MB, 系统经历了1次GC，为新生代GC，回收的效果是整个堆从14MB左右降到了1MB。JDK9、JDK10中，除了新生代、老年代，还新增了一个巨型区域，即上述输出中的Humongous regions。</p>
<p>​    另外，日志有详细的时间信息，第一列显Java程序的运行时间，Pause Young(G1 Evacuation Pause) 14-&gt;1M(32M) 7.028ms表示新生代垃圾回收花了7.028ms。</p>
<p>​    Pre Evacuate Collection Set, Evacuate Collection Set, Post Evacuate Collection Set, Other 代表G1垃圾回收标记-清除算法不同阶段所花费的时间。</p>
<p>​    如果需要更全面的堆信息，还可以使用-XX:+PrintHeapAtGC(考虑到兼容性，JDK9开始已经删除此参数，查看堆信息可以使用VisualVM)。它会在每次GC前、后分别打印对的信息。</p>
<p>​    如果需要GC发生时间，还可以使用-XX:PrintGCTimeStamps(JDK9, JDK10中使用-Xlog:gc*已经默认打印出时间)。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f076160a154a67df1f02.jpg" alt=""></p>
<p>​    由于GC会引起应用程序停顿，因此还需要特别关注应用程序的执行时间和停顿时间。使用参数-XX:+PrintGCApplicationConcurrentTime可以打印应用执行时间，使用参数-XX:+PrintGCApplicationStoppedTime可以打印应用程序由于GC而产生的停顿时间，如下所示：如果想跟踪系统内的软引用、弱引用、虚引用和Finallize队列，可以打开-XX:+PrintReferenceGC(考虑到兼容性，JDK9已经删除此参数)开关。</p>
<p>​    默认情况下，GC日志会在控制台输出，不便于后续分析和定位问题，所以虚拟机允许将GC日志以文件形式输出，可以使用-Xloggc指定。比如使用参数-Xloggc:log/gc.log(JDK9,10建议使用-Xlog:gc:log/gc.log)启动虚拟机。</p>
<h3 id="3-1-2-类加载-卸载的追踪"><a href="#3-1-2-类加载-卸载的追踪" class="headerlink" title="3.1.2 类加载/卸载的追踪"></a>3.1.2 类加载/卸载的追踪</h3><p>​    一般情况下，系统加载的类存在于文件系统中，以jar的形式打包或以class文件的形式存在，可以直接通过文件系统查看。</p>
<p>​    但是伴随动态代理，AOP等技术的普遍使用，系统也极有可能在运行时动态生成某些类，这些类相对比较隐蔽，无法通过文件系统找到。</p>
<p>​    使用参数-verbos:class最终类的加载/卸载。</p>
<p>​    也可以单独使用参数-XX:+TraceClassLoding(在JDK9, 10中建议使用-Xlog:class+load=info, 就跟JDK8中的参数-XX:+TraceClassLoding效果一样)跟踪类加载。</p>
<p>​    使用参数-XX:+TraceClassUnloading(在JDK9, JDK10中建议使用-Xlog:class+unload=info)跟踪类的加载。</p>
<p>​    下面代码使用ASM动态生成名为Example类，将其反复加载到系统中。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f3b0160a154a67dff7df.jpg" alt=""></p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66f3f6160a154a67e00800.jpg" alt=""></p>
<p>​    日志中可以看到，先加载了Object类，作为所有类的父类。后半部分显示，对Example类先后进行了10次加载和9次卸载</p>
<p>​    注意：动态类的加载非常隐蔽，由代码逻辑控制，不出现文件系统中。</p>
<p>​    Java虚拟机还允许研发人员在运行时打印、查看系统中类的分布情况，只要在系统启动时加上-XX:+PrintClassHistogram参数。然后在Java控制台中按下Ctrl+Break组合键，控制台就会显示当前类信息柱状图。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66f48f160a154a67e02703.jpg" alt=""></p>
<h3 id="3-1-3-查看系统参数"><a href="#3-1-3-查看系统参数" class="headerlink" title="3.1.3 查看系统参数"></a>3.1.3 查看系统参数</h3><p>​    由于系统支持众多可配置参数，不同参数对系统的执行效果有较大的影响，有必要确定当前系统实际运行参数。</p>
<p>​    参数-XX:+PrintVMOptions可以在程序运行时，打印虚拟机接收到的命令行显示参数。</p>
<p>​    参数-XX:+PrintCommandLineFlags可以打印传递给虚拟机的显示和隐式参数，隐式参数未必是通过命令行直接给出的，它可能是在虚拟机器启动时自动设置的。</p>
<p>​    另外一个有用的参数是-XX:+PrintFlagsFinal，它会打印所有的系统参数的值。开启这个参数后，可能会产生500多行参数。</p>
<h2 id="3-2-让性能飞起来：学习堆的配置参数"><a href="#3-2-让性能飞起来：学习堆的配置参数" class="headerlink" title="3.2 让性能飞起来：学习堆的配置参数"></a>3.2 让性能飞起来：学习堆的配置参数</h2><h3 id="3-2-1-最大堆和初始堆的设置"><a href="#3-2-1-最大堆和初始堆的设置" class="headerlink" title="3.2.1 最大堆和初始堆的设置"></a>3.2.1 最大堆和初始堆的设置</h3><p>​    Java进程启动时，虚拟机就会分配一块初始堆大小，可以使用参数-Xms指定这块空间的大小。如果初始堆空间耗尽，将会对堆空间进行扩展，其扩展的上限为最大对抗空间。最大堆空间可以使用参数-Xmx指定。</p>
<p>​    最大内存由-XX:MaxHeapSize=20971520指定。而打印的最大可用内存比设定值略少。因为分配给堆空间和实际的内存空间并非一个概念。由于垃圾回收需要，会对堆空间进行分区管理，一些算法会使用空间换时间的策略，因此会存在可用内存的损失。</p>
<p>​    最终结果就是实际可用内存会浪费大小等于from/to的空间。因此最大可用内存为-Xmx减去from的值。这样算下来可能还会有偏差，是因为虚拟机内存进一步对堆的from/to做了对齐操作。对于串行GC的情况，虚拟机使用一下方法估算from/to的大小。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f79a160a154a67e0c6d6.jpg" alt=""></p>
<p>​    提示：在实际工作中，也可以将初始堆和最大堆设置为相等，这样的好处是，可以减少程序运行时，进行垃圾回收的次数，从而提高程序的性能。</p>
<h3 id="3-2-2-新生代的配置"><a href="#3-2-2-新生代的配置" class="headerlink" title="3.2.2 新生代的配置"></a>3.2.2 新生代的配置</h3><p>​    参数-Xmn可以用于设置新生代的大小。设置一个新生代会减少老年代的大小，这个参数对系统性能有很大影响。新生代大小一般为整个堆空间的1/3到1/4.</p>
<p>​    参数-XX:SurvivorRatio用来设置新生代中eden区和from/to区的比例。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f8cd160a154a67e10eed.jpg" alt=""></p>
<p>(1)使用- Xmx20m- Xms20m- Xmn1m- XX: SurvivorRatio= 2- XX:+ PrintGCDetails 运行 上述 Java 程序。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f8f3160a154a67e1195a.jpg" alt=""></p>
<p>​    eden 区 与 from 区 的 比值 为 2 ∶ 1， 故 eden 区 为 512KB。 总可 用 新生代 大小 为 512KB+ 256KB= 768KB， 新生代 总大小 为 512KB+ 256KB+ 256KB= 1024KB= 1MB。</p>
<p>​     由于 eden 区 无法 容纳 任何 一个 程序 中 分配 的 1MB 数组， 故 触发 了 一次 新生代 GC， 对 eden 区 进行 了 部分 回收。 同时， 这个 偏小 的 新生代 无法 为 1MB 数组 预留 空间， 故 所有 的 数组 都 分配 在 老 年代， 老年 代 最终 占用 10354KB 空间。</p>
<p>（2） 使用 参数- Xmx20m- Xms20m- Xmn7m- XX: SurvivorRatio= 2- XX:+ PrintGCDetails 运行 上述 程序， 将 新生代 扩大 为 7MB。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f952160a154a67e12fd9.jpg" alt=""></p>
<p>​    在这 个 参数 下， 由于 eden 区 有 足够 的 空间， 因此 所有 的 数组 都 分配 在 eden 区。 但 eden 区 并不 足以 预留 10MB 的 空间， 故在 程序 运行 期间 出现 了 3 次 新生代 GC。 由于 每 申请 一次 空间， 同时 也 废弃 了 上一次 申请 的 空间（ 上一次 申请 的 内存 失去 了 引用）， 故在 新生代 GC 中， 有效 回收 了 这些 失效 的 内存。 最终 结果是： 所有 的 内存 分配 都在 新生代 进行， 通过 GC 保证 了 新生代 有 足够 的 空间， 而 老年 代 没有 为 这些 数组 预留 任何 空间， 只是 在 GC 过程中， 部分 新生代 对象 晋升 到 老 年代。</p>
<p>（3） 使用 参数- Xmx20m- Xms20m- Xmn15m- XX: SurvivorRatio= 8- XX:+ PrintGCDetails 运行</p>
<p><img src="https://pic.imgdb.cn/item/5f66f983160a154a67e13bb6.jpg" alt=""></p>
<p>​    在这 次 执行 中， 由于 新生代 使用 15MB 空间， 其中 eden 区 占用 了 12288KB， 完全 满足 10MB 数组 的 分配， 因此 所有 的 分配 行为 都在 eden 区 直接进行， 且 没有 触发 任何 GC 行为。 因此 from/ to 和 老 年代 tenured 的 使用 率 都为 0。</p>
<p>​    在实际工作中，应该根据系统特点做合理设置，基本策略是：尽可能将对象预留在新生代，减少老年代GC的次数。</p>
<p>​    除了可以使用参数-Xmn指定新生代的大小，还可以试用参数-XX:NewRatio来设置新生代和老年代的比例。</p>
<p><img src="https://pic.imgdb.cn/item/5f66f9ed160a154a67e15329.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f66fa5e160a154a67e16d56.jpg" alt=""></p>
<h3 id="3-2-3-堆溢出处理"><a href="#3-2-3-堆溢出处理" class="headerlink" title="3.2.3 堆溢出处理"></a>3.2.3 堆溢出处理</h3><p>​    如果堆空间不足，则有可能OOM。</p>
<p>​    如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，要获取尽可能多的现场信息，以帮助研发人员排查问题。</p>
<p>​    提供了参数-XX:+HeapDumpOnOutOfMemeoryError，可以在内存溢出时导出整个堆的信息。可以配合使用的还有-XX:HeapDumpPath。</p>
<p>​    除了在OOM导出堆信息，还允许在发生错误时执行一个脚本。可以用于崩溃的程序自救、报警或通知。可以帮助开发人员获得更多的系统信息，比如完整的系统转存文件。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f66fb8a160a154a67e1b492.jpg" alt=""></p>
<h2 id="3-3-别让性能有缺口：了解非堆内存的参数配置"><a href="#3-3-别让性能有缺口：了解非堆内存的参数配置" class="headerlink" title="3.3 别让性能有缺口：了解非堆内存的参数配置"></a>3.3 别让性能有缺口：了解非堆内存的参数配置</h2><h3 id="3-3-1-方法区配置"><a href="#3-3-1-方法区配置" class="headerlink" title="3.3.1 方法区配置"></a>3.3.1 方法区配置</h3><p>​    方法 区 主要 存放 类 的 元 信息。 在 JDK 1. 6 和 JDK 1. 7 等 版本 中， 可以 使用- XX: PermSize 和- XX: MaxPermSize 配置 永久 区 大小。 其中，- XX: PermSize 表示 初始 的 永久 区 大小，- XX: MaxPermSize 表示 最大 永久 区 大小。 </p>
<p>​    从 JDK 1. 8 开始， 永久 区 被 彻底 移 除， 使用 了 新的 元 数据区 存放 类 的 元 数据。 在 默认 情况下， 元 数据区 只 受 系统 可用 内存 的 限制， 但 依然 可以 使用 参数- XX: MaxMetaspaceSize 指定 永久 区 的 最大 可用 值。 方法 区 的 详细 使用 和 配置 可以 参考 2. 5 节。</p>
<h3 id="3-3-2-栈配置"><a href="#3-3-2-栈配置" class="headerlink" title="3.3.2 栈配置"></a>3.3.2 栈配置</h3><p>​    可以用-Xss参数指定线程的栈大小。</p>
<h3 id="3-3-3-直接内存配置"><a href="#3-3-3-直接内存配置" class="headerlink" title="3.3.3 直接内存配置"></a>3.3.3 直接内存配置</h3><p>​    武断 地 认为 使用 直接 内存 一定 可以 提高 内存 访问 速度 也是 不正确 的。</p>
<p>​    最大 可用 直接 内存 可以 使用 参数- XX: MaxDirectMemorySize 设置， 如果不 设置， 默认值 为最 大堆 空间， 即- Xmx 的 值。 当 直接 内存 使用 量 达到- XX: MaxDirectMemorySize 时， 就会 触发 垃圾 回收， 如果 垃圾 回收 不能 有效 释放 足够 的 空间， 直接 内存 溢出 依然 会 引起 系统 的 OOM。</p>
<p>​    虽然 在 访问 读写 上 直接 内存 有 较大 的 优势， 但是 在内 存 空间 申请 时， 直接 内存 毫无 优势 可言。在 申请 内存 空间 时， 堆 空间 的 速度 远远 快于 直接 内存。</p>
<p>​    结论： 直接 内存 适合 申请 次数 较少、 访问 较 频繁 的 场合。 如果 需要 频繁 申请 内存 空间， 则 并不 适合 使用 直接 内存。</p>
<h2 id="3-4-Client和Server二选一：虚拟机工作模式"><a href="#3-4-Client和Server二选一：虚拟机工作模式" class="headerlink" title="3.4 Client和Server二选一：虚拟机工作模式"></a>3.4 Client和Server二选一：虚拟机工作模式</h2><p>​    参数-client指定Client模式，-server指定server模式。</p>
<p>​    与 Client 模式 相比， Server 模式 的 启动 比较慢， 因为 Server 模式 会 尝试 收集 更多 的 系统 性能 信息， 使用 更 复杂 的 优化 算法 对 程序 进行 优化。因此， 当 系统 完全 启动 并进 入 运行 稳 定期 后， Server 模式 的 执行 速度 会 远远 快于Client 模式。 所以， 对于 后台 长期 运行 的 系统 来说， 使用- server 参数 启动 对 系统 的 整体 性能 可以 有不 小的 帮助。 但对 于 用户 界面 程序 而言， 运行 时间 不长， 又 追求 启动 速度， Client 模式 也是 不错 的 选择。</p>
<p>​    在64位系统中，虚拟机更倾向于使用Server模式。</p>
<p>​    虚拟 机 在 Server 模式 和 Client 模式 下 的 各种 参数 可能 会有 很大 的 不同， 读者 如果 需要 查看 给定 参数 的 默认值， 可以 使用- XX:+ PrintFlagsFinal 参数。 这里 以 JIT 编译 阈值 和 最大 堆 为例， 展示 Client 模式 和 Server 模式 的 区别。</p>
<p>​    在 Client 模式 下， CompileThreshold 的 默认值 为 1500， 即 函数 被 调用 1500 次 后， 会 进行 JIT 编译（ 有关 JIT 编译 的 更多 细节 请参阅 第 11 章）。 而在 Server 模式 下， 这个 数值 为 10000。 因此， 在 Server 模式 下 系统 更有 可能 解释 执行。 而 一旦 进行 编译， Server 模式 的 优化 效果 会好 于 Client 模式。 对于 系统 最 大堆， 在 Client 模式 下 为 约 256MB， 而在 Server 模式 下 约为 1GB。</p>
<h1 id="第4章-垃圾回收的概念与算法"><a href="#第4章-垃圾回收的概念与算法" class="headerlink" title="第4章 垃圾回收的概念与算法"></a>第4章 垃圾回收的概念与算法</h1><p>知识点：</p>
<ul>
<li>了解什么是垃圾回收</li>
<li>学习几种常用的垃圾回收算法</li>
<li>掌握可触及的概念</li>
<li>理解Stop-The-World(STW)</li>
</ul>
<h2 id="4-1-内存管理清洁工：认识垃圾回收"><a href="#4-1-内存管理清洁工：认识垃圾回收" class="headerlink" title="4.1 内存管理清洁工：认识垃圾回收"></a>4.1 内存管理清洁工：认识垃圾回收</h2><p>​    开发人员只需要关注内存的申请，而内存的释放由系统自动识别和完成。</p>
<h2 id="4-2-清洁工具打PK：讨论常用的垃圾回收算法"><a href="#4-2-清洁工具打PK：讨论常用的垃圾回收算法" class="headerlink" title="4.2 清洁工具打PK：讨论常用的垃圾回收算法"></a>4.2 清洁工具打PK：讨论常用的垃圾回收算法</h2><h3 id="4-2-1-引用计数法-Reference-Counting"><a href="#4-2-1-引用计数法-Reference-Counting" class="headerlink" title="4.2.1 引用计数法(Reference Counting)"></a>4.2.1 引用计数法(Reference Counting)</h3><p>​    有两个问题：</p>
<p>(1) 无法处理循环引用</p>
<p>(2) 引用计算器要求在每次引用产生和消除的时候，伴随一个加法操作和一个减法操作，对系统性能有一定影响。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f68960a160a154a679c2ec7.jpg" alt=""></p>
<h3 id="4-2-2-标记清除算法-Mark-Sweep"><a href="#4-2-2-标记清除算法-Mark-Sweep" class="headerlink" title="4.2.2 标记清除算法(Mark-Sweep)"></a>4.2.2 标记清除算法(Mark-Sweep)</h3><p>​    分为两个阶段：标记阶段和清除阶段。</p>
<p>​    在标记阶段，首先通过根节点标记所有从根节点开始的可达对象。然后在清除节点，清除所有未被标记的对象。标记清除的最大问题是可能产生空间碎片。</p>
<p><img src="https://pic.imgdb.cn/item/5f68996a160a154a679f1344.jpg" alt=""></p>
<h3 id="4-2-3-复制算法-Copying"><a href="#4-2-3-复制算法-Copying" class="headerlink" title="4.2.3 复制算法(Copying)"></a>4.2.3 复制算法(Copying)</h3><p>​    核心思想是：将原有内存空间分成两块，每次使用其中一块，在进行垃圾回收时，将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>​    代价是将内存折半。</p>
<p><img src="https://pic.imgdb.cn/item/5f689a09160a154a679f960f.jpg" alt=""></p>
<p>​    在新生代串行垃圾回收器中，使用了复制算法思想。新生代分为eden区、from区和to区。from区和to区也称为survivor区，用于存放未被回收的对象。</p>
<ul>
<li><p>新生代： 存放 年轻 对象 的 堆 空间。 年轻 对象 指 刚刚 创建 的 或者 经历 垃圾 回收 次数 不多 的 对象。 </p>
</li>
<li><p>老 年代： 存放 老年 对象 的 堆 空间。 老年 对象 指 经历 多次 垃圾 回收 后 依然 存活 的 对象。</p>
</li>
</ul>
<p>​    在 进行 垃圾 回收 时， eden 区 的 存活 对象 会被 复制 到 未使 用的 survivor 区（ 假设 是 to 区）， 正在 使用 的 survivor 区（ 假设 是 from） 的 年轻 对象 也会 被 复制 到 to 区（ 大 对象 或者 老年 对象 会 直接 进入 老 年代， 如果 to 区 已满， 则 对象 也会 直接 进入 老 年代）。 此时， eden 区 和 from 区 的 剩余 对象 就是 垃圾 对象， 可以 直接 清空， to 区 则 存放 此次 回收 后的 存活 对象。 这种 改进 的 复制 算法， 既 保证 了 空间 的 连续性， 又 避免 了 大量 的 内存 空间 浪费，</p>
<p><img src="https://pic.imgdb.cn/item/5f689c3c160a154a67a169f9.jpg" alt=""></p>
<p>注意： 复制 算法 比较 适合 新生代， 因为 在 新生代 垃圾 对象 通常 会 多于 存活 对象， 复制 算法 的 效果 会 比较 好。</p>
<h3 id="4-2-4-标记压缩算法-Mark-Compact"><a href="#4-2-4-标记压缩算法-Mark-Compact" class="headerlink" title="4.2.4 标记压缩算法(Mark-Compact)"></a>4.2.4 标记压缩算法(Mark-Compact)</h3><p>​    也叫标记整理算法。</p>
<p>​    由于 存活 对象 较多， 复制 的 成本 将 很高。</p>
<p>​    标记 压缩 法 是一 种 老 年代 的 回收 算法。 它在 标记 清 除法 的 基础上 做了 一些 优化。 和 标记 清除 法 一样， 标记 压缩 法 首先 也需 要从 根 节点 开始， 对 所有 可达 对象 做 一次 标记。 但 之后， 它 并不 只是 简单 地 清理 未标 记的 对象， 而是 将 所有 的 存活 对象 压缩 到 内存 的 一端。 然后， 清理 边界 外 所有 的 空间。 这种 方法 既 避免 了 碎片 的 产生， 又不 需要 两块 相同 的 内存 空间， 性 价 比 较高。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f689ca0160a154a67a1bbb9.jpg" alt=""></p>
<p>标记 压缩 法 的 最终 效果 等同 于 标记 清除 法 执行 完成 后再 进行 一次 内存 碎片 整理， 因此， 也可以 把 它 称为 标记 清除 压缩 法。</p>
<h3 id="4-2-5-分代算法-Generational-Collecting"><a href="#4-2-5-分代算法-Generational-Collecting" class="headerlink" title="4.2.5 分代算法(Generational Collecting)"></a>4.2.5 分代算法(Generational Collecting)</h3><p>​    分代算法将内存区间根据对象的特点分成几块，根据每块内存的区间的特点使用不同的回收算法，以提高垃圾回收效率。</p>
<p><img src="https://pic.imgdb.cn/item/5f689e46160a154a67a313df.jpg" alt=""></p>
<p>​    通常 新生代 回收 的 频率 很高， 但是 每次 回收 的 耗时 很短， 而 老年 代 回收 的 频率 比 较低， 但是 会 消耗 更多 的 时间。 为了 支持 高频率 的 新生代 回收， 虚拟 机 可能 使用 一种 叫作 卡 表（ Card Table） 的 数据 结构。 卡 表为 一个 比特 位 集合， 每一个 比特 位 可以 用来 表示 老 年代 的 某一 区域 中的 所有 对象 是否 持有 新生代 对象 的 引用。</p>
<p>​    这样 在 新生代 GC 时， 可以 不用 花 大量 时间 扫描 所有 的 老年 代 对象 来 确定 每一个 对象 的 引用 关系， 可以 先 扫描 卡 表， 只有 当 卡 表 的 标记 位 为 1 时， 才 需要 扫描 给定 区域 的 老年 代 对象， 而 卡 表 位 为 0 的 老年 代 对象， 一定 不 含有 新生代 对象 的 引用。</p>
<p><img src="https://pic.imgdb.cn/item/5f689ead160a154a67a3738c.jpg" alt=""></p>
<h3 id="4-2-6-分区算法-Region"><a href="#4-2-6-分区算法-Region" class="headerlink" title="4.2.6 分区算法(Region)"></a>4.2.6 分区算法(Region)</h3><p>​    分 代 算法 将 按照 对象 的 生命 周期 长短 划分 成 两个 部分， 分区 算法 将 整个 堆 空间 划分 成 连续 的 不同 小 区间。</p>
<p>​    所示。 每一个 小 区间 都 独立 使用， 独立 回收。 这种 算法 的 好处 是 可以 控制 一次 回收 小区 间的 数量。</p>
<p>​    在 相同 条件下， 堆 空间 越大， 一次 GC 所需 要的 时间 就 越长， 从而 产生 的 停顿 也 越长（ GC 产生 的 停顿 请 参见 4. 4 节）。 为了 更好 地 控制 GC 产生 的 停顿 时间， 将 一块 大的 内存 区域 分割 成 多个 小块， 根据 目标 停顿 时间， 每次 合理 地 回收 若干个 小 区间， 而 不是 回收 整个 堆 空间， 从而 减少 一次 GC 所 产生 的 停顿。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f68a036160a154a67a46732.jpg" alt=""></p>
<h2 id="4-3-谁才是真正的垃圾：判断可触及性"><a href="#4-3-谁才是真正的垃圾：判断可触及性" class="headerlink" title="4.3 谁才是真正的垃圾：判断可触及性"></a>4.3 谁才是真正的垃圾：判断可触及性</h2><p>​    垃圾 回收 的 基本 思想 是 考查 每一个 对象 的 可 触及 性， 即从 根 节点 开始 是否 可以 访问 这个 对象， 如果 可以， 则 说明 当前 对象 正在 被 使用， 如果 从 所 有的 根 节点 开始 都无 法 访问 到 某个 对象， 说明 该 对象 已经 不再 使用 了， 一般来说， 该 对象 需要 被 回收。 但 事实上， 一个 无法 触及 的 对象 有可 能在 某个 条件下 使 自己“ 复活”， 如果 是 这样 的 情况， 那么 对 它的 回收 就是 不合理 的， 为此， 需要 给出 一个 对象 可触 及 性 状态 的 定义， 并 规定 在什么 状态 下 才可 以 安全 地 回收 对象。</p>
<ul>
<li>可触及的：从根节点，可以到达这个对象。</li>
<li>可符合的：对象的所有引用都被释放，但是对象有可能在finalize()函数中复活。</li>
<li>不可触及的：对象的finalize()函数被调用，并没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为finalize()函数只会被调用一次。</li>
</ul>
<h3 id="4-3-1-对象的复活"><a href="#4-3-1-对象的复活" class="headerlink" title="4.3.1 对象的复活"></a>4.3.1 对象的复活</h3><p>​    对象有可能在finalize函数中使自己复活。</p>
<p>​    注意： finalize() 函数 是一 个 非常 糟糕 的 模式， 不 推荐 读者 使用 finalize() 函数 释放 资源。</p>
<p>​    第一， 因为 finalize() 函数 有可能 发生 引用 外 泄， 在 无意中 复活 对象；</p>
<p>​    第二， 由于 finalize() 函数 是 被 系统 调用 的， 调用 时间 是 不明确 的， 因此 不是 一个 好的 资源 释放 方案， 推荐 在 try- catch- finally 语句 中进 行 资源 的 释放。</p>
<h3 id="4-3-2-引用和可触及性的强度"><a href="#4-3-2-引用和可触及性的强度" class="headerlink" title="4.3.2 引用和可触及性的强度"></a>4.3.2 引用和可触及性的强度</h3><p>​    在 Java 中 提供 了 4 个 级别 的 引用： 强 引用、 软 引用、 弱 引用 和 虚 引用。 除 强 引用 外， 其他 3 种 引用 均可 以在 java. lang. ref 包 中 找到。</p>
<p>​    其中 FinalReference 为“ 最终” 引用， 它 用以 实现 对象 的 finalize（） 函数（</p>
<p>​    强 引用 就是 程序 中 一般 使用 的 引用 类型， 强 引用 的 对象 是 可 触及 的， 不会 被 回收。 软 引用、 弱 引用 和 虚 引用 的 对 象是 软 可 触及、 弱 可 触及 和 虚 可 触及 的， 在 一定 条件下 都是 可以 被 回收 的。</p>
<p>强 引用 具备 以下 特点：</p>
<ul>
<li><p>强 引用 可以 直接 访问 目标 对象。</p>
</li>
<li><p>强 引用 所 指向 的 对象 在 任何时候 都不 会被 系统 回收， 虚拟 机 宁愿 抛出 OOM 异常， 也不 会 回收 强 引用 所 指向的 对象。</p>
</li>
<li><p>强 引用 可能 导致 内存 泄漏。</p>
</li>
</ul>
<h3 id="4-3-3-软引用——可被回收的引用"><a href="#4-3-3-软引用——可被回收的引用" class="headerlink" title="4.3.3 软引用——可被回收的引用"></a>4.3.3 软引用——可被回收的引用</h3><p>软 引用 是 比 强 引用 弱 一点 的 引用 类型。 如果 一个 对象 只 持有 软 引用， 那么 当 堆 空间 不足 时， 就会 被 回收。 软 引用 使用 java. lang. ref. SoftReference 类 实现。</p>
<p>每一个 软 引用 都可以 附带 一个 引用 队列， 当 对象 的 可达 性 发生 改变 时（ 由 可达 变为 不 可达）， 软引用 对象 就会 进入 引用 队列。 通过 这个 引用 队列， 可以 跟踪 对象 的 回收 情况。</p>
<p><img src="https://pic.imgdb.cn/item/5f68a826160a154a67aaf771.jpg" alt=""></p>
<h3 id="4-3-4-弱引用——发现即回收"><a href="#4-3-4-弱引用——发现即回收" class="headerlink" title="4.3.4 弱引用——发现即回收"></a>4.3.4 弱引用——发现即回收</h3><p>​    弱 引用 是 一种 比 软 引用 弱 的 引用 类型。 在 系统 GC 时， 只要 发现 弱 引用， 不管 系统 堆 空间 使用 情况 如何， 都会 将对 象 进行 回收。 但是， 由于 垃圾 回收 器 的 线程 通常 优先级 很低， 并不 一定 能 很快 地 发现 持有 弱 引用 的 对象。 在 这种 情况下， 弱 引用 对象 可以 存在 较长 的 时间。 一旦 一个 弱 引用 对象 被 垃圾 回收 器 回收， 便会 加入 一个 注册 的 引用 队列（ 这一点 和 软 引用 很像）。 弱 引用 使用 java. lang. ref. WeakReference 类 实现。</p>
<p>​    弱 引用 和 软 引用 一样， 在 构造 弱 引用 时， 也可以 指定 一个 引用 队列， 当 弱 引用 对象 被 回收 时， 就会 加入 指定 的 引用 队列， 通过 这个 队列 可以 跟踪 对象 的 回收 情况。</p>
<p>注意： 软 引用、 弱 引用 都 非常 适合 保存 那些 可有可无 的 缓存 数据。 如果 这么 做， 当 系统 内存 不足 时， 这些 缓存 数据 会被 回收， 不会 导致 内存 溢出。 而 当 内存 资源 充足 时， 这些 缓存 数据 又可 以 存在 相当 长的 时间， 从而 起到 让 系统 加速 的 作用。</p>
<h3 id="4-3-5-虚引用——对象回收跟踪"><a href="#4-3-5-虚引用——对象回收跟踪" class="headerlink" title="4.3.5 虚引用——对象回收跟踪"></a>4.3.5 虚引用——对象回收跟踪</h3><p>​    虚 引用 是 所有 引用 类型 中 最弱 的 一个。 一个 持有 虚 引用 的 对象， 和 没有 引用 几乎 是 一样 的， 随时 都可 能被 垃圾 回收 器 回收。 当 试图 通过 虚 引用 的 get() 方法 取得 强 引用 时， 总会 失败。 并且， 虚 引用 必须 和 引用 队列 一起 使用， 它的 作用 在于 跟踪 垃圾 回收 过程。</p>
<p>​    由于 虚 引用 可以 跟踪 对象 的 回收 时间， 所以 也可以 将 一些 资源 释放 操作 放在 虚 引用 中 执行 和 记录。</p>
<h2 id="4-4-垃圾回收时的停顿现象：Stop-TheWorld实战"><a href="#4-4-垃圾回收时的停顿现象：Stop-TheWorld实战" class="headerlink" title="4.4 垃圾回收时的停顿现象：Stop-TheWorld实战"></a>4.4 垃圾回收时的停顿现象：Stop-TheWorld实战</h2><p>​    垃圾 回收 器 的 任务 是 识别 和 回收 垃圾 对象， 以 进行 内存 清理。 为了 让 垃圾 回收 器 可以 正常 且 高效 地 执行， 在 大部分 情况下， 会要 求 系统 进入 一个 停顿 的 状态。 停顿 的 目的 是 终止 所有 应用 线程 的 执行， 只有 这样 系统 中 才不 会有 新的 垃圾 产生， 同时 停顿 保证 了 系统 状态 在某 一个 瞬间 的 一致性， 也有 益于 垃圾 回收 器 更好 地 标记 垃圾 对象。 因此， 在 垃圾 回收 时， 都会 产生 应用 程序 的 停顿。 停顿 产生 时， 整个 应用 程序 会被 卡 死， 没有 任何 响应， 因此 这个 停顿 也 叫作“ Stop- The- World”（ STW）。</p>
<p>​    例子略。</p>
<h1 id="第5章-垃圾收集器和内存分配"><a href="#第5章-垃圾收集器和内存分配" class="headerlink" title="第5章 垃圾收集器和内存分配"></a>第5章 垃圾收集器和内存分配</h1><p>知识点：</p>
<ul>
<li>Java虚拟机支持的垃圾回收器种类</li>
<li>串行垃圾回收器</li>
<li>并行垃圾回收器</li>
<li>CMS回收器</li>
<li>G1回收器</li>
<li>有关对象分配的一些细节问题</li>
</ul>
<h2 id="5-1-一心一意一件事：串行回收器"><a href="#5-1-一心一意一件事：串行回收器" class="headerlink" title="5.1 一心一意一件事：串行回收器"></a>5.1 一心一意一件事：串行回收器</h2><p>串行回收器是指使用单线程进行垃圾回收的回收器。</p>
<p>对于 并行 能力 较弱 的 计算机 来说， 串行 回收 器 的 专注 性 和 独占 性 往往 能 让 其 有 更好 的 性能 表现。 串行 回收 器 可以 在 新生代 和 老年 代 使用， 根据 不同 的 堆 空间 分为 新生代 串行 回收 器 和 老年 代 串行 回收 器。</p>
<h3 id="5-1-1-新生代串行回收器"><a href="#5-1-1-新生代串行回收器" class="headerlink" title="5.1.1 新生代串行回收器"></a>5.1.1 新生代串行回收器</h3><p>两个特点</p>
<ul>
<li>仅仅使用单线程进行垃圾回收</li>
<li>是独占式的垃圾回收方式。</li>
</ul>
<p>在 串行 回收 器 进行 垃圾 回收 时， Java 应用 程序 中的 线程 都 需要 暂停 工作， 等待 垃圾 回收 完成。</p>
<p><img src="https://pic.imgdb.cn/item/5f69f9e2160a154a67573d4c.jpg" alt=""></p>
<p>​    新生代 串行 回收 器 使用 复制 算法， 实现 相对 简单、 逻辑 处理 特别高 效 且 没有 线程 切换 的 开销。 在 诸如 单 CPU 处理器 等 硬件 平台 不是 特别 优越 的 情况下， 它的 性能 表现 可以 超过 并行 回收 器 和 并发 回收 器。</p>
<p>使用- XX:+ UseSerialGC 参数 可以 指定 使用 新生代 串行 回收 器 或 老年 代 串行 回收 器。 当 虚拟 机 在 Client 模式 下 运行时， 它是 默认 的 垃圾 回收 器。</p>
<p>注意：串行 垃圾 回收 器 虽然 古老， 但是 久经考验， 在 大多数 情况下， 其 性能 表现 是 相当 不错 的。</p>
<h3 id="5-1-2-老年代串行回收器"><a href="#5-1-2-老年代串行回收器" class="headerlink" title="5.1.2 老年代串行回收器"></a>5.1.2 老年代串行回收器</h3><p>作为 老牌 的 垃圾 回收 器， 老年 代 串行 回收 器 可以 和 多种 新生代 回收 器 配合 使用， 同时 它 也可以 作为 CMS 回收 器 的 备用 回收 器。</p>
<ul>
<li>-XX：+ UseSerialGC： 新生代、 老 年代 都 使用 串行 回收 器。</li>
<li>-XX：+ UseParNewGC（ JDK 9、 JDK 10 已经 删除， 因为 ParNew 需要 和 CMS 搭配 工作， 而 CMS 已经 被 G1 替代， 不再 支持 此 参数）： 新生代 使用 ParNew 回收 器， 老年 代 使用 串行 回收 器。</li>
<li>-XX：+ UseParallelGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 串行 回收 器。</li>
</ul>
<h2 id="5-2-人多力量大：并行回收器"><a href="#5-2-人多力量大：并行回收器" class="headerlink" title="5.2 人多力量大：并行回收器"></a>5.2 人多力量大：并行回收器</h2><h3 id="5-2-1-新生代ParNew回收器"><a href="#5-2-1-新生代ParNew回收器" class="headerlink" title="5.2.1 新生代ParNew回收器"></a>5.2.1 新生代ParNew回收器</h3><p>它 只是 简单 地 将 串行 回收 器 多 线程 化， 它的 回收 策略、 算法 及 参数 和 新生代 串行 回收 器 一样。</p>
<p><img src="https://pic.imgdb.cn/item/5f69fabc160a154a6757a32c.jpg" alt=""></p>
<ul>
<li>-XX：+ UseParNewGC（ JDK 9、 JDK 10 已经 删除， 因为 ParNew 需要 和 CMS 搭配 工作， 而 CMS 已经 被 G1 替代， 不再 支持 此 参数）： 新生代 使用 ParNew 回收 器， 老年 代 使用 串行 回收 器。</li>
<li>-XX：+ UseConcMarkSweepGC（ JDK 9、 JDK 10 不 建议 使用， 建议 使用 默认 的 G1 垃圾 回收 器）： 新生代 使用 ParNew 回收 器， 老年 代 使用 CMS。</li>
</ul>
<p>​    ParNew 回收 器 工作 时 的 线程 数量 可以 使用- XX: ParallelGCThreads 参数 指定。 一般， 最好 与 CPU 数量 相当， 避免 过多 的 线程 数 影响 垃圾 回收 性能。 在 默认 情况下， 当 CPU 数量 小于 8 时， ParallelGCThreads 的 值 等于 CPU 数量， 当 CPU 数量 大于 8 时， ParallelGCThreads 的 值 等于 3+(( 5 × CPU_ Count)/ 8)。</p>
<h3 id="5-2-2-新生代ParallelGC回收器"><a href="#5-2-2-新生代ParallelGC回收器" class="headerlink" title="5.2.2 新生代ParallelGC回收器"></a>5.2.2 新生代ParallelGC回收器</h3><p>​    从 表面 上看， 它 和 ParNew 回收 器 一样， 都是 多 线程、 独占 式 的 回收 器。 但是， ParallelGC 回收 器 有一个 重要的 特点： 它 非常 关注 系统 的 吞吐量。</p>
<ul>
<li><p>-XX：+ UseParallelGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 串行 回收 器。 </p>
</li>
<li><p>-XX：+ UseParallelOldGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 ParallelOldGC 回收 器。 </p>
</li>
</ul>
<p>  ParallelGC 回收 器 提供 了 两个 重要的 参数 用于 控制系统 的 吞吐量。</p>
<ul>
<li><p>-XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。 它的 值 是一 个大 于 0 的 整数。 ParallelGC 在 工作 时， 会 调整 Java 堆 大小 或者 其他 参数， 尽可能 地 把 停顿 时间 控制 在 MaxGCPauseMillis 以内。 如果 读者 希望 减少 停顿 时间 而 把 这个 值 设 得很 小， 为了 达到 预期 的 停顿 时间， 虚拟 机 可能 会使 用 一个 较 小的 堆（ 一个 小堆 比 一个 大堆 回收 快）， 而这 将 导致 垃圾 回收 变得 很 频繁， 从而 增加 垃圾 回收 总 时间， 降低 吞吐量。 </p>
</li>
<li><p>-XX： GCTimeRatio： 设置 吞吐量 大小。 它的 值 是 一个 0 到 100 之间 的 整数。 假设 GCTimeRatio 的 值 为 n， 那么 系统 将 花费 不超过 1/（ 1+ n） 的 时间 进行 垃圾 回收。 比如 GCTimeRatio 等于 19（ 默认值）， 则 系统 用于 垃圾 回收回收 的 时间 不超过 1/（ 1+ 19）= 5%。 默认 情况下， 它的 取值 是 99， 即有 不超过 1/（ 1+ 99）= 1% 的 时间 用于 垃圾 回收。</p>
</li>
</ul>
<p>​    还 支持 一种 自 适应 的 GC 调节 策略。 使用- XX:+ UseAdaptiveSizePolicy 可以 打开 自 适应 GC 策略。 在这 种 模式 下， 新生代 的 大小、 eden 区 和 survivor 区 的 比例、 晋升 老 年代 的 对象 年龄 等 参数 会被 自动 调整， 以 达到 在 堆 大小、 吞吐量 和 停顿 时间 之间 的 平衡 点。</p>
<h3 id="5-2-3-老年代ParallelOldGC会后器"><a href="#5-2-3-老年代ParallelOldGC会后器" class="headerlink" title="5.2.3 老年代ParallelOldGC会后器"></a>5.2.3 老年代ParallelOldGC会后器</h3><p>​    ParallelOldGC 回收 器 使用 标记 压缩 法， 它在 JDK1. 6 中 才可 以 使用。</p>
<p><img src="https://pic.imgdb.cn/item/5f69fd2a160a154a6758af56.jpg" alt=""></p>
<p>使用- XX:+ UseParallelOldGC 可以 在 新生代 使用 ParallelGC 回收 器， 老年 代 使用 ParallelOldGC 回收 器。</p>
<p>参数- XX: ParallelGCThreads 也可以 用于 设置 垃圾 回收 时 的 线程 数量。</p>
<h2 id="5-3-一心多用都不落下：CMS回收器-JDK8及之前的版本"><a href="#5-3-一心多用都不落下：CMS回收器-JDK8及之前的版本" class="headerlink" title="5.3 一心多用都不落下：CMS回收器(JDK8及之前的版本)"></a>5.3 一心多用都不落下：CMS回收器(JDK8及之前的版本)</h2><h3 id="5-3-1-CMS主要工作步骤"><a href="#5-3-1-CMS主要工作步骤" class="headerlink" title="5.3.1 CMS主要工作步骤"></a>5.3.1 CMS主要工作步骤</h3><p>​    CMS 工作 时 的 主要 步骤 有： 初始 标记、 并发 标记、 预 清理、 重新 标记、 并发 清除 和 并发 重置。</p>
<p><img src="https://pic.imgdb.cn/item/5f69fddf160a154a6759083d.jpg" alt=""></p>
<p>​    根据 标记 清除 法， 初始 标记、 并发 标记 和 重新 标记 都是 为了 标记 出 需要 回收 的 对象。 并发 清理 则是 在 标记 完成 后， 正式 回收 垃圾 对象。 并发 重置 是指 在 垃圾 回收 完成 后， 重新 初始化 CMS 数据 结构 和 数据， 为 下一 次 垃圾 回收 做好 准备。 并发 标记、 并发 清理 和 并发 重置 都是 可以 和 应用 程序 线程 一起 执行 的。</p>
<pre><code>默认 情况下， 在 并发 标记 之后， 会有 一个 预 清理 的 操作（ 也可以 关闭 开关- XX:- CMSPrecleaningEnabled， 不 进行 预 清理）。 预 清理 是 并发 的， 除了 为 正式 清理 做 准备 和 检查， 还会 尝试 控制 一次 停顿 的 时间。 由于 重新 标记 是 独占 CPU 的， 如果 新生代 GC 发 生后， 立即 触发 一次 重新 标记， 那么 一次 停顿 的 时间 可能 很长。 为了 避免 这种 情况， 预处理 时会 刻意 等待 一次 新生代 GC 的 发生， 然后 根据 历史 性能 数据 预测 下 一次 新生代 GC 可能发生 的 时间， 在当 前 时间 和 预测 时间 的 中间 时刻 进行 重新 标记。 这样 可 尽量 避免 新生代 GC 和 重新 标记 重合， 尽可能 减少 一次 停顿 的 时间。</code></pre><h3 id="5-3-2-CMS主要的参数"><a href="#5-3-2-CMS主要的参数" class="headerlink" title="5.3.2 CMS主要的参数"></a>5.3.2 CMS主要的参数</h3><p>​    启用 CMS 回收 器 的 参数 是- XX:+ UseConcMarkSweepGC。设置 合理 的 工作 线程 数量 对 系统性 能有 重要的 影响。</p>
<p>​    CMS 默认 启动 的 并发 线程 数 是( ParallelGCThreads+ 3)/ 4。 ParallelGCThreads 表示 GC 并行 时 使用 的 线程 数量，如果 新生代 使用 ParNew， 那么 ParallelGCThreads 也就是 新生代 GC 的 线程 数量。 这 意味着 有 4 个 ParallelGCThreads 时， 只有 1 个 并发 线程， 而有 两个 并发 线程 时， 有 5~ 8 个 ParallelGCThreads 线程。</p>
<p>​    并发 线程 数量 也可以 通过- XX: ConcGCThreads 或者- XX: ParallelCMSThreads 参数 手工 设定。 当 CPU 资源 比较 紧张 时， 受到 CMS 回收 器 线程 的 影响， 应用 系统 的 性能 在 垃圾 回收 阶段 可能 会 非常 糟糕。</p>
<p>​     CMS 回收 器 不会 等待 堆 内存 饱和 时 才 进行 垃圾 回收， 而是 当 堆 内存 使用 率 达到 某一 阈值 时 便 开始 进行 回收， 以 确保 应用 程序 在 CMS 工作 过程中， 依然 有 足够 的 空间 支持 应用 程序 运行。</p>
<p>​    使用 参数- XX: CMSInitiatingOccupancyFraction 来 指定， 默认 是 68， 即 当 老 年代 的 空间 使用 率 达到 68% 时， 会 执行 一次 CMS 回收。 如果 应用 程序 的 内存 使用 率 增长 很快， 在 CMS 的 执行 过程中， 已经 出现 了 内存 不足 的 情况， CMS 回收 就会 失败， 虚拟 机 将 启动 老年 代 串行 回收 器 进行 垃圾 回收。</p>
<p>​    如果 内存 增长 缓慢， 则 可以 设置 一个 稍 大的 值， 大的 阈值 可以 有效 降低 CMS 的 触发 频率， 减少 老年 代 回收 的 次数， 可以 较为 明显 地 改善 应用 程序 性能。 反之， 如果 应用 程序 内存 使用 率 增长 很快， 则应 该 降低 这个 阈值， 以 避免 频繁 触发 老年 代 串行 回收 器。</p>
<p><img src="https://pic.imgdb.cn/item/5f69ff4a160a154a6759d87c.jpg" alt=""></p>
<p>​    -XX:+ UseCMSCompactAtFullCollection 参数 可 以使 CMS 在 垃圾 收集 完成 后， 进行 一次 内存 碎片 整理， 内存 碎片 的 整理 不是 并发 进行 的。</p>
<p>​    - XX: CMSFullGCsBeforeCompaction 参数 可以 用于 设定 进行 多少 次 CMS 回收 后， 进行 一次 内存 压缩。</p>
<h3 id="5-3-3-CMS的日志分析"><a href="#5-3-3-CMS的日志分析" class="headerlink" title="5.3.3 CMS的日志分析"></a>5.3.3 CMS的日志分析</h3><p>​    略</p>
<h3 id="5-3-4-有关Class的回收"><a href="#5-3-4-有关Class的回收" class="headerlink" title="5.3.4 有关Class的回收"></a>5.3.4 有关Class的回收</h3><p>​    在 使用 CMS 回收 器 时， 如果 需要 回收 Perm 区， 那么 默认 情况下， 还需 要 触发 一次 Full GC。</p>
<p>​    如果 希望 使用 CMS 回收 器 回收 Perm 区， 则 必须 打开- XX:+ CMSClassUnloadingEnabled 开关。 使用- XX:+ CMSClassUnloadingEnabled 后， 如果 条件 允许， 系统 会 使用 CMS 的 机制 回收 Perm 区 的 Class 数据，</p>
<h2 id="5-4-未来我做主-G1回收器-JDK9及之后版本的默认回收器"><a href="#5-4-未来我做主-G1回收器-JDK9及之后版本的默认回收器" class="headerlink" title="5.4 未来我做主:G1回收器(JDK9及之后版本的默认回收器)"></a>5.4 未来我做主:G1回收器(JDK9及之后版本的默认回收器)</h2><p> G1 使用 了 全新 的 分区 算法， 其 特点 如下。</p>
<ul>
<li><p>并行 性： G1 在 回收 期间， 可以 由 多个 GC 线程 同时 工作， 有效 利用 多 核计 算 能力。</p>
</li>
<li><p>并发 性： G1 拥有 与 应用 程序 交替 执行 的 能力， 部分 工作 可以 和 应用 程序 同时 执行， 一般来说， 不会 在 整个 回收 期间 完全 阻塞 应用 程序。</p>
</li>
<li><p>分 代 GC： G1 依然是 一个 分 代 回收 器， 但是 和 之前 的 回收 器 不同， 它 同时 兼顾 年轻 代 和 老 年代， 其他 回收 器 或者 工作 在 年轻 代， 或者 工作 在 老 年代。</p>
</li>
<li><p>空间 整理： G1 在 回收 过程中， 会 进行 适当 的 对象 移动， 不像 CMS， 只是 简单 地 标记 清理 对象， 在 若干 次 GC 后， CMS 必须 进行 一次 碎片 整理。 而 G1 不同， 它 每次 回收 都会 有效地 复制 对象， 减少 碎片 空间。</p>
</li>
<li><p>可 预见性： 由于 分区 的 原因， G1 可以 只 选取 部分 区域 进行 内存 回收， 这样 缩小 了 回收 的 范围， 全局 停顿 也能 得到 较好 的 控制。</p>
</li>
</ul>
<h3 id="5-4-1-G1的内存划分和主要收集过程"><a href="#5-4-1-G1的内存划分和主要收集过程" class="headerlink" title="5.4.1 G1的内存划分和主要收集过程"></a>5.4.1 G1的内存划分和主要收集过程</h3><p>​    G1 将 堆 进行 分区， 划分 为 一 个个 的 区域， 每次 回收 的 时候， 只 回收 其中 几个 区域， 以此 来 控制 垃圾 回收 产生 的 一次 停顿 的 时间。</p>
<p>​    回收过程有4个阶段：</p>
<ul>
<li>新生代 GC。 </li>
<li>并发 标记 周期。</li>
<li>混合 回收。 </li>
<li>如果 需要， 可能 会 进行 Full GC。</li>
</ul>
<h3 id="5-4-2-G1的新生代GC"><a href="#5-4-2-G1的新生代GC" class="headerlink" title="5.4.2 G1的新生代GC"></a>5.4.2 G1的新生代GC</h3><p>​    新生代 GC 的 主要 工作 是 回收 eden 区 和 survivor 区。 一旦 eden 区 被占 满， 新生代 GC 就会 启动。E 表示 eden 区， S 表示 survivor 区， O 表示 老 年代。 可以 看到， 新生代 GC 只 处理 eden 区 和 survivor 区， 回收 后 所有 的 eden 区 都 应该 被 清空， 而 survivor 区 会被 回收 一部分 数据， 但是 应该 至少 仍然 存在 一个 survivor 区。</p>
<p>​    另一个 重要的 变化 是， 老 年代 的 区域 增多， 因为 部分 survivor 区 或者 eden 区 的 对象 可能 会 晋升 到 老 年代。</p>
<p><img src="https://pic.imgdb.cn/item/5f6a016c160a154a675b1bc4.jpg" alt=""></p>
<h3 id="5-4-3-G1的并发标记周期"><a href="#5-4-3-G1的并发标记周期" class="headerlink" title="5.4.3 G1的并发标记周期"></a>5.4.3 G1的并发标记周期</h3><p>​    分为以下几步：</p>
<ul>
<li>初始 标记： 标记 从 根 节点 直接 可达 的 对象。 这个 阶段 会 伴随 一次 新生代 GC， 它是 会 产生 全局 停顿 的， 应用 程序 线程 在这 个 阶段 必须 停止 执行。</li>
<li>根 区域 扫描： 由于 初始 标记 必然会 伴随 一次 新生代 GC， 所以 在 初始化 标记 后， eden 区 被 清空， 并且 存活 对象 被 移入 survivor 区。 在这 个 阶段， 将 扫描 由 survivor 区 直接 可达 的 老年 代 区域， 并 标记 这些 直接 可达 的 对象。 这个 过程 是 可以 和 应用 程序 并发 执行 的。 但是 根 区域 扫描 不能 和 新生代 GC 同时 执行（ 因为 根 区域 扫描 依赖 survivor 区 的 对象， 而 新生代 GC 会 修改 这个 区域）， 因此 如果 恰巧 在此 时 需要 进行 新生代 GC， 就 需要 等待 根 区域 扫描 结束 后才 能 进行。 如果 发生 这种 情况， 这次 新生代 GC 的 时间 就会 延长。</li>
<li>并发 标记： 和 CMS 类似， 并发 标记 将会 扫描 并 查找 整个 堆 的 存活 对象， 并 做好 标记。 这是 一个 并发 的 过程， 并且 这个 过程 可以 被 一次 新生代 GC 打断。</li>
<li>重新 标记： 和 CMS 一样， 重新 标记 也是 会 产生 应用 程序 停顿 的。 由于 在 并发 标记 过程中， 应用 程序 依然 在 运行， 因此 标记 结果 可能 需要 进行 修正， 所以 在此 对上 一次 的 标记 结果 进行 补充。 在 G1 中， 这个 过程 使用 SATB（ Snapshot- At- The- Beginning） 算法 完成， 即 G1 会在 标记 之初 为 存活 对象 创建 一个 快照， 这个 快照 有助于 加速 重新 标记 的 速度。</li>
<li>独占 清理： 这个 阶段 是 会 引起 停顿 的。 它将 计算 各个 区域 的 存活 对象 和 GC 回收 比例， 并进 行 排序， 识别 可供 混合 回收 的 区域。 在这 个 阶段， 还会 更新 记忆 集（ Remebered Set）。 该 阶段 给出 了 需要 被 混合 回收 的 区域 并进 行了 标记， 在 混合 回收 阶段 需要 这些 信息。</li>
<li>并发 清理： 这里 会 识别 并 清理 完全 空闲 的 区域。 它是 并发 的 清理， 不会 引起 停顿。</li>
</ul>
<p>​    并发 标记 周期 执行 前后 最大 的 不同 是在 该 阶段 后， 系统 增加 了 一些 标记 为 G 的 区域。 这些 区域 被 标记， 是因为 它们 内部 的 垃圾 比例 较高， 希望 在 后续 的 混合 GC 中进 行 收集（ 注意 在 并发 标记 周期 中 并未 正式 收集 这些 区域）。 这些 将要 被 回收 的 区域 会被 G1 记录 在 一个 称为 Collection Sets（ 回收 集） 的 集合 中。</p>
<p><img src="https://pic.imgdb.cn/item/5f6a02a1160a154a675bd3d5.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f6a02b2160a154a675bdddd.jpg" alt=""></p>
<h3 id="5-4-4-混合回收"><a href="#5-4-4-混合回收" class="headerlink" title="5.4.4 混合回收"></a>5.4.4 混合回收</h3><p>​    在这 个 阶段 既 会 执行 正常 的 年轻 代 GC， 又会 选取 一些 被 标记 的 老年 代 区域 进行 回收， 它 同时 处理 了 新生代 和 老 年代， 如图 5. 9 所示。 因为 新生代 GC 的 原因， eden 区 必然 被 清空， 此外， 有 两块 被 标记 为 G 的 垃圾 比例 最高 的 区域 被 清理。 被 清理 区域 中的 存活 对象 会被 移到 其他 区域， 这样做 的 好处 是 可以 减少 空间 碎片。</p>
<p><img src="https://pic.imgdb.cn/item/5f6a0303160a154a675c110f.jpg" alt=""></p>
<p>​    混合 GC 会 执行 多次， 直到 回收 了 足够 多的 内存 空间， 然后 它 会 触发 一次 新生代 GC。 新生代 GC 后， 又 可能 会 发生 一次 并发 标记 周期 的 处理， 最后 又会 引起 混合 GC 的 执行。</p>
<p><img src="https://pic.imgdb.cn/item/5f6a0320160a154a675c2354.jpg" alt=""></p>
<h3 id="5-4-5-必要时的Full-GC"><a href="#5-4-5-必要时的Full-GC" class="headerlink" title="5.4.5 必要时的Full GC"></a>5.4.5 必要时的Full GC</h3><p>​    不能 完全避免 在 特别 繁忙 的 场合 出现 在 回收 过程中 内存 不充足 的 情况。 当 遇到 这种 情况 时， G1 也会 转入 一个 Full GC。</p>
<h3 id="5-4-6-G1的日志"><a href="#5-4-6-G1的日志" class="headerlink" title="5.4.6 G1的日志"></a>5.4.6 G1的日志</h3><p>略。</p>
<p>​    记忆 集 是 G1 中 维护 的 一个 数据 结构， 简称 RS。 每一个 G1 区域 都有 一个 RS 与之 关联。 由于 G1 回收 时 是按 照 区域 回收 的， 比如 在 回收 区域 A 的 对象 时， 很可能 并不 回收 区域 B 的 对象， 为了 回收 区域 A 的 对象， 要 扫描 区域 B 甚至 整个 堆 来 判定 区域 A 中 哪些 对象 不 可达， 这样做 的 代价 显然 很大。 因此， G1 在 区域 A 的 RS 中， 记录 了 在 区域 A 中 被 其他 区域 引用 的 对象， 这样 在 回收 区域 A 时， 只要 将 RS 视为 区域 A 根 集 的 一部分 即可， 从而 避免 做 整个 堆 的 扫描。 由于 系统 在 运行 过程中， 对象 之间 的 引用 关系 是 可能 时刻 变化 的， 为了 更 高效 地 跟踪 这些 引用 关系， 会 将 这些 变化 记录 在 Update Buffers 中。 这里 的 Processed Buffers 指的 就是 处理 这个 Update Buffers 数据。</p>
<h3 id="5-4-7-G1相关参数"><a href="#5-4-7-G1相关参数" class="headerlink" title="5.4.7 G1相关参数"></a>5.4.7 G1相关参数</h3><p>​    可以 使用- XX:+ UseG1GC 标记 打开 G1 的 开关， 对 G1 进行 设置 时， 最重要的 一个 参数 就是- XX: MaxGCPauseMillis， 它 用于 指定 目标 最大 停顿 时间。时间。 如果 任何 一次 停顿 超过 这个 设置 值， G1 就会 尝试 调整 新生代 和 老 年代 的 比例、 调整 堆 大小、 调整 晋升 年龄 等， 试图 达到 预设 目标。</p>
<p>​    如果 停顿 时间 缩短， 对于 新生代 来说， 这 意味着 很可能 要 增加 新生代 GC 的 次数。 对于 老年 代 来说， 为了 获得 更短 的 停顿 时间， 在 混合 GC 时， 一次 收集 的 区域 数量 也会 变少， 这样 无疑 增加 了 进行 Full GC 的 可能性。</p>
<p>​    另外 一个 重要的 参数 是- XX: ParallelGCThreads， 它 用于 设置 并行 回收 时 GC 的 工作 线程 数量。<br>​    此外，- XX: InitiatingHeapOccupancyPercent 参数 可以 指定 当 整个 堆 使用 率 达到 多少 时， 触发 并发 标记 周期 的 执行。 默认值 是 45， 即 当 整个 堆 的 占用 率 达到 45% 时， 执行 并发 标记 周期。 InitiatingHeapOccupancyPercent 一旦 设置， 始终 都不 会被 G1 修改， 这 意味着 G1 不会 试图 改变 这个 值 来 满足 MaxGCPauseMillis 的 目标。 如果 InitiatingHeapOccupancyPercent 值 设置 得 偏大， 会 导致 并发 周期 迟迟 得不到 启动， 那么 引起 Full GC 的 可能性 也 大大 增加， 反之， 一个 过小 的 InitiatingHeapOccupancyPercent 值 会使 得 并发 标记 周期 执行 非常 频繁， 大量 GC 线程 抢占 CPU， 导致 应用 程序 的 性能 有所 下降。</p>
<h2 id="5-5-回眸：有关对象内存分配和回收的一些细节问题"><a href="#5-5-回眸：有关对象内存分配和回收的一些细节问题" class="headerlink" title="5.5 回眸：有关对象内存分配和回收的一些细节问题"></a>5.5 回眸：有关对象内存分配和回收的一些细节问题</h2><h3 id="5-5-1-禁用System-gc"><a href="#5-5-1-禁用System-gc" class="headerlink" title="5.5.1  禁用System.gc()"></a>5.5.1  禁用System.gc()</h3><p>​    在 默认 情况下， System. gc() 会 显 式 直接 触发 Full GC， 同时 对 老 年代 和 新生代 进行 回收。 而 一般 情况下， 我们 认为 垃圾 回收 应该 是 自动 进行 的， 无须 手工 触发。 如果 过于 频繁 地 触发 垃圾 回收 对 系统性 能 是 没有 好处 的。 因此 虚拟 机 提供 了 一个 参数 DisableExplicitGC 来 控制 是否 手工 触发 GC。</p>
<p>​    如果 设置 了- XX:-+ DisableExplicitGC， 条件 判断 就 无法 成立， 那么 就会 禁用 显 式 GC， System. gc() 等价 于 一个 空 函数 调用。</p>
<h3 id="5-5-2-System-gc-使用并发回收"><a href="#5-5-2-System-gc-使用并发回收" class="headerlink" title="5.5.2 System.gc()使用并发回收"></a>5.5.2 System.gc()使用并发回收</h3><p>​    在 默认 的 情况下， 即使 System. gc() 生效， 会使 用 传统 的 Full GC 方式 回收 整个 堆， 而 忽略 参数 中的 UseG1GC 和 UseConcMarkSweepGC。</p>
<p>​    打开 虚拟 机 参数- XX:+ ExplicitGCInvokesConcurrent 后， 可以 改变 这种 默认 的 行为，</p>
<p>​    只有 在 打开 ExplicitGCInvokesConcurrent 开关 后， System. gc() 这种 显 式 GC 才会 使用 并发 的 方式 进行 回收， 否则， 无论 是否 启用 了 CMS 或者 G1， 都不 会 进行 并发 回收。</p>
<h3 id="5-5-3-并行GC前额外触发的新生代GC"><a href="#5-5-3-并行GC前额外触发的新生代GC" class="headerlink" title="5.5.3 并行GC前额外触发的新生代GC"></a>5.5.3 并行GC前额外触发的新生代GC</h3><p>​    对于 并行 回收 器 的 Full GC（ 使用 UseParallelOldGC 或者 UseParallelGC），， 在 每一 次 Full GC 之前 都会 伴随 一次 新生代 GC。</p>
<p>​    如果不 需要 这个 特性， 那么 可以 使用 参数- XX:- ScavengeBeforeFullGC 去除 发生 在 Full GC 之前 的 那次 新生代 GC。 在 默认 情况下， ScavengeBeforeFullGC 的 值 为 true。</p>
<h3 id="5-5-4-对象何时进入老年代"><a href="#5-5-4-对象何时进入老年代" class="headerlink" title="5.5.4 对象何时进入老年代"></a>5.5.4 对象何时进入老年代</h3><h4 id="1-初创的对象在eden区"><a href="#1-初创的对象在eden区" class="headerlink" title="1. 初创的对象在eden区"></a>1. 初创的对象在eden区</h4><p>​    当 对象 首次 创建 时， 会被 放置 在 新生代 的 eden 区。当 对象 的 年龄 达到 一定 的 大小， 就 自然 可以 离开 年轻 代， 进入 老 年代。 一般 把 对象 进入 老 年代 的 事件， 称为“ 晋升”。</p>
<h4 id="3-老年对象进入老年代"><a href="#3-老年对象进入老年代" class="headerlink" title="3. 老年对象进入老年代"></a>3. 老年对象进入老年代</h4><p>​    对象 的 年龄 是由 对象 经历 过 的 GC 次数 决定 的。 在 新生代 中的 对象 每 经历 一次 GC， 如果 它 没有 被 回收， 它的 年龄 就 加 1。 虚拟 机 提供 了 一个 参数 来 控制 新生代 对象 的 最大 年龄： MaxTenuringThreshold。 在 默认 情况下， 这个 参数 的 值 为 15。 也就是说， 新生代 的 对象 最多 经历 15 次 GC， 就可以 晋升 到 老 年代。</p>
<p>​    MaxTenuringThreshold 指的 是最 大 晋升 年龄。 它是 对象 晋升 到 老 年代 的 充分 非必要 条件。 即 达到 该 年龄， 对象 必然 晋升， 而未 达到 该 年龄， 对象 也有 可能 晋升。 事实上， 对象 的 实际 晋升 年龄， 是由 虚拟 机 在 运行时 自行 判断 的。</p>
<p>​    计算晋升年龄的基本逻辑代码如下：</p>
<p><img src="https://pic.imgdb.cn/item/5f6b3d5d160a154a67d76a1d.jpg" alt=""></p>
<p>注意： 对象 的 实际 晋升 年龄 是 根据 survivor 区 的 使用 情况 动态 计算 得来 的， 而 MaxTenuringThreshold 只是 表示 这个 年龄 的 最大值。</p>
<h4 id="4-大对象进入老年代"><a href="#4-大对象进入老年代" class="headerlink" title="4. 大对象进入老年代"></a>4. 大对象进入老年代</h4><p>​    除了 年龄， 对象 的 体积 也会 影响 对象 的 晋升。 试想， 如果 对象 体积 很大， 新生代 无论 eden 区 还是 survivor 区 都无 法 容纳 这个 对象， 自然 这个 对象 无法 存放 在 新生代， 也非 常有 可能 被 直接 晋升 到 老 年代。</p>
<p>​     PretenureSizeThreshold， 它 用来 设置 对象 直接 晋升 到 老 年代 的 阈值， 单位 是 字节。 只要 对象 的 大小 大于 指定 值， 就会 绕过 新生代， 直接 在 老年 代 分配。 这个 参数 只对 串行 回收 器 和 ParNew 有效， 对于 ParallelGC 无效。 默认 情况下 该 值 为 0， 也就是 不 指定 最大 的 晋升 大小， 一切 由 运行 情况 决定。</p>
<h3 id="5-5-5-在TLAB上分配对象"><a href="#5-5-5-在TLAB上分配对象" class="headerlink" title="5.5.5 在TLAB上分配对象"></a>5.5.5 在TLAB上分配对象</h3><p>​    TLAB 的 全称 是 Thread Local Allocation Buffer， 即 线程 本地 分配 缓存。 从 名字 上 可以 看到， TLAB 是一 个 线程 专用 的 内存 分配 区域。</p>
<p>​    Java 虚拟 机 就 使用 了 TLAB 这种 线程 专属 的 区域 来 避免 多 线程 冲突， 提高 对象 分配 的 效率。 TLAB 本身 占用 了 eden 区 的 空间。 在 TLAB 启用 的 情况下， 虚拟 机会 为 每一个 Java 线程 分配 一块 TLAB 区域。</p>
<p>​    大 对象 无法 在 TLAB 区域 进行 分配， 总是 会 直接 分配 在 堆 上。 由于 TLAB 空间 比较 小， 很容易 装满。 比如， 一个 100KB 的 空间， 如果 已经 使用 了 80KB， 当 需要 再分 配 一个 30KB 的 对象 时， 肯定 就 无能为力 了。 这时， 虚拟 机 有两 种 选择： 第一， 废弃 当前 的 TLAB 区域， 这样 就会 浪费 20KB 空间； 第二， 将 这 30KB 的 对象 直接 分配 在 堆 上， 保留 当前 的 TLAB 区域， 这样 将来 有 小于 20KB 的 对象 分配 请求 时 可以 直接 使用 这块 空间。 当 发生 请求 分配 的 对象 大于 TLAB 内 可用 空间 时， 虚拟 机 如何 在这 两种 行为 中进 行 选择 呢? 虚拟 机 内部 会 维护 一个 叫作 refill_ waste 的 值， 当 请求 对象 大于 refill_ waste 时， 会 选择 在 堆 中 分配， 若 小于 该 值， 则 会 废弃 当前 TLAB 区域， 新建 TLAB 区域 来 分配 新 对象。 这个 阈值 可以 使用 虚拟 机 参数 TLABRefillWasteFraction 来 调整， 它 表示 TLAB 中 允许 产生 这种 浪费 的 比例。 它的 默认值 为 64， 即表示 使用 约为 1/ 64 的 TLAB 区域 作为 refill_ waste。</p>
<p>​    默认 情况下， TLAB 和 refill_ waste 的 大小 都是 会在 运行时 不断 调整 的， 使 系统 的 运行 状态 达到 最优。 如果 想 禁用 自动 调整 TLAB 的 大小， 可以 使用- XX:- ResizeTLAB 禁用 ResizeTLAB， 并使 用- XX: TLABSize 手工 指定 TLAB 的 大小。</p>
<p>​    如果 想 观察 TLAB 区域 的 使用 情况， 可 打开 跟踪 参数- XX:+ PrintTLAB（ 考虑到 兼容性 问题， JDK9、 JDK10 不再 支持 此 参数）。</p>
<h3 id="5-5-6-finalize-函数对垃圾回收的影响"><a href="#5-5-6-finalize-函数对垃圾回收的影响" class="headerlink" title="5.5.6 finalize()函数对垃圾回收的影响"></a>5.5.6 finalize()函数对垃圾回收的影响</h3><p>​    该 函数 允许 在 子类 中 被 重载， 用于 在 对象 被 回收 时 进行 资源 释放。 目前， 普遍 的 认识 是， 尽量 不要 使用 finalize() 函数 进行 资源 释放， 原因 主要 有 以下 几点：</p>
<ul>
<li>在 使用 finalize（） 函数 时 可能 会 导致 对象 复活。</li>
<li>finalize（） 函数 的 执行 时间 是 没有 保障 的， 它 完全 由 GC 线程 决定， 在 极端 情况下， 若不 发生 GC， finalize（） 函数 将 没有 机会 执行。</li>
<li>一个 糟糕 的 finalize（） 函数 会 严重影响 GC 的 性能。</li>
</ul>
<p>​    finalize() 函数 是由 FinalizerThread 线程 处理 的。 每一个 即将 被 回收 并且 包含 finalize() 函数 的 对象 都会 在 正式 回收 前 加入 FinalizerThread 的 执行 队列， 该 队列 为 java. lang. ref. ReferenceQueue 引用 队列， 内部 实 现为 链 表 结构， 队列 中 每一 项 都为 java. lang. ref. Finalizer 引用， 它 本质 为 一个 引用。</p>
<p><img src="https://pic.imgdb.cn/item/5f6b414d160a154a67d971aa.jpg" alt=""></p>
<p>​    虽然 不 推荐 使用 finalize() 函数， 但是 在 有些 场合， 使用 finalize() 函数 可以 起到 双 保险 的 作用。 比如 在 MySQL 的 JDBC 驱动 中， com. mysql. jdbc. ConnectionImpl 就 实现 了 finalize() 函数。</p>
<p>​    当 一个 JDBC Connection 被 回收 时， 需要 进行 连接 的 关闭， 即 这里 的 cleanup（） 方法。 事实上， 在 回收 前， 开发 人员 如果 正常 调用 了 Connection. close（） 方法， 连接 就 会被 显 式 关闭， 那样 的 话， 在 cleanup（） 方法 中将 什么 都 不会 做。 而 如果 开发 人员 忘记 显 式 关闭 连接， 而 Connection 对象 又被 回收 了， 则 会 隐式 地 进行 连接 的 关闭， 确保 没有 数据库 连接 泄漏。</p>
<h2 id="5-6-温故而知新"><a href="#5-6-温故而知新" class="headerlink" title="5.6 温故而知新"></a>5.6 温故而知新</h2><h4 id="1-与串行回收器相关的参数"><a href="#1-与串行回收器相关的参数" class="headerlink" title="1. 与串行回收器相关的参数"></a>1. 与串行回收器相关的参数</h4><ul>
<li>-XX：+ UseSerialGC： 在 新生代 和 老年 代 使用 串行 回收 器。 </li>
<li>-XX： SurvivorRatio： 设置 eden 区 大小 和 survivior 区 大小 的 比例。 </li>
<li>-XX： PretenureSizeThreshold： 设置 大 对象 直接 进入 老 年代 的 阈值。 当 对象 的 大小 超过 这个 值 时， 将 直接 被 分配 在 老 年代。 </li>
<li>-XX： MaxTenuringThreshold： 设置 对象 进入 老 年代 的 年龄 的 最大值。 每一 次 Minor GC 后， 对象 年龄 就 加 1。 任何 大于 这个 年龄 的 对象， 一定 会 进入 老 年代。</li>
</ul>
<h4 id="2-与并行GC相关的参数"><a href="#2-与并行GC相关的参数" class="headerlink" title="2. 与并行GC相关的参数"></a>2. 与并行GC相关的参数</h4><ul>
<li><p>-XX：+ UseParNewGC（ 考虑到 兼容性 问题， JDK 9、 JDK 10 已经 删除）： 在 新生代 使用 并行 回收 器。 </p>
</li>
<li><p>-XX：+ UseParallelOldGC： 老年 代 使用 并行 回收 器。</p>
</li>
<li><p>-XX： ParallelGCThreads： 设置 用于 垃圾 回收 的 线程 数。 通常 情况下 可以 和 CPU 数量 相等， 但在 CPU 数量 比较 多的 情况下， 设置 相对 较小 的 数值 也是 合理 的。 </p>
</li>
<li><p>-XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。 它的 值 是一 个大 于 0 的 整数。 回收 器 在 工作 时， 会 调整 Java 堆 大小 或者 其他 一些 参数， 尽可能 地 把 停顿 时间 控制 在 MaxGCPauseMillis 以内。 </p>
</li>
<li><p>-XX： GCTimeRatio： 设置 吞吐量 大小。 它的 值 是 一个 0 到 100 之间 的 整数。 假设 GCTimeRatio 的 值 为 n， 那么 系统 将 花费 不超过 1/（ 1+ n） 的 时间 用于 垃圾 回收。 </p>
</li>
<li><p>-XX：+ UseAdaptiveSizePolicy： 打开 自 适应 GC 策略。 在这 种 模式 下， 新生代 的 大小、 eden 区 和 survivior 区 的 比例、 晋升 老 年代 的 对象 年龄 等 参数 会被 自动 调整， 以 达到 在 堆 大小、 吞吐量 和 停顿 时间 之间 的 平衡。</p>
</li>
</ul>
<h4 id="3-与-CMS-回收-器-相关-的-参数（-JDK9、-JDK10-已经-开始-废弃-CMS-回收-器，-建议-使用-G1-回收-器）"><a href="#3-与-CMS-回收-器-相关-的-参数（-JDK9、-JDK10-已经-开始-废弃-CMS-回收-器，-建议-使用-G1-回收-器）" class="headerlink" title="3. 与 CMS 回收 器 相关 的 参数（ JDK9、 JDK10 已经 开始 废弃 CMS 回收 器， 建议 使用 G1 回收 器）"></a>3. 与 CMS 回收 器 相关 的 参数（ JDK9、 JDK10 已经 开始 废弃 CMS 回收 器， 建议 使用 G1 回收 器）</h4><ul>
<li>-XX：+ UseConcMarkSweepGC： 新生代 使用 并行 回收 器， 老年 代 使用 CMS+ 串行 回收 器。 </li>
<li>-XX： ParallelCMSThreads： 设定 CMS 的 线程 数量。 </li>
<li>-XX： CMSInitiatingOccupancyFraction： 设置 CMS 回收 器 在 老年 代 空间 被 使用 多少 后 触发， 默认 为 68%。 </li>
<li>-XX：+ UseCMSCompactAtFullCollection： 设置 CMS 回收 器 在 完成 垃圾 回收 后 是否 要 进行 一次 内存 碎片 的 整理。 </li>
<li>-XX： CMSFullGCsBeforeCompaction： 设定 进行 多少 次 CMS 垃圾 回收 后， 进行 一次 内存 压缩。 </li>
<li>-XX：+ CMSClassUnloadingEnabled： 允许 对 类 元 数据区 进行 回收。 </li>
<li>-XX： CMSInitiatingPermOccupancyFraction： 当 永久 区 占用 率 达到 这一 百分比 时， 启动 CMS 回收（ 前提 是 激活 了- XX：+ CMSClassUnloadingEnabled）。 </li>
<li>-XX： UseCMSInitiatingOccupancyOnly： 表示 只在 到达 阈值 的 时候 才 进行 CMS 回收。 </li>
<li>-XX：+ CMSIncrementalMode： 使用 增量 模式， 比较 适合 单 CPU。 增量 模式 在 JDK 8 中 标记 为 废弃， 并且 将 在 JDK 9 中 彻底 移 除。</li>
</ul>
<h5 id="4-与-G1-回收-器-相关-的-参数"><a href="#4-与-G1-回收-器-相关-的-参数" class="headerlink" title="4. 与 G1 回收 器 相关 的 参数"></a>4. 与 G1 回收 器 相关 的 参数</h5><ul>
<li>-XX：+ UseG1GC： 使用 G1 回收 器。 </li>
<li>-XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。 </li>
<li>-XX： GCPauseIntervalMillis： 设置 停顿 间隔 时间。</li>
</ul>
<h4 id="5-TLAB相关"><a href="#5-TLAB相关" class="headerlink" title="5. TLAB相关"></a>5. TLAB相关</h4><ul>
<li>-XX：+ UseTLAB： 开启 TLAB 分配。 </li>
<li>-XX：+ PrintTLAB（ 考虑到 兼容性 问题， JDK 9、 JDK 10 不再 支持 此 参数）： 打印 TLAB 相关 分配 信息。 ·-XX： TLABSize： 设置 TLAB 区域 大小。 </li>
<li>-XX：+ ResizeTLAB： 自动 调整 TLAB 区域 大小。</li>
</ul>
<h4 id="6-其他参数"><a href="#6-其他参数" class="headerlink" title="6. 其他参数"></a>6. 其他参数</h4><ul>
<li>-XX：+ DisableExplicitGC： 禁用 显 式 GC。 </li>
<li>-XX：+ ExplicitGCInvokesConcurrent： 使用 并发 方式 处理 显 式 GC。</li>
</ul>
<h2 id="5-7-动手才是真英雄"><a href="#5-7-动手才是真英雄" class="headerlink" title="5.7 动手才是真英雄"></a>5.7 动手才是真英雄</h2><p>这章只列标题</p>
<h3 id="5-7-1-配置实验环境"><a href="#5-7-1-配置实验环境" class="headerlink" title="5.7.1 配置实验环境"></a>5.7.1 配置实验环境</h3><h3 id="5-7-2-配置-性能-测试-工具-JMeter"><a href="#5-7-2-配置-性能-测试-工具-JMeter" class="headerlink" title="5.7.2 配置 性能 测试 工具 JMeter"></a>5.7.2 配置 性能 测试 工具 JMeter</h3><h3 id="5-7-3-配置Web应用服务器Tomcat"><a href="#5-7-3-配置Web应用服务器Tomcat" class="headerlink" title="5.7.3 配置Web应用服务器Tomcat"></a>5.7.3 配置Web应用服务器Tomcat</h3><h3 id="5-7-4-实战-案例-1—-初试-串行-回收-器"><a href="#5-7-4-实战-案例-1—-初试-串行-回收-器" class="headerlink" title="5.7.4 实战 案例 1— 初试 串行 回收 器"></a>5.7.4 实战 案例 1— 初试 串行 回收 器</h3><h3 id="5-7-5-实战-案例-2—-扩-大堆-以-提升-系统-性能"><a href="#5-7-5-实战-案例-2—-扩-大堆-以-提升-系统-性能" class="headerlink" title="5.7.5 实战 案例 2— 扩 大堆 以 提升 系统 性能"></a>5.7.5 实战 案例 2— 扩 大堆 以 提升 系统 性能</h3><h3 id="5-7-6-实战-案例-3—-调整-初始-堆-大小"><a href="#5-7-6-实战-案例-3—-调整-初始-堆-大小" class="headerlink" title="5.7.6 实战 案例 3— 调整 初始 堆 大小"></a>5.7.6 实战 案例 3— 调整 初始 堆 大小</h3><h3 id="5-7-7-实战-案例-4—-使用-ParrellOldGC-回收-器"><a href="#5-7-7-实战-案例-4—-使用-ParrellOldGC-回收-器" class="headerlink" title="5.7.7 实战 案例 4— 使用 ParrellOldGC 回收 器"></a>5.7.7 实战 案例 4— 使用 ParrellOldGC 回收 器</h3><h3 id="5-7-8-实战-案例-5—-使用-较小-堆-提高-GC-压力"><a href="#5-7-8-实战-案例-5—-使用-较小-堆-提高-GC-压力" class="headerlink" title="5.7.8 实战 案例 5— 使用 较小 堆 提高 GC 压力"></a>5.7.8 实战 案例 5— 使用 较小 堆 提高 GC 压力</h3><h3 id="5-7-9-实战-案例-6—-测试-ParallelOldGC-的-表现"><a href="#5-7-9-实战-案例-6—-测试-ParallelOldGC-的-表现" class="headerlink" title="5.7.9 实战 案例 6— 测试 ParallelOldGC 的 表现"></a>5.7.9 实战 案例 6— 测试 ParallelOldGC 的 表现</h3><h3 id="5-7-10-实战-案例-7—-测试-ParNew-回收-器-的-表现"><a href="#5-7-10-实战-案例-7—-测试-ParNew-回收-器-的-表现" class="headerlink" title="5.7.10 实战 案例 7— 测试 ParNew 回收 器 的 表现"></a>5.7.10 实战 案例 7— 测试 ParNew 回收 器 的 表现</h3><h3 id="5-7-11-实战-案例-8—-测试-JDK-1-8-的-表现"><a href="#5-7-11-实战-案例-8—-测试-JDK-1-8-的-表现" class="headerlink" title="5.7.11 实战 案例 8— 测试 JDK 1. 8 的 表现"></a>5.7.11 实战 案例 8— 测试 JDK 1. 8 的 表现</h3><h3 id="5-7-12-实战-案例-9—-使用-高-版本-虚拟-机-提升-性能"><a href="#5-7-12-实战-案例-9—-使用-高-版本-虚拟-机-提升-性能" class="headerlink" title="5.7.12 实战 案例 9— 使用 高 版本 虚拟 机 提升 性能"></a>5.7.12 实战 案例 9— 使用 高 版本 虚拟 机 提升 性能</h3><h1 id="第6章-性能监控工具"><a href="#第6章-性能监控工具" class="headerlink" title="第6章 性能监控工具"></a>第6章 性能监控工具</h1><h2 id="6-1-有我更高效-Linux下的性能监控工具"><a href="#6-1-有我更高效-Linux下的性能监控工具" class="headerlink" title="6.1 有我更高效:Linux下的性能监控工具"></a>6.1 有我更高效:Linux下的性能监控工具</h2><h3 id="6-1-1-显示系统整体资源使用情况-top命令。"><a href="#6-1-1-显示系统整体资源使用情况-top命令。" class="headerlink" title="6.1.1 显示系统整体资源使用情况-top命令。"></a>6.1.1 显示系统整体资源使用情况-top命令。</h3><p>top 命令 的 输出 可以 分为 两个 部分： 前半部 分 是 统计 信息， 后半部 分 是 进程 信息。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c85c9160a154a677455d5.jpg" alt=""></p>
<p>​    在 统计 信息 中， 第 1 行 是 任务 队列 信息， 它的 结果 等 同于 uptime 命令。 从左到右 依次 表示 系统 当前 时间、 系统 运行 时间、 当前 登录 用 户数。 最后 的 load average 表示 系统 的 平均 负载， 即 任务 队列 的 平均 长度， 其中 的 3 个值 分别 表示 1 分钟、 5 分钟、 15 分钟 到 现在 的 平均值。</p>
<p>​    第 2 行 是 进程 统计 信息， 分别 是 正在 运行 的 进程 数、 睡眠 进程 数、 停止 的 进程 数、 僵尸 进程 数。</p>
<p>​    等 3 行 是 CPU 统计 信息， us 表示 用户 空间 CPU 占用 率、 sy 表示 内核 空间 CPU 占用 率、 ni 表示 用户 进程 空间 改变 过 优先级 的 进程 CPU 的 占用 率、 id 表示 空闲 CPU 占用 率、 wa 表示 等待 输入 和 输出 的 CPU 时间 百分比、 hi 表示 硬件 中断 请求、 si 表示 软件 中断 请求。 在 Mem 中， 从左到右， 依次 表示 物理 内存 总量、 已 使用 的 物理 内存、 空闲 物理 内存、 内核 缓冲 使 用量。 在 Swap 中， 依次 表示 交换 区 总量、 空闲 交换 区 大小、 缓冲 交换 区 大小。</p>
<p>​    top 命令 的 第 2 部分 是 进程 信息， 显示 了 系统 内 各个 进程 的 资源 使用 情况， 主要 字段 的 含义 如下。 </p>
<ul>
<li><p>PID： 进程 ID。 </p>
</li>
<li><p>USER： 进程 所有者 的 用 户名。 </p>
</li>
<li><p>PR： 优先级。 · NI： nice 值， 负值 表示 高 优先级， 正值 表示 低 优先级。 </p>
</li>
<li><p>%CPU： 上次 更新 到 现在 的 CPU 时间 占用 百分比。</p>
</li>
<li><p>TIME+： 进程 使用 的 CPU 时间 总计， 单位 为 1/ 100 秒。 </p>
</li>
<li><p>%MEM： 进程 使用 的 物理 内存 百分比。</p>
</li>
<li><p>VIRT： 进程 使用 的 虚拟 内存 总量， 单位 为 KB， VIRT= SWAP+ RES。 </p>
</li>
<li><p>RES： 进程 使用 的、 未被 换出 的 物理 内存 大小， 单位 为 KB， RES= CODE+ DATA。</p>
</li>
<li><p>SHR： 共享 内存 大小， 单位 为 KB。 </p>
</li>
<li><p>COMMAND： 命令 名/ 命令行。 </p>
</li>
</ul>
<p>注意： 使用 top 命令 可以 从 宏观 上 观察 系统 中 各个 进程 的 CPU 占用 情况， 以及 内存 使用 情况。</p>
<h3 id="6-1-2-监控内存和CPU-vmstat命令"><a href="#6-1-2-监控内存和CPU-vmstat命令" class="headerlink" title="6.1.2 监控内存和CPU-vmstat命令"></a>6.1.2 监控内存和CPU-vmstat命令</h3><p>​    vmstat 命令 也是 一个 功能 比较 齐全 的 性能 监测 工具。 它可 以 统计 CPU、 内存 使用 情况、 Swap 使用 情况 等 信息。 和 sar 工具 类似， vmstat 也可以 指定 采样 周期 和 采样 次数。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8684160a154a6774a1e3.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f6c86c7160a154a6774bc13.jpg" alt=""></p>
<h3 id="6-1-3-监控I-O-iostat命令"><a href="#6-1-3-监控I-O-iostat命令" class="headerlink" title="6.1.3 监控I/O-iostat命令"></a>6.1.3 监控I/O-iostat命令</h3><p>iostat 命令 可以 提供 详细 的 I/ O 信息， 它的 基本 使用方法 如下：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8747160a154a6774ee89.jpg" alt=""></p>
<p>以上 命令 显示 了 CPU 的 使用 概况 和 磁盘 I/ O 的 信息。 输出 信息 每 1 秒 采样 1 次， 合计 采样 两次。 如果 只需 要 显示 磁盘 情况， 不需要 显示 CPU 使用 情况， 则 可以 使用 命令：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c875c160a154a6774f69d.jpg" alt=""></p>
<p>如果 需要 得到 更多 的 统计 信息， 可以 使用- x 选项。</p>
<h3 id="6-1-4-多功能诊断器——pidstat工具"><a href="#6-1-4-多功能诊断器——pidstat工具" class="headerlink" title="6.1.4 多功能诊断器——pidstat工具"></a>6.1.4 多功能诊断器——pidstat工具</h3><p>​    pidstat 是一 个 功能 强大 的 性能 监测 工具， 也是 Sysstat 的 组件 之一。 读者 可以 在 http:// www. icewalkers. com/ Linux/ Software/ 59040/ Sysstat. html 下载 这个 工具。 下载 后， 通过./ configure、 make、 make install 等 3 个 命令 即可 安装 pidstat 工具。 如果 是 Ubuntu 系统， 也可以 简单 地 通过 以下 命令 安装：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8791160a154a67750dcb.jpg" alt=""></p>
<h4 id="1-CPU-使用-率-监控"><a href="#1-CPU-使用-率-监控" class="headerlink" title="1.CPU 使用 率 监控"></a>1.CPU 使用 率 监控</h4><p>​    pidstat 的 参数- p 用于 指定 进程 ID，- u 表示 对 CPU 使用 率 的 监控。 参数 1 3 表示 每秒 采样 一次， 合计 采样 3 次。 从这 个 输出 中 可以 看到， 该 应用 程序 CPU 占用 率 几乎 达到 100%。 pidstat 的 功能 不仅仅 限于 观察 进程 信息， 还可以 进一步 监控 线程 的 信息。 使用 以下 命令：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c87cd160a154a677526ab.jpg" alt=""></p>
<p>-t 参数 将 系统性 能 的 监控 细化 到 线程 级别。 从这 个 输出 中 可以 知道， 该 Java 应用 程序 之所以 有如 此 高的 CPU 占用 率， 是因为 线程 1204 的 缘故。</p>
<h4 id="2-I-O使用情况监控"><a href="#2-I-O使用情况监控" class="headerlink" title="2. I/O使用情况监控"></a>2. I/O使用情况监控</h4><p>​    在 程序 运行 过程中， 使用 以下 命令 监控 程序 I/ O 使用 情况。 其中 22796 是 通过 jps 命令 查询 得到 的 进程 ID，- d 参数 表明 监控 对象 为 磁盘 I/ O。 1 3 表示 每秒 采样 一次， 合计 采样 3 次。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c894a160a154a6776421e.jpg" alt=""></p>
<h4 id="3-内存监控"><a href="#3-内存监控" class="headerlink" title="3.内存监控"></a>3.内存监控</h4><p>下例 使用 pidstat 工具 对 进程 ID 为 27233 的 进程 进行 内存 监控。 每秒 刷新 一次， 共进 行 5 次 统计。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8968160a154a67765eff.jpg" alt=""></p>
<h2 id="6-2-用我更高效-Windows下的性能监控工具"><a href="#6-2-用我更高效-Windows下的性能监控工具" class="headerlink" title="6.2 用我更高效:Windows下的性能监控工具"></a>6.2 用我更高效:Windows下的性能监控工具</h2><h3 id="6-2-1-任务管理器"><a href="#6-2-1-任务管理器" class="headerlink" title="6.2.1 任务管理器"></a>6.2.1 任务管理器</h3><p>略</p>
<h3 id="6-2-2-perfmon性能监控工具"><a href="#6-2-2-perfmon性能监控工具" class="headerlink" title="6.2.2 perfmon性能监控工具"></a>6.2.2 perfmon性能监控工具</h3><p><img src="https://pic.imgdb.cn/item/5f6c8a74160a154a677720f2.jpg" alt=""></p>
<h3 id="6-2-3-ProcessExplorer进行管理工具"><a href="#6-2-3-ProcessExplorer进行管理工具" class="headerlink" title="6.2.3 ProcessExplorer进行管理工具"></a>6.2.3 ProcessExplorer进行管理工具</h3><p>​    ProcessExplorer 是一 款 功能 极其 强大 的 进程 管理 工具。 它 完全可以 替代 Windows 自带 的 任务 管理器。 读者 可以 在 http:// technet. microsoft. com/ en- us/ sysinternals/ bb896653 下载 该 工具。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8ad8160a154a67774a5d.jpg" alt=""></p>
<h3 id="6-2-4-pslist工具——Windows下也有命令行工具"><a href="#6-2-4-pslist工具——Windows下也有命令行工具" class="headerlink" title="6.2.4 pslist工具——Windows下也有命令行工具"></a>6.2.4 pslist工具——Windows下也有命令行工具</h3><p>读者 可以 在 http:// technet. microsoft. com/ en- us/ sysinternals/ bb896682 下载 并 安装 该 工具。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8b10160a154a677764e6.jpg" alt=""></p>
<h2 id="6-3-外科手术刀-JDK性能监控工具"><a href="#6-3-外科手术刀-JDK性能监控工具" class="headerlink" title="6.3 外科手术刀: JDK性能监控工具"></a>6.3 外科手术刀: JDK性能监控工具</h2><h3 id="6-3-1-查看Java进程——jps命令"><a href="#6-3-1-查看Java进程——jps命令" class="headerlink" title="6.3.1 查看Java进程——jps命令"></a>6.3.1 查看Java进程——jps命令</h3><p>参数- q 可以 指定 jps 只 输出 进程 ID， 而 不 输出 类 的 名称：</p>
<p>参数- m 可以 用于 输出 传递 给 Java 进程（ 主 函数） 的 参数：</p>
<p>参数- l 可以 用于 输出 主 函数 的 完整 路径：</p>
<p>参数- v 可以 显示 传递 给 Java 虚拟 机 的 参数：</p>
<p>注意： jps 命令 类似于 ps 命令， 但 是它 只 列出 系统 中 所有 的 Java 应用 程序。 通过 jps 命令 可以 方便 地 查看 Java 进程 的 启动 类、 传入 参数 和 Java 虚拟 机 参数 等 信息。</p>
<h3 id="6-3-2-查看虚拟机运行时信息——jstat命令"><a href="#6-3-2-查看虚拟机运行时信息——jstat命令" class="headerlink" title="6.3.2 查看虚拟机运行时信息——jstat命令"></a>6.3.2 查看虚拟机运行时信息——jstat命令</h3><p><img src="https://pic.imgdb.cn/item/5f6c8c8f160a154a67780c9d.jpg" alt=""></p>
<p>option 可以 由 以下 值 构成。 </p>
<ul>
<li>-class： 显示 ClassLoader 的 相关 信息。 </li>
<li>-compiler： 显示 JIT 编译 的 相关 信息。 </li>
<li>-gc： 显示 与 GC 相关 的 堆 信息。 </li>
<li>-gccapacity： 显示 各个 代 的 容量 及 使用 情况。</li>
<li>-gccause： 显示 垃圾 回收 相关 信息（ 同- gcutil）， 同时 显示 最后 一次 或当 前 正在 发生 的 垃圾 回收 的 诱发 原因。 </li>
<li>-gcnew： 显示 新生代 信息。 </li>
<li>-gcnewcapacity： 显示 新生代 大小 与 使用 情况。 </li>
<li>-gcold： 显示 老 年代 和 永久 代 的 信息。 </li>
<li>-gcoldcapacity： 显示 老 年代 的 大小。 </li>
<li>-gcpermcapacity： 显示 永久 代 的 大小。 </li>
<li>-gcutil： 显示 垃圾 回收 信息。 </li>
<li>-printcompilation： 输出 JIT 编译 的 方法 信息。 </li>
<li>-t 参数 可以 在 输出 信息 前 加上 一个 Timestamp 列， 显示 程序 的 运行 时间。 </li>
<li>-h 参数 可以 指定 在 周期性 数据 输出 时， 输出 多少 行 数据 后 输出 一个 表头 信息。 · interval 参数 用于 指定 输出 统计数据 的 周期， 单位 为 毫秒。 </li>
<li>count 参数 用于 指定 一共 输出 多少 次 数据。</li>
</ul>
<h3 id="6。3-3-查看虚拟机参数——jinfo命令"><a href="#6。3-3-查看虚拟机参数——jinfo命令" class="headerlink" title="6。3.3 查看虚拟机参数——jinfo命令"></a>6。3.3 查看虚拟机参数——jinfo命令</h3><p>​    jinfo 命令 可以 用来 查看 正在 运行 的 Java 应用 程序 的 扩展 参数， 甚至 支持 在 运行时 修改 部分 参数。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8da0160a154a677885b2.jpg" alt=""></p>
<p>其中 option 可以 为 以下 信息。 </p>
<ul>
<li>-flag&lt; name&gt;： 打印 指定 Java 虚拟 机 的 参数 值。 </li>
<li>-flag [+|-]<name>： 设置 指定 Java 虚拟 机 参数 的 布尔 值。 </li>
<li>-flag&lt; name&gt;=&lt; value&gt;： 设置 指定 Java 虚拟 机 参数 的 值。</li>
</ul>
<h3 id="6-3-4-导出堆到文件——jmap命令"><a href="#6-3-4-导出堆到文件——jmap命令" class="headerlink" title="6.3.4 导出堆到文件——jmap命令"></a>6.3.4 导出堆到文件——jmap命令</h3><p>​    jmap 命令 是 一个 多功能 的 命令。 它可 以 生成 Java 程序 的 堆 Dump 文件， 也可以 查看 堆 内 对象 实例 的 统计 信息、 查看 ClassLoader 的 信息 及 finalizer 队列。</p>
<p>下例 使用 jmap 命令 生成 PID 为 2972 的 Java 程序 的 对象 统计 信息， 并 输出 到 s. txt 文件 中。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8e09160a154a6778b7c7.jpg" alt=""></p>
<p>jmap 命令 另一个 更为重要 的 功能 是 得到 Java 程序 的 当前 堆 快照：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8e2a160a154a6778c526.jpg" alt=""></p>
<p>此外， jmap 还可以 查看 系统 的 ClassLoader 的 信息。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8e4e160a154a6778d3b3.jpg" alt=""></p>
<p> 使用 以下 命令 可以 查看 堆积 在 finalizer 队列 中的 对象：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8e6f160a154a6778e19d.jpg" alt=""></p>
<h3 id="6-3-5-JDK自带的堆分析工具——jhat命令"><a href="#6-3-5-JDK自带的堆分析工具——jhat命令" class="headerlink" title="6.3.5 JDK自带的堆分析工具——jhat命令"></a>6.3.5 JDK自带的堆分析工具——jhat命令</h3><p>使用 jhat 命令 可以 分析 Java 应用 程序 的 堆 快照 内容。</p>
<p>说明： jhat 命令 在 JDK9、 JDK10 中 已经 被 删除， 官方 建议 用 VisualVm 代替， 参考 6. 5. 5 节。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8fbc160a154a67797641.jpg" alt=""></p>
<h3 id="6-3-6-查看线程对堆栈——jstack命令"><a href="#6-3-6-查看线程对堆栈——jstack命令" class="headerlink" title="6.3.6 查看线程对堆栈——jstack命令"></a>6.3.6 查看线程对堆栈——jstack命令</h3><p><img src="https://pic.imgdb.cn/item/5f6c8fde160a154a677987a7.jpg" alt=""></p>
<p>-l 选项 用于 打印 锁 的 附加 信息。 jstack 命令 会在 控制台 输出 程序 中 所 有的 锁 信息， 可以 使用 重定向 将 输出 保存 到 文件 中， 如：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c8ff6160a154a6779934d.jpg" alt=""></p>
<p>注意： 通过 jstack 命令 不仅 可以 得到 线程 堆栈， 还能 自动 进行 死锁 检查， 输出 找到 的 死锁 信息。</p>
<h3 id="6-3-7-远程主机信息收集——jstatd命令"><a href="#6-3-7-远程主机信息收集——jstatd命令" class="headerlink" title="6.3.7 远程主机信息收集——jstatd命令"></a>6.3.7 远程主机信息收集——jstatd命令</h3><p>​    jstatd 命令 是 一个 RMI 服务 端 程序， 它的 作用 相当于 代理 服务器， 建立 本地 计算机 与 远程 监控 工具 的 通信。 jstatd 服务器 将 本机 的 Java 应用 程序 信息 传递 到 远程 计算机。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9039160a154a6779b405.jpg" alt=""></p>
<p>直接 打开 jstatd 服务器 可能 会 抛出 访问 拒绝 异常。这是 由于 jstatd 程序 没有 足够 的 权限 所致。 可以 使用 Java 的 安全 策略， 为 其 分配 相应 的 权限。 下面 的 代码 为 jstatd 分配 了 最大 的 权限， 将其 保存 在 jstatd. all. policy 文件 中：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9059160a154a6779c3ba.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f6c9066160a154a6779c923.jpg" alt=""></p>
<p>-J 参数 是一 个 公共 的 参数， 如 jps、 jstat 等 命令 都可以 接收 这个 参数。 由于 jps、 jstat 命令 本身 也是 Java 应用 程序，- J 参数 可 以为 jps 等 命令 本身 设置 Java 虚拟 机 参数。</p>
<p>在 默认 情况下， jstatd 命令 将 在 1099 端口 开启 RMI 服务器。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9094160a154a6779dd14.jpg" alt=""></p>
<h3 id="6-3-8-多功能命令行——jcmd命令"><a href="#6-3-8-多功能命令行——jcmd命令" class="headerlink" title="6.3.8 多功能命令行——jcmd命令"></a>6.3.8 多功能命令行——jcmd命令</h3><p>​    在 JDK 1. 7 以后， 新增 了 一个 命令行 工具 jcmd。 它是 一个 多功能 的 工具， 可以 用来 导出 堆、 查看 Java 进程、 导出 线程 信息、 执行 GC 等。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c90c4160a154a6779f127.jpg" alt=""></p>
<p>（1） 查看 虚拟 机 启动 时间 VM. uptime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 2828 VM.uptime</span><br></pre></td></tr></table></figure>

<p>jcmd 命令 也 支持 直接 使用 MainClass 的 名字 来 代替 进程 号， 这样 在编 写 脚本 的 时候 也 更为 容易。</p>
<p>（2） 打印 线程 栈 信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 2828 Thread.print</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/5f6c913e160a154a677a2d58.jpg" alt=""></p>
<p>从 以上 示例 中 可以 看到， jcmd 拥有 jmap 的 大部分 功能， 并且 在 Oracle 的 官方 网 站上 也 推荐 使用 jcmd 命令 代替 jmap 命令。</p>
<h3 id="6-3-9-性能统计工具——hprof"><a href="#6-3-9-性能统计工具——hprof" class="headerlink" title="6.3.9 性能统计工具——hprof"></a>6.3.9 性能统计工具——hprof</h3><p> hprof 不是 独立 的 监控 工具， 它 只是 一个 Java agent 工具。 它可 以用 于 监控Java 应用 程序 在 运行时 的 CPU 信息 和 堆 信息。 使用 java- agentlib: hprof= help 命令 可以 查看 hprof 的 帮助 文档。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9224160a154a677a9675.jpg" alt=""></p>
<h3 id="6-3-10-扩展jps命令"><a href="#6-3-10-扩展jps命令" class="headerlink" title="6.3.10 扩展jps命令"></a>6.3.10 扩展jps命令</h3><p>​     包括 jps 在内 的 命令 本质上 是 使用 Java 实现 的。 以 jps 命令 为例， 它在 实现 过程中， 使用 MonitoredVmUtil 类 获得 给定 虚拟 机 的 相关 信息。</p>
<p>​    其他略</p>
<h2 id="6-4-你是我的眼-图形化虚拟机监控工具JConsole"><a href="#6-4-你是我的眼-图形化虚拟机监控工具JConsole" class="headerlink" title="6.4  你是我的眼:图形化虚拟机监控工具JConsole"></a>6.4  你是我的眼:图形化虚拟机监控工具JConsole</h2><h3 id="6-4-1-Jconsole连接Java程序"><a href="#6-4-1-Jconsole连接Java程序" class="headerlink" title="6.4.1 Jconsole连接Java程序"></a>6.4.1 Jconsole连接Java程序</h3><p>JConsole 程序 在% JAVA_ HOME%/ bin 目录 下， 启动 后， 程序 便 要求 指定 连接 Java 应用 程序。</p>
<p>​    在 新建 连接 对话框 中， 罗列 了 所有 的 本地 Java 应用 程序， 选择 需要 连接 的 程序 即可。 在 本地 进程 下， 还有 一个 用于 连接 远程 进程 的 文本 框， 输入 正确 的 远程 进程 地址 即可 连接。</p>
<p>如果 需要 使用 JConsole 连接 远程 进程， 则 可以 在 远程 Java 应用 程序 启动 时 加上 如下 参数：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9322160a154a677b04fe.jpg" alt=""></p>
<h3 id="6-4-2-Java程序概况"><a href="#6-4-2-Java程序概况" class="headerlink" title="6.4.2 Java程序概况"></a>6.4.2 Java程序概况</h3><p><img src="https://pic.imgdb.cn/item/5f6c934b160a154a677b16ae.jpg" alt=""></p>
<h3 id="6-4-3-内存监控"><a href="#6-4-3-内存监控" class="headerlink" title="6.4.3 内存监控"></a>6.4.3 内存监控</h3><p>​    切换 到 内存 监控 界面， 可以 显示 当前 内存 的 详细信息。 不仅 包括 堆 内存 的 整体 信息， 更 细化 到 eden 区、 survivor 区、 老 年代 的 使用 情况。 同时， 也 包括 非 堆 区， 即 永久 代 的 使用 情况。 单击 右 上角 的“ 执行 GC” 按钮， 可以 强制 应用 程序 进行 一次 Full GC。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9427160a154a677b747d.jpg" alt=""></p>
<h3 id="6-4-4-线程监控"><a href="#6-4-4-线程监控" class="headerlink" title="6.4.4 线程监控"></a>6.4.4 线程监控</h3><p>​    JConsole 中的 线程 选项 卡 允许 开发 人员 监控 程序 内 的 线程， 如图 6. 27 所示。 JConsole 显示 了 系统 内 的 线程 数量， 并在 屏幕 下方 显示 了 程序 中 所有 的 线程。 单击 线程 名称， 便可 以 查看 线程 的 栈 信息。 使用“ 检测</p>
<p><img src="https://pic.imgdb.cn/item/5f6c946a160a154a677b9196.jpg" alt=""></p>
<h3 id="6-4-5-类加载情况"><a href="#6-4-5-类加载情况" class="headerlink" title="6.4.5 类加载情况"></a>6.4.5 类加载情况</h3><p><img src="https://pic.imgdb.cn/item/5f6c9480160a154a677b9ae8.jpg" alt=""></p>
<h3 id="6-4-6-虚拟机信息"><a href="#6-4-6-虚拟机信息" class="headerlink" title="6.4.6 虚拟机信息"></a>6.4.6 虚拟机信息</h3><p>在 VM 概要 页， JConsole 显示 了 当前 应用 程序 的 运行 环境， 包括 虚拟 机 类型、 版本、 堆 信息 及 虚拟 机 参数 等。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c949a160a154a677ba6d8.jpg" alt=""></p>
<h2 id="6-5-一目了然-可视化性能监控工具Visual-VM"><a href="#6-5-一目了然-可视化性能监控工具Visual-VM" class="headerlink" title="6.5 一目了然: 可视化性能监控工具Visual VM"></a>6.5 一目了然: 可视化性能监控工具Visual VM</h2><p>Visual VM 是一 个 功能 强 大的 多 合一 故障 诊断 和 性能 监控 可 视 化 工具， 它 集成 了 多种 性能 统计 工具 的 功能， 使用 Visual VM 可以 代替 jstat、 jmap、 jhat、 jstack， 甚至 代替 JConsole。 在 JDK6 升级 到 JDK7 以后， Visual VM 便 作为 JDK 的 一部分 发布， 即 它 完全 免费。</p>
<p>​    Visual VM 的 一大 特点 是 支持 插件 扩展， 并且 插件 安装 非常 方便。 我们 既可以 通过 离 线下 载 插件 文件*. nbm， 然后 在 Plugin 对话框 的 已 下载 页面 添加 已 下载 的 插件， 也可 以在 可用 插件 页面 下， 在 线 安装 插件。</p>
<h3 id="6-5-1-Visual-VM连接应用程序"><a href="#6-5-1-Visual-VM连接应用程序" class="headerlink" title="6.5.1 Visual VM连接应用程序"></a>6.5.1 Visual VM连接应用程序</h3><p>​    Visual VM 支持 多种 方式 连接 应用 程序， 最 常用 的 就是 本地 连接。 只要 本地 计算机 内有 Java 应用 程序 正在 执行， 在 Visual VM 的 Local 节点 下， 就会 出现 这些 应用 程序。 双击 应用 程序 或者 使用 鼠标 右键 打开 应用 程序， 就能 够 监控 应用 程序 运行，</p>
<p><img src="https://pic.imgdb.cn/item/5f6c95cd160a154a677c2942.jpg" alt=""></p>
<p>也 支持 远程 JMX 连接。 Java 应用 程序 可以 通过 以下 参数 打开 JMX 端口：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c95dc160a154a677c3071.jpg" alt=""></p>
<p>在 弹出 的 对话框 中 填写 远程 计算机 地址、 端口， 如图 6. 34 所示。 如果 需要 验证， 则 填写 用 户名 和 密码。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c95f4160a154a677c3a49.jpg" alt=""></p>
<h3 id="6-5-2-监控应用程序"><a href="#6-5-2-监控应用程序" class="headerlink" title="6.5.2 监控应用程序"></a>6.5.2 监控应用程序</h3><p><img src="https://pic.imgdb.cn/item/5f6c9612160a154a677c4897.jpg" alt=""></p>
<p>​    单击 Tab 页 面上 的 监视 页面， 即可 监控 应用 程序 CPU、 堆、 永久 区、 类 加载 和 线程 数 的 总体 情况。 通过 页 面上 的“ 执行 垃圾 回收” 和“ 堆 Dump” 按钮 还可以 手工 执行 Full GC 和 生成 堆 快照。</p>
<h3 id="6-5-3-Thread-Dump和分析"><a href="#6-5-3-Thread-Dump和分析" class="headerlink" title="6.5.3 Thread Dump和分析"></a>6.5.3 Thread Dump和分析</h3><p>​    线程 页面（ 如图 6. 38 所示） 可以 提供 详细 的 线程 信息。 单击 右 上角 的“ 线程 Dump” 按钮 可以 导出 当前 所有 线程 的 堆栈 信息（ 相当于 使用 jstack 命令）。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9648160a154a677c5a33.jpg" alt=""></p>
<p>注意： Visual VM 的 Thread 页面 提供 了 详细 的 线程 信息， 还会 进行 自动 的 死锁 监测， 一旦 发现 存在 死锁 便会 提示 用户。</p>
<h3 id="6-5-4-性能分析"><a href="#6-5-4-性能分析" class="headerlink" title="6.5.4 性能分析"></a>6.5.4 性能分析</h3><p>​    Visual VM 有两 个 采样 器， 在 Sampler 页面 显示 了 CPU 和 内存 两个 性能 采样 器， 用于 实时 监控 程序 信息。 CPU 采样 器 可以 将 CPU 占用 时间 定位 到 方法， 内存 采样 器 可以 查看 当前 程序 的 堆 信息。</p>
<p>​     通过 Visual VM 的 采样 功能， 可以 找到 该 程序 中 占用 CPU 时间 最长 的 方法。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9676160a154a677c6a5e.jpg" alt=""></p>
<p>在 Visual VM 的 默认 统计 信息 中， 并不 包含 JDK 的 内置 对象 的 函数 调用 统计， 比如 java.* 包 中的 类。 如果 需要 统计 JDK 内 的 方法 调用 情况， 需要 单击 右 上角 的“ 设置” 选项， 手工 进行 配置。</p>
<h3 id="6-5-5-内存快照分析"><a href="#6-5-5-内存快照分析" class="headerlink" title="6.5.5 内存快照分析"></a>6.5.5 内存快照分析</h3><p>使用 右键 菜单 中的“ 堆 Dump”， 可以 立即 获得 当前 应用 程序 的 内存 快照。</p>
<p>内存 快照 分析 如图 6. 44 所示， 在 顶部 的 Tab 页 中， 提供 了 4 个 基本功 能 页： 概要、 类、 实例 数 和 OQL 控制台。 下面 分别 介绍 它们。 </p>
<p>（1） 概要 页面 展示 了 当前 内存 的 整体 信息， 包括 内存 大小、 实例 总数、 类 总数 等。 （2） 在 类 页面 中， 以 类 为 索引， 显示 了 每个 类 的 实例 数 和 占用 空间。 在 类 页面 中， 还可 以对 两个 不同 的 内存 快照 文件 进行 比较， 这个 功能 可以 帮助 开发者 快速 分析 同一 应用 程序 在 运行 的 不同 时刻， 内存 数据 产生 的 变化。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c96b5160a154a677c7fef.jpg" alt=""></p>
<p>（3） 在 实例 数 页面 中， 将 显示 指定 类 的 所有 实例。 开发者 可以 查看 当前 内存 中的 实际 内容。 图 6. 46 显示 了 查看 一个 String 对象 实例 页面 的 部分 内容。 可以 看到， 系统 中 所有 的 String 对象 都 一一 被 列出， 并且 可以 看到 所有 对象 的 具体 数据。</p>
<p>（4） OQL 控制台 提供 了 更 强大 的 对象 查询 功能。 有关 Visual VM 的 OQL 支持， 将 在后 续 章节 进行 详细 阐述。</p>
<p> 注意： 通过 Visual VM 提供 的 内存 快照 分析 工具， 可以 查看 堆 快照 内 的 类 信息 和 对象 信息。</p>
<h3 id="6-5-6-BTrace介绍"><a href="#6-5-6-BTrace介绍" class="headerlink" title="6.5.6 BTrace介绍"></a>6.5.6 BTrace介绍</h3><p>​    BTrace 是一 款 非常 有意思 的 工具， 它可 以在 不 停机 的 情况下， 通过 字节 码 注入 动态 监控 系统 的 运行 情况， 可以 跟踪 指定 的 方法 调用、 构造 函数 调用 和 系统 内存 等 信息。</p>
<p>​    在 Visual VM 中 安装 BTrace 插件 后， 便可 以 针对 Java 应用 程序 执行 BTrace 脚本 了。 在 Java 应用 程序 节点 上 单击 右键， 选择“ Trace application” 即可 进入 BTrace 插件 界面， 如图 6. 48 所示。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9755160a154a677cbdb1.jpg" alt=""></p>
<p>其他暂略，参考书即可。</p>
<h2 id="6-6-来自JRockit的礼物-虚拟机诊断工具"><a href="#6-6-来自JRockit的礼物-虚拟机诊断工具" class="headerlink" title="6.6 来自JRockit的礼物: 虚拟机诊断工具"></a>6.6 来自JRockit的礼物: 虚拟机诊断工具</h2><p>Mission Control 程序 为% JAVA_ HOME%/ bin/ jmc. exe， 打开 这 款 软件。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9868160a154a677d326f.jpg" alt=""></p>
<h3 id="6-6-1-MBean服务器"><a href="#6-6-1-MBean服务器" class="headerlink" title="6.6.1 MBean服务器"></a>6.6.1 MBean服务器</h3><p>​    在 Mission Control 界面 左侧 的 JVM 浏览器 中， 枚举 了 系统 内 所有 的 Java 进程。 打开 其中 一个 进程 的 MBean 服务器。</p>
<p>可以 看到， Mission Control 的 界面 非常 有特色， 在 默认 的 界面 中， 以 飞机 仪表 的 视图 显示 了 Java 堆 使用 空间、 CPU 使用 率 和 Live Set+ Fragmentation。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c9968160a154a677da8b3.jpg" alt=""></p>
<p>​    单击“ 运行时” 按钮， 如图 6. 55 所示， 通过 左 下侧 的 Tab 页 切换， 还可以 显示 内存、 垃圾 收集、 内存 池、 线程 等 信息。</p>
<p><img src="https://pic.imgdb.cn/item/5f6c99b0160a154a677dcfee.jpg" alt=""></p>
<h3 id="6-6-2-飞行记录器-Flight-Recorder"><a href="#6-6-2-飞行记录器-Flight-Recorder" class="headerlink" title="6.6.2 飞行记录器(Flight Recorder)"></a>6.6.2 飞行记录器(Flight Recorder)</h3><p>​    飞行 记录器 是 Mission Control 提供 的 另一 大 功能， 和 MBean 服务器 不同， 它 通过 记录 程序 在 一段时间 内 的 运行 情况， 将 记录 结果 进行 分析 和 展示， 可以 更进一步 对 系统 的 性能 进行 分析 和 诊断。 要使 用 飞行 记录器， 要 监控 的 程序 必须 带 以下 参数 启动：</p>
<p><img src="https://pic.imgdb.cn/item/5f6c99d7160a154a677de40b.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f6c9a07160a154a677e006e.jpg" alt=""></p>
<h1 id="第7章-分析Java堆"><a href="#第7章-分析Java堆" class="headerlink" title="第7章 分析Java堆"></a>第7章 分析Java堆</h1><h3 id="7-1-1-堆溢出"><a href="#7-1-1-堆溢出" class="headerlink" title="7.1.1 堆溢出"></a>7.1.1 堆溢出</h3><p>​    为了 减少 堆 溢出 错误， 一方面 可以 使用- Xmx 参数 指定 一个 更 大的 堆 空间， 另一方面， 由于 堆 空间 不可能 无限 增大， 通过 MAT 或者 Visual VM 等 工具， 找到 大量 占用 堆 空间 的 对象 并在 应用 程序上 做出 合理 的 优化， 也是 十分必要 的。</p>
<h3 id="7-1-2-直接内存溢出"><a href="#7-1-2-直接内存溢出" class="headerlink" title="7.1.2 直接内存溢出"></a>7.1.2 直接内存溢出</h3><p>​    在 Java 的 NIO（ New I/ O） 中， 支持 直接 内存 使用， 也就是 通过 Java 代码 获得 一块 堆 外 的 内存 空间， 这块 空间 是 直接 向 操作系统 申请 的。 直接 内存 的 申请 速度 一般 要比 堆 内存 慢， 但是 其 访问 速度 要 快于 堆 内存。 因此， 对于 那些 可 复 用的， 并且 会被 经常 访问 的 空间， 使用 直接 内存 是 可以 提高 系统性 能 的。 但 由于 直接 内存 没 有被 Java 虚拟 机 完全 托管， 若 使用不当， 也 容易 触发 直接 内存 溢出， 导致 宕 机。</p>
<p><img src="https://pic.imgdb.cn/item/5f6ed9df160a154a6745d7c7.jpg" alt=""></p>
<p>​    提醒： 如果在此 使 用的 是 JDK 1. 7u40 32 位 Java 虚拟 机， 如果 使用 JDK 1. 7 64 位 虚拟 机， 程序 是 可以 正常 执行 的， 且不 会 出现 OOM， 这是 因为 32 位 计算机 系统 对应 用 程序 的 可用 最大 内存 有限制。 以 Windows 平台 为例， 在 32 位 系统 中， 进程 的 寻址 空间 为 4GB， 其中 2GB 为 用户 空间， 2GB 为 系统 空间， 故 实际 可用 的 系统 内存 只有 2GB， 当 Java 进程 的 所有 内存 之和（ 堆 空间、 栈 空间、 直接 内存 及 虚拟 机 自身 所用 的 内存） 大于 2GB 时， 就会 出现 OOM。</p>
<p>​    如果 将上 述 代码 中 第 6 行的 System. gc() 注释 掉， 使 显 式 GC 生效， 那么 程序 将 可以 正常 结束， 这 说明 GC 可以 回收 直接 内存。 </p>
<p>​    另一个 让 该 程序 正常 执行 的 方法 是 设置 一个 较 小的 堆， 在 不 指定- XX: MaxDirectMemorySize 的 情况下， 最大 可用 直接 内存 等于- Xmx 的 值。</p>
<h3 id="7-1-3-过多线程导致OOM"><a href="#7-1-3-过多线程导致OOM" class="headerlink" title="7.1.3 过多线程导致OOM"></a>7.1.3 过多线程导致OOM</h3><p>​    由于 每一个 线程 的 开启 都要 占用 系统 内存， 因此当 线程 数量 太多 时， 也有 可能 导致 OOM。 由于 线程 的 栈 空间 也 是在 堆 外 分配 的， 因此 和 直接 内存 非常 相似， 如果 想 让 系统 支持 更多 的 线程， 那么 应该 使用 一个 较 小的 堆 空间。</p>
<p>​    或者减少 每一个 线程 所占 的 内存 空间， 使用- Xss 参数 可以 指定 线程 的 栈 空间。</p>
<p>​    注意： 如果 减小 了 线程 的 栈 空间 大小， 栈 溢出 的 风险 会 相应 地 上升。</p>
<h3 id="7-1-4-永久区溢出"><a href="#7-1-4-永久区溢出" class="headerlink" title="7.1.4 永久区溢出"></a>7.1.4 永久区溢出</h3><p>​    永久 区（ Perm） 是 存放 类 元 数据 的 区域。 如果 一个 系统 中有 太多 的 类型， 那么 永久 区 是有 可能 溢出 的。 在 JDK 1. 8 中， 永久 区 被 一块 称为 元 数据 的 区域 替代， 但是 它们 的 功能 是 类似 的， 都是 为了 保存 类 的 元 信息。</p>
<p>​    一般来说要解决永久区问题，可以从以下几个方面考虑:</p>
<ul>
<li>增加MaxPermSize的值</li>
<li>减少系统需要的累的数量</li>
<li>使用ClassLoader合理地装载各个类，并定期进行回收。</li>
</ul>
<h3 id="7-1-5-GC效率低下引起的OOM"><a href="#7-1-5-GC效率低下引起的OOM" class="headerlink" title="7.1.5 GC效率低下引起的OOM"></a>7.1.5 GC效率低下引起的OOM</h3><p>​    GC 是 内存 回收 的 关键， 如果 GC 效率 低下， 那么 系统 的 性能 会受 到 严重 的 影响。 如果 系统 的 堆 空间 太小， 那么 GC 所 花的 时间 就会 较多， 并且 回收 所 释放 的 内存 会 较少。 根据 GC 占用 的 系统 时间， 以及 释放 内存 的 大小， 虚拟 机会 评估 GC 的 效率， 一旦 虚拟 机 认为 GC 的 效率 过低， 就有 可能 直接 抛出 OOM。</p>
<ul>
<li><p>花在 GC 上 的 时间 是否 超过 了 98%。</p>
</li>
<li><p>老年 代 释放 的 内存 是否 小于 2%。</p>
</li>
<li><p>eden 区 释放 的 内存 是否 小于 2%。</p>
</li>
<li><p>是否 连续 5 次 GC 都 出现 了 上述 几种 情况（ 注意 是 同时 出现， 不是 出现 一个）。</p>
</li>
</ul>
<p>只有 满足 所有 条件， 虚拟 机 才有 可能 抛出 如下 OOM：</p>
<p><img src="https://pic.imgdb.cn/item/5f6eee02160a154a674bd9e1.jpg" alt=""></p>
<h2 id="7-2-无处不在的字符串-String在虚拟机中的实现"><a href="#7-2-无处不在的字符串-String在虚拟机中的实现" class="headerlink" title="7.2 无处不在的字符串:String在虚拟机中的实现"></a>7.2 无处不在的字符串:String在虚拟机中的实现</h2><h3 id="7-2-1-String对象的特点"><a href="#7-2-1-String对象的特点" class="headerlink" title="7.2.1 String对象的特点"></a>7.2.1 String对象的特点</h3><ul>
<li>不变性</li>
<li>针对常量池的优化</li>
<li>类的final定义</li>
</ul>
<h4 id="1-不变性"><a href="#1-不变性" class="headerlink" title="1.不变性"></a>1.不变性</h4><p>​    一旦生成，则不能对它进行改变。看起来像修改的操作，都是依靠产生新的字符串实现的。</p>
<h4 id="2-针对常量池的优化"><a href="#2-针对常量池的优化" class="headerlink" title="2. 针对常量池的优化"></a>2. 针对常量池的优化</h4><p>​    针对 常量 池 的 优化 指 当 两个 String 对象 拥有 相同 的 值 时， 它们 只 引用 常量 池 中的 同一个 副本。</p>
<p><img src="https://pic.imgdb.cn/item/5f6eefca160a154a674c682e.jpg" alt=""></p>
<h4 id="3-类的定义"><a href="#3-类的定义" class="headerlink" title="3.类的定义"></a>3.类的定义</h4><p>​    除以 上 两点 外， final 类型 定义 也是 String 对象 的 重要 特点。 作为 final 类 的 String 对象 在 系统 中 不可 能有 任何 子类， 这是 对 系统 安全 性的 保护。 同时， 在 JDK 1. 5 版本 之前 的 环境 中， 使用 final 定义 有助于 帮助 虚拟 机 寻找 机会， 内联 所有 的 final 方法， 从而 提高 系统 效率。 但这 种 优化 方法 在 JDK 1. 5 以后， 效果 并不 明显。</p>
<h3 id="7-2-2-有关String的内存泄露"><a href="#7-2-2-有关String的内存泄露" class="headerlink" title="7.2.2 有关String的内存泄露"></a>7.2.2 有关String的内存泄露</h3><p>​    在 JDK 1. 6 中， java. lang. String 主 要由 3 部分 组成： value 数组、 offset 偏移 和 count 长度。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f6ef1de160a154a674d2671.jpg" alt=""></p>
<p>​    这个 结构 为 内存 泄漏 埋下 了 伏笔， 字符串 的 实际 内容 由 value、 offset 和 count 三 者 共同 决定， 而非 value 一项。 试想， 如果 字符串 value 数组 包含 100 个 字符， 而 count 长度 只有 1 个 字节， 那么 这个 String 实际上 只有 1 个 字符， 却占据 了 至少 100 个 字节， 剩余 的 99 个 就 属于 泄漏 的 部分， 它们 不会 被 使用， 不会 被 释放， 却 长期 占用 内存， 直到 字符串 本身 被 回收。</p>
<h3 id="7-2-3-有关String常量池的位置"><a href="#7-2-3-有关String常量池的位置" class="headerlink" title="7.2.3 有关String常量池的位置"></a>7.2.3 有关String常量池的位置</h3><p>​    在 虚拟 机中， 有 一块 称为 常量 池 的 区域 专门 用于 存放 字符串 常量。 在 JDK 1. 6 之前， 这块 区域 属于 永久 区 的 一部分， 但是 在 JDK 1. 7 以后， 它 就被 移 到了 堆 中进 行 管理。</p>
<p>​    另外 一点 值得注意 的 是， 虽然 String. intern（） 的 返回 值 永远 等于 字符串 常量。 但这 并不 代表 在 系统 的 每时每刻， 相同 的 字符串 的 intern（） 返回 值 都会 是 一样 的（ 虽然 在 95% 以上 的 情况下， 都是 相同 的）。 因为 存在 这么 一种 可能： 在 一次 intern（） 调用 之后， 该 字符串 在某 一个 时刻 被 回收， 之后， 再进 行 一次 intern（） 调用， 那么 字面 量 相同 的 字符串 重新 被 加入 常量 池， 但是 引用 位置 已经 不同。</p>
<h2 id="7-3-虚拟机也有内窥镜：使用MAT分析Java堆"><a href="#7-3-虚拟机也有内窥镜：使用MAT分析Java堆" class="headerlink" title="7.3 虚拟机也有内窥镜：使用MAT分析Java堆"></a>7.3 虚拟机也有内窥镜：使用MAT分析Java堆</h2><p>​    MAT 是 Memory Analyzer 的 简称， 它 是一 款 功能 强大 的 Java 堆 内存 分析器。 可以 用于 查找 内存 泄漏， 以及 查看 内存 消耗 情况。 MAT 是 基于 Eclipse 开发 的， 是一 款 免费 的 性能 分析 工具。  可以 在 http:// www. eclipse. org/ mat/ 下载 并使 用 MAT。</p>
<h3 id="7-3-1-初始MAT"><a href="#7-3-1-初始MAT" class="headerlink" title="7.3.1 初始MAT"></a>7.3.1 初始MAT</h3><p>在 分析 堆 快照 前， 首先 需要 导出 应用 程序 的 堆 快照。 在 本书 前文 中 提到 的 jmap、 JConsole 和 Visual VM 等 工具 都可 用于 获得 Java 应用 程序 的 堆 快照 文件。 MAT 本身 也 具有 这个 功能。</p>
<p>​    其他略</p>
<h3 id="7-3-2-浅堆和深堆"><a href="#7-3-2-浅堆和深堆" class="headerlink" title="7.3.2 浅堆和深堆"></a>7.3.2 浅堆和深堆</h3><p>​    浅 堆（ Shallow Heap） 和 深 堆（ Retained Heap） 是 两个 非常重 要的 概念， 它们 分别 表示 一个 对象 结构 所占 用的 内存 大小 和 一个 对 象被 GC 回收 后， 可以 真实 释放 的 内存 大小。 </p>
<p>​    浅 堆（ Shallow Heap） 是指 一个 对象 所 消耗 的 内存。 在 32 位 系统 中， 一个 对象 引用 会 占据 4 字节， 一个 int 类型 变量 会 占据 4 字节， 一个 long 类型 变量 会 占据 8 字节， 每个 对象 头 需要 占用 8 字节。 根据 堆 快照 格式 不同， 对象 的 大小 可能 会 向 8 字节 对齐。 以 String 对象 为例， 如图 7. 13 所示， 显示 了 String 对象 的 几个 属性（ JDK 1. 7， 与 JDK 1. 6 有 差异）。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f6ef43f160a154a674e18d4.jpg" alt=""></p>
<p>​    深 堆（ Retained Heap） 的 概念 略微 复杂。 要 理解 深 堆， 首先 需要 了解 保留 集（ Retained Set）。 对象 A 的 保留 集 指 当 对象 A 被 回收 后， 可以 被 释放 的 所有 的 对象 集合（ 包括 对象 A 本身）， 即 对象 A 的 保留 集 可以 被认为 是 只能 通过 对象 A 被 直接 或 间接 访 问到 的 所有 对象 的 集合。 通俗 地说， 就 是指 仅 被 对象 A 所持 有的 对象 的 集合。 深 堆 是指 对象 的 保留 集中 所有 的 对象 的 浅 堆 大小 之和。</p>
<p>注意： 浅 堆 指 对象 本身 占用 的 内存， 不包括 其内 部 引用 对象 的 大小。 一个 对象 的 深 堆 指 只能 通过 该 对象 访 问到 的（ 直接 或 间接） 所有 对象 的 浅 堆 之和， 即对 象被 回收 后， 可以 释放 的 真实 空间。</p>
<h3 id="7-3-3-MAT堆分析案例解析"><a href="#7-3-3-MAT堆分析案例解析" class="headerlink" title="7.3.3 MAT堆分析案例解析"></a>7.3.3 MAT堆分析案例解析</h3><p>略</p>
<h3 id="7-3-4-支配树-Domainator-Tree"><a href="#7-3-4-支配树-Domainator-Tree" class="headerlink" title="7.3.4 支配树(Domainator Tree)"></a>7.3.4 支配树(Domainator Tree)</h3><p>​    MAT 提供 了 一个 称为 支配 树（ Dominator Tree） 的 对象 图。 支配 树 体现 了 对象 实例 间的 支配 关系。 在 对象 引用 图中， 所有 指向 对象 B 的 路径 都 经过 对象 A， 则 认为 对象 A 支配 对象 B。 如果 对象 A 是 离 对象 B 最近 的 一个 支配 对象， 则 认为 对象 A 为 对象 B 的 直接 支配者。 支配 树 是 基于 对象 间的 引用 图 所 建立 的， 它有 以下 基本 性质： </p>
<ul>
<li>对象 A 的 子 树（ 所有 被 对象 A 支配 的 对象 集合） 表示 对象 A 的 保留 集（ Retained Set）， 即 深 堆。 ·</li>
<li>如果 对象 A 支配 对象 B， 那么 对象 A 的 直接 支配者 也 支配 对象 B。 ·</li>
<li>支配 树 的 边 与 对象 引 用图 的 边 不 直接 对应。</li>
</ul>
<h3 id="7-3-5-Tomcat堆溢出分析"><a href="#7-3-5-Tomcat堆溢出分析" class="headerlink" title="7.3.5 Tomcat堆溢出分析"></a>7.3.5 Tomcat堆溢出分析</h3><p>略</p>
<h2 id="7-4-筛选对对象-MAT对OQL的支持"><a href="#7-4-筛选对对象-MAT对OQL的支持" class="headerlink" title="7.4 筛选对对象:MAT对OQL的支持"></a>7.4 筛选对对象:MAT对OQL的支持</h2><h3 id="7-4-1-SELECT子句"><a href="#7-4-1-SELECT子句" class="headerlink" title="7.4.1 SELECT子句"></a>7.4.1 SELECT子句</h3><p>​    在 MAT 中， Select 子句 的 格式 与 SQL 基本 一致， 用于 指定 要 显示 的 列。 Select 子句 中 可以 使用“*”， 查看 结果 对象 的 引用 实例（ 相当于 outgoing references）。</p>
<h3 id="7-4-2-FROM子句"><a href="#7-4-2-FROM子句" class="headerlink" title="7.4.2 FROM子句"></a>7.4.2 FROM子句</h3><p>From 子句 用于 指定 查询 范围， 它可 以 指定 类 名、 正 则 表达式 或者 对象 地址。</p>
<h3 id="7-4-3-Where子句"><a href="#7-4-3-Where子句" class="headerlink" title="7.4.3 Where子句"></a>7.4.3 Where子句</h3><p>Where 子句 用于 指定 OQL 的 查询 条件。 OQL 查询 将 只 返回 满足 Where 子句 指定 条件 的 对象。 Where 子句 的 格式 与 传统 SQL 极为 相似。</p>
<h3 id="7-4-4-内置对象与方法"><a href="#7-4-4-内置对象与方法" class="headerlink" title="7.4.4 内置对象与方法"></a>7.4.4 内置对象与方法</h3><p>OQL 中 可以 访问 堆 内 对象 的 属性， 也可以 访问 堆 内 代理 对象 的 属性。 访问 堆 内 对象 的 属性 时， 格式 如下：</p>
<p><img src="https://pic.imgdb.cn/item/5f6ef5cf160a154a674e85bc.jpg" alt=""></p>
<h2 id="7-5-更精彩的查找-Visual-VM对OQL的支持"><a href="#7-5-更精彩的查找-Visual-VM对OQL的支持" class="headerlink" title="7.5 更精彩的查找: Visual VM对OQL的支持"></a>7.5 更精彩的查找: Visual VM对OQL的支持</h2><h3 id="7-5-1-Visual-VM的OQL的基本语法"><a href="#7-5-1-Visual-VM的OQL的基本语法" class="headerlink" title="7.5.1 Visual VM的OQL的基本语法"></a>7.5.1 Visual VM的OQL的基本语法</h3><p><img src="https://pic.imgdb.cn/item/5f6ef60e160a154a674e9814.jpg" alt=""></p>
<p>​    注意： 对于 MAT 来说， OQL 的 关键字， 如 select、 from 等 可以 使用 大写， 也可以 使用 小写， 但 对于 Visual VM 而言， 必须 统一 使用 小写。</p>
<p>​    select 子句 和 where 子句 支持 使用 JavaScript 语法 处理 较 复杂 的 查询 逻辑， select 子句 可以 使用 类似 JSON 的 语法 输出 多个 列。 from 子句 可以 使用 instanceof 关键字， 将 给定 类 的 子类 也 包括 到 输出 列表 中。</p>
<h3 id="7-5-2-内置heap对象"><a href="#7-5-2-内置heap对象" class="headerlink" title="7.5.2 内置heap对象"></a>7.5.2 内置heap对象</h3><p><img src="https://pic.imgdb.cn/item/5f6ef65c160a154a674eafa6.jpg" alt=""></p>
<h3 id="7-5-3-对象函数"><a href="#7-5-3-对象函数" class="headerlink" title="7.5.3 对象函数"></a>7.5.3 对象函数</h3><p>​    在 Visual VM 中， 还为 OQL 语言 提供 了 一组 以 对象 为 操作 目标 的 内置 函数。 通过 这些 函数， 可以 获取 目标 对象 的 更多 信息。</p>
<h4 id="1-classof-函数"><a href="#1-classof-函数" class="headerlink" title="1.classof() 函数"></a>1.classof() 函数</h4><h4 id="2-objectid-函数"><a href="#2-objectid-函数" class="headerlink" title="2.objectid()函数"></a>2.objectid()函数</h4><h4 id="3-reachables-函数"><a href="#3-reachables-函数" class="headerlink" title="3.reachables()函数"></a>3.reachables()函数</h4><h4 id="4-referrers-函数"><a href="#4-referrers-函数" class="headerlink" title="4.referrers()函数"></a>4.referrers()函数</h4><h4 id="5-referees-函数"><a href="#5-referees-函数" class="headerlink" title="5.referees()函数"></a>5.referees()函数</h4><h4 id="6-sizeof-函数"><a href="#6-sizeof-函数" class="headerlink" title="6.sizeof()函数"></a>6.sizeof()函数</h4><h4 id="7-rsizeof-函数"><a href="#7-rsizeof-函数" class="headerlink" title="7.rsizeof()函数"></a>7.rsizeof()函数</h4><h4 id="8-toHtml-函数"><a href="#8-toHtml-函数" class="headerlink" title="8.toHtml()函数"></a>8.toHtml()函数</h4><h3 id="7-5-4-集合-统计函数"><a href="#7-5-4-集合-统计函数" class="headerlink" title="7.5.4 集合/统计函数"></a>7.5.4 集合/统计函数</h3><p>Visual VM 中 还有 一组 用于 集合 操作 和 统计 的 函数。 可以 方便 地 对 结果 集 进行 处理 或者 统计 操作。 集合/ 统计 函数 主要 有 contains()、 count()、 filter()、 length()、 map()、 max()、 min()、 sort()、 top()、 sum()、 unique() 等。</p>
<h3 id="7-5-5-程序化OSQL分析Tomcat堆"><a href="#7-5-5-程序化OSQL分析Tomcat堆" class="headerlink" title="7.5.5 程序化OSQL分析Tomcat堆"></a>7.5.5 程序化OSQL分析Tomcat堆</h3><p>​    Visual VM 不仅 支持 在 OQL 控制 台上 执行 OQL， 也可以 通过 其 OQL 相关 的 JAR 包， 将 OQL 查询 程序 化， 从而 获得 更加 灵活 的 对象 查询 功能， 实现 堆 快照 分析 的 自动化。</p>
<h1 id="第8章-锁与并发"><a href="#第8章-锁与并发" class="headerlink" title="第8章 锁与并发"></a>第8章 锁与并发</h1><p>知识点：</p>
<ul>
<li>理解 线程 安全 的 重要性。 </li>
<li>“锁” 在 虚拟 机内 的 基本 实现 方式。 </li>
<li>应用 层 对“ 锁” 进行 优化 的 一般 方法 和 思路。 </li>
<li>无 锁 计算 的 方法 和 原理。 </li>
<li>理解 Java 虚拟 机内 存 模型。</li>
</ul>
<h2 id="8-1-安全就是锁存在的理由-锁的基本概念和实现"><a href="#8-1-安全就是锁存在的理由-锁的基本概念和实现" class="headerlink" title="8.1 安全就是锁存在的理由: 锁的基本概念和实现"></a>8.1 安全就是锁存在的理由: 锁的基本概念和实现</h2><p>​    通过 锁 可以 让 多个 线程 排队 一个 一个 地 进入 临界 区 访问 目标 对象， 使 目标 对象 的 状态 总 保持一致， 这也 就是 锁 存在 的 价值。</p>
<h3 id="8-1-1-理解线程安全"><a href="#8-1-1-理解线程安全" class="headerlink" title="8.1.1 理解线程安全"></a>8.1.1 理解线程安全</h3><p>​    通过 锁 可以 实现 线程 安全， 线程 安全 就 是在 多 线程 环境 下， 无论 多个 线程 如何 访问 目标 对象， 目标 对象 的 状态 应该 始终 是 保持一致 的， 线程 的 行为 也 总是 正确 的。</p>
<p><img src="https://pic.imgdb.cn/item/5f6ef90b160a154a674f5f4e.jpg" alt=""></p>
<h3 id="8-1-2-对象头和锁"><a href="#8-1-2-对象头和锁" class="headerlink" title="8.1.2 对象头和锁"></a>8.1.2 对象头和锁</h3><p>​    在 Java 虚拟 机 的 实现 中 每个 对象 都有 一个 对 象头， 用于 保存 对象 的 系统 信息。 对象 头中 有一个 称为 Mark Word 的 部分， 它是 实现 锁 的 关键。 在 32 位 系统 中， Mark Word 为 一个 32 位 的 数据， 在 64 位 系统 中， 它 占 64 位。 它是 一个 多功能 的 数据区， 可以 存放 对象 的 哈 希 值、 对象 年龄、 锁 的 指针 等 信息。 一个 对象 是否 占用 锁、 占用 哪个 锁， 就 记录 在 这个 Mark Word 中。</p>
<p><img src="https://pic.imgdb.cn/item/5f6ef93c160a154a674f6bf9.jpg" alt=""></p>
<p>​    它 表示 Mark Word 中有 25 位（ 比特） 表示 对象 的 哈 希 值， 4 位 表示 对象 的 年龄， 1 位 表示 是否 为 偏向 锁， 2 位 表示 锁 的 信息。</p>
<p><img src="https://pic.imgdb.cn/item/5f6ef975160a154a674f7aee.jpg" alt=""></p>
<h2 id="8-2-避免残酷的竞争-锁在Java虚拟机中的实现与优化"><a href="#8-2-避免残酷的竞争-锁在Java虚拟机中的实现与优化" class="headerlink" title="8.2 避免残酷的竞争: 锁在Java虚拟机中的实现与优化"></a>8.2 避免残酷的竞争: 锁在Java虚拟机中的实现与优化</h2><h3 id="8-2-1-偏向锁"><a href="#8-2-1-偏向锁" class="headerlink" title="8.2.1 偏向锁"></a>8.2.1 偏向锁</h3><p>​    偏向 锁 是 JDK 1. 6 提出 的 一种 锁 优化 方式。 其 核心 思想 是， 如果 程序 没有 竞争， 则 取消 之前 已经 取得 锁 的 线程 同步 操作。 也 就说， 某一 锁 被 线程 获取 后， 就会 进入 偏向 模式， 当 线程 再次 请求 这个 锁 时， 无须 再进 行 相关 的 同步 操作， 从而 节省 了 操作 时间。在 JVM 中 使用- XX:+ UseBiasedLocking 可以 设置 启用 偏向 锁。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f6ef9e3160a154a674f960a.jpg" alt=""></p>
<p>​    偏向 锁 在 锁 竞争 激烈 的 场合 没有 太强 的 优化 效果， 因为 大量 的 竞争 会 导致 持有 锁 的 线程 不停 地 切换， 锁 也 很难 一直 保持 在 偏向 模式， 此时 使用 锁 偏向 不仅 得不到 性能 优化， 反而 有可能 降低 系统 性能。 因此， 在 竞争 激烈 的 场合， 可以 尝试 使用- XX:- UseBiasedLocking 参数 禁用 偏向 锁。</p>
<h3 id="8-2-2-轻量级锁"><a href="#8-2-2-轻量级锁" class="headerlink" title="8.2.2 轻量级锁"></a>8.2.2 轻量级锁</h3><p>​    如果 偏向 锁 失败， Java 虚拟 机会 让 线程 申请 轻量级 锁。 轻量级 锁 在 虚拟 机内 部 使用 一个 称为 BasicObjectLock 的 对象 实现， 这个 对象 内部 由 一个 BasicLock 对象 和 一个 持有 该 锁 的 Java 对象 指针 组成。 BasicObjectLock 对象 放置 在 Java 栈 的 栈 帧 中。 在 BasicLock 对象 内部 还 维护 着 displaced_ header 字段， 它 用于 备份 对象 头部 的 Mark Word。</p>
<p><img src="https://pic.imgdb.cn/item/5f6efafc160a154a674fe351.jpg" alt=""></p>
<p>​    BasicLock 通过 set_ displaced_ header() 方法 备份 了 原 对象 的 Mark Word。 接着， 使用 CAS 操作， 尝试 将 BasicLock 的 地址 复制 到 对 象头 的 Mark Word。 如果 复制 成功， 那么 加锁 成功， 否则 认为 加锁 失败。 如果 加锁 失败， 那么 轻量级 锁 就有 可能 膨胀 为重 量级 锁。</p>
<p><img src="https://pic.imgdb.cn/item/5f6efb18160a154a674feac6.jpg" alt=""></p>
<h3 id="8-2-3-锁膨胀"><a href="#8-2-3-锁膨胀" class="headerlink" title="8.2.3 锁膨胀"></a>8.2.3 锁膨胀</h3><p>​    当 轻量级 锁 失败， 虚拟 机 就会 使用 重量级 锁。 在 使用 重量级 锁 时， 对象 的 Mark Word 如下：</p>
<p><img src="https://pic.imgdb.cn/item/5f6efb69160a154a674ffd46.jpg" alt=""></p>
<p>​    第 1 步 是 废弃 前面 BasicLock 备份 的 对象 头 信息。 第 2 步 则 正式 启用 重量级 锁。 启用 过程 分为 两步： 首先 通过 inflate() 方法 进行 锁 膨胀， 其 目的 是 获得 对象 的 ObjectMonitor； 然后 使用 enter() 方法 尝试 进入 该 锁。 在 调用 enter() 方法 时， 线程 很可能 会在 操作系统 层面 被 挂起， 此时 线程 间 切换 和 调度 的 成本 就会 比 较高。</p>
<h3 id="8-2-4-自旋锁"><a href="#8-2-4-自旋锁" class="headerlink" title="8.2.4 自旋锁"></a>8.2.4 自旋锁</h3><p>​    锁 膨胀 后， 进入 ObjectMonitor 的 enter() 方法， 线程 很可能 会在 操作系统 层面 被 挂起， 这样 线程 上下文 切换 的 性能 损失 就比 较大。 在 锁 膨胀 之后， 虚拟 机会 做 最后 的 争取， 希望 线程 可以 尽快 进入 临界 区 而 避免 被 操作系统 挂起。 一种 较为 有效 的 手段 就是 使用 自 旋 锁。</p>
<p>​    自 旋 锁 可以 使 线程 在 没有 取得 锁 时不 被 挂起， 而去 执行 一个 空 循环（ 即 所谓 的 自 旋）， 在 若干个 空 循环 后， 线程 如果 可以 获得 锁， 则 继续 执行。 若 线程 依然 不能 获得 锁， 才会 被 挂起。 使用 自 旋 锁 后， 线程 被 挂起 的 概率 相对 减小， 线程 执行 的 连贯性 相对 加强。 因此， 对于 那些 锁 竞争 不是 很 激烈、 锁 占用 时间 很短 的 并发 线程， 具有 一定 的 积极 意义， 但 对于 锁 竞争 激烈、 单 线程 锁 占用 时间 长的 并发 程序， 自 旋 锁 在 自 旋 等待 后， 往往 依然 无法 获得 对应 的 锁， 不仅 白白 浪费 了 CPU 时间， 最终 还是 免不了 被 挂起， 浪费 了 系统 资源。</p>
<p>​    在 JDK 1. 6 中， Java 虚拟 机 提供- XX:+ UseSpinning 参数 来 开启 自 旋 锁， 使用- XX: PreBlockSpin 参数 来 设置 自 旋 锁 的 等待 次数。 </p>
<p>​    在 JDK 1. 7 后的 版本， 自 旋 锁 的 参数 被 取消， 虚拟 机 不再 支持 由 用户 配置 自 旋 锁。 自 旋 锁 总是 被 执行， 自 旋 次数 也由 虚拟 机 自行 调整。</p>
<h3 id="8-2-5-锁消除"><a href="#8-2-5-锁消除" class="headerlink" title="8.2.5 锁消除"></a>8.2.5 锁消除</h3><p>​    锁 消除 是 Java 虚拟 机 在 JIT 编译 时， 通过 对 运行 上下文 的 扫描， 去除 不可能 存在 共享 资源 竞争 的 锁。 通过 锁 消除， 可以 节省 毫无意义 的 请求 锁 时间。</p>
<p>​    虚拟 机 可以 在 运行时， 基于 逃逸 分析 技术， 捕获 这些 不可能 存在 竞争 却有 申请 锁 的 代码 段， 并 消除 这些 不必要 的 锁， 从而 提高 系统 性能。</p>
<p>​    逃逸 分析 和 锁 消除 分别 可以 使用 参数- XX:+ DoEscapeAnalysis 和- XX:+ EliminateLocks 开启（ 锁 消除 必须 工作 在- server 模式 下）。</p>
<h2 id="8-3-应对残酷的竞争-锁在应用层的优化思路"><a href="#8-3-应对残酷的竞争-锁在应用层的优化思路" class="headerlink" title="8.3 应对残酷的竞争: 锁在应用层的优化思路"></a>8.3 应对残酷的竞争: 锁在应用层的优化思路</h2><h3 id="8-3-1-减少锁持有时间"><a href="#8-3-1-减少锁持有时间" class="headerlink" title="8.3.1 减少锁持有时间"></a>8.3.1 减少锁持有时间</h3><p>注意： 减少 锁 的 持有 时间 有助于 减小 锁 冲突 的 可能性， 进而 提升 系统 的 并发 能力。</p>
<h3 id="8-3-2-减少锁粒度"><a href="#8-3-2-减少锁粒度" class="headerlink" title="8.3.2 减少锁粒度"></a>8.3.2 减少锁粒度</h3><p>​    减小 锁 粒度 也是 一种 削弱 多 线程 锁 竞争 的 有效 手段。 这种 技术 典型的 使用 场景 就是 ConcurrentHashMap 类 的 实现。</p>
<p>​    减少 锁 粒度 会 引入 一个 新的 问题： 当 系统 需要 取得 全局 锁 时， 消耗 的 资源 会 比较 多。</p>
<p>注意： 所谓 减少 锁 粒度， 就是 指 缩小 锁定 对象 的 范围， 从而 减小 锁 冲突 的 可能性， 进而 提高 系统 的 并发 能力。</p>
<h3 id="8-3-3-锁分离"><a href="#8-3-3-锁分离" class="headerlink" title="8.3.3 锁分离"></a>8.3.3 锁分离</h3><p>​    锁 分离 是 减小 锁 粒度 的 一个 特例， 它 依据 应用 程序 的 功能 特点， 将 一个 独占 锁 分成 多个 锁。 一个 典型的 案例 就是 java. util. concurrent. LinkedBlockingQueue 的 实现。</p>
<h3 id="8-3-4-锁粗化"><a href="#8-3-4-锁粗化" class="headerlink" title="8.3.4 锁粗化"></a>8.3.4 锁粗化</h3><p>​    在 通常 情况下， 为了 保证 多 线程 的 有效 并发， 会要 求 每个 线程 持有 锁 的 时间 尽量 短， 即在 使用 完 公共 资源 后， 应该 立即 释放 锁。 只有 这样， 等待 这个 锁 的 其他 线程 才能 尽早 地 获得 资源 执行任务。 但是， 凡事 都有 一个 度， 如果 对 同一个 锁 不停 地 进行 请求、 同步 和 释放， 本身 也会 消耗 系统 宝贵 的 资源， 反而 不利于 性能 优化。 </p>
<p>​    为此， 虚拟 机 在 遇到 一连串 连续 地 对 同一 锁 不断 进行 请求 和 释放 的 操作 时， 便会 把 所 有的 锁 操作 整合 成对 锁 的 一次 请求， 从而 减少 对 锁 的 请求 同步 次数， 这个 操作 叫作 锁 粗 化。</p>
<p><img src="https://pic.imgdb.cn/item/5f6eff6a160a154a67511272.jpg" alt=""></p>
<p>​    注意： 性能 优化 就是 根据 运行时 的 真实 情况 对 各个 资源 点 进行 权衡 的 过程。 锁 粗 化 的 思想 和 减少 锁 持有 时间 是 相反 的， 在 不同 的 场合 它们 的 效果 不同， 开发 人员 需要 根据 实际情况 进行 权衡。 此外， 前文 提到 的 偏向 锁、 自 旋 锁 作为 虚拟 机 内部 的 锁 优化 策略， 也不 是 绝对 可以 提高 系统 性能， 对 锁 的 优化 还是 需要 做 更多 的 权衡 和 思考。</p>
<h2 id="8-4-无招胜有招-无锁"><a href="#8-4-无招胜有招-无锁" class="headerlink" title="8.4 无招胜有招: 无锁"></a>8.4 无招胜有招: 无锁</h2><p>​    在高并发时，对锁的激烈竞争可能会成为系统瓶颈，为此，开发人员可以使用一种成为非阻塞同步的方法，不需要使用锁，所以也称为无锁。</p>
<h3 id="8-4-1-理解CAS"><a href="#8-4-1-理解CAS" class="headerlink" title="8.4.1 理解CAS"></a>8.4.1 理解CAS</h3><p>​    最简单的非阻塞同步为ThreadLocal，每个线程拥有各自独立的变量副本，无须相互等待。</p>
<p>​    本节将介绍一种更为重要的、基于CAS算法的无锁控制方法。</p>
<p>​    无锁算法的设计和实现都比锁复杂得多，但是对死锁问题天生免疫，而且拥有更加优越的性能。</p>
<p>​    CAS的过程是这样的: 包含3个参数，形式是CAS(V,E,N)。V表示要更新的变量,E表示预期值,N表示新值。仅当V的值等于E的值时，才会将V的值更新为N，否则说明已经有其他线程做了更新，则当前线程什么都不做。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然也允许放弃。</p>
<p>​    JDK1.6以后，虚拟机可以使用这个指令来实现并发操作和并发数据结构</p>
<p><img src="https://pic.imgdb.cn/item/5f6f0173160a154a6751a7b1.jpg" alt=""></p>
<h3 id="8-4-2-原子操作"><a href="#8-4-2-原子操作" class="headerlink" title="8.4.2 原子操作"></a>8.4.2 原子操作</h3><p>​    JDK的java.util.concurrent.atomic包下,有一组使用无锁算法实现的原子操作类。</p>
<p>​    以AtomicInteger为例，核心方法有：</p>
<p><img src="https://pic.imgdb.cn/item/5f6f01c2160a154a6751d4f3.jpg" alt=""></p>
<h3 id="8-4-3-新宠儿LongAddr"><a href="#8-4-3-新宠儿LongAddr" class="headerlink" title="8.4.3 新宠儿LongAddr"></a>8.4.3 新宠儿LongAddr</h3><p>​    JDK1.8引入了LongAddr类，性能更上一层楼。</p>
<p>​    AtomicInteger等原子类的实现，都在一个死循环内，不断尝试修改目标值，知道修改成功。如果竞争不激烈，修改成功概率就很高。如果大量修改失败时，会影响性能。</p>
<p>​    结合前文介绍的减少锁粒度，有一种改进思路。一种方案是仿造ConcurrentHashMap，将热点数据分离。LongAdder就使用了这种思想。</p>
<p><img src="https://pic.imgdb.cn/item/5f6f026e160a154a67520dd3.jpg" alt=""></p>
<p>​    </p>
<h2 id="8-5-将随机变为可控-理解Java内存模型"><a href="#8-5-将随机变为可控-理解Java内存模型" class="headerlink" title="8.5 将随机变为可控: 理解Java内存模型"></a>8.5 将随机变为可控: 理解Java内存模型</h2><p>​    Java内存模型(JMM)就是用来解释多线程数据访问的一致性，将这种看似随机的状态变为可控，从而屏蔽多线程可能引发的种种问题。</p>
<h3 id="8-5-1-原子性"><a href="#8-5-1-原子性" class="headerlink" title="8.5.1 原子性"></a>8.5.1 原子性</h3><p>​    原子性的原子代表不可分割的意思。</p>
<h3 id="8-5-2-有序性"><a href="#8-5-2-有序性" class="headerlink" title="8.5.2 有序性"></a>8.5.2 有序性</h3><p>​    在指令执行时，可能会对目标指令进行重排，对于当前线程自己看是有序的，但是一个线程观察另外一个线程时，可能会乱序。</p>
<p><img src="https://pic.imgdb.cn/item/5f6f039a160a154a67526e07.jpg" alt=""></p>
<h3 id="8-5-3-可见性"><a href="#8-5-3-可见性" class="headerlink" title="8.5.3 可见性"></a>8.5.3 可见性</h3><p>​    可见性是指当一个线程修改一个变量的值时，在另外一个线程中可以马上得知这个修改。由于系统编译器优化，部分变量的值可能会被寄存器或高速缓冲缓存，而每个CPU都拥有独立的寄存器和Cache，从而导致其他线程无法发现这个修改。</p>
<h3 id="8-5-4-Happens-Befor原则"><a href="#8-5-4-Happens-Befor原则" class="headerlink" title="8.5.4 Happens-Befor原则"></a>8.5.4 Happens-Befor原则</h3><p>​    指令重排有原则，以下是一些基本原则:</p>
<p><img src="https://pic.imgdb.cn/item/5f6f0476160a154a6752b65a.jpg" alt=""></p>
<h1 id="第9章-Class文件结构"><a href="#第9章-Class文件结构" class="headerlink" title="第9章 Class文件结构"></a>第9章 Class文件结构</h1><p>知识点：</p>
<ul>
<li>Class文件的基本结构</li>
<li>使用jClassLib查看Class文件</li>
<li>使用ASM手工生成Class文件</li>
</ul>
<h2 id="9-1-不仅跨平台，还能跨语言-语言无关性"><a href="#9-1-不仅跨平台，还能跨语言-语言无关性" class="headerlink" title="9.1 不仅跨平台，还能跨语言: 语言无关性"></a>9.1 不仅跨平台，还能跨语言: 语言无关性</h2><p><img src="https://pic.imgdb.cn/item/5f709101160a154a67c8bd7a.jpg" alt=""></p>
<h2 id="9-2-虚拟机的基石-Class文件"><a href="#9-2-虚拟机的基石-Class文件" class="headerlink" title="9.2 虚拟机的基石:Class文件"></a>9.2 虚拟机的基石:Class文件</h2><p><img src="https://pic.imgdb.cn/item/5f70911d160a154a67c8c9bc.jpg" alt=""></p>
<p>​    </p>
<p>​    在Java虚拟机规范中， Class文件使用一种类似于C语言结构体的方式进行描述，并且同意使用无符号整数为基本类型，由u1、u2、u4、u8分别表示无符号单字节、2字节、4字节和8字节整数。对于字符串，则使用u1数组进行表示。</p>
<p><img src="https://pic.imgdb.cn/item/5f7091da160a154a67c91f6f.jpg" alt=""></p>
<p>(1) 文字以一个4字节的Magic(被称为魔数)老太皮，紧跟大、小版本号</p>
<p>(2) 在版本号之后是常量池, 常量池的个数为constant_pool_count, 常量池中的表项有constant_pool_count-1项，</p>
<p>(3) 常量池之后是类的访问修饰符、代表自身类的引用、父类引用及接口数量和实现的接口引用。</p>
<p>(4) 在接口之后，有字段的数量和字段描述、方法数量及方法的描述。</p>
<p>(5) 存放类文件的属性信息。</p>
<h3 id="9-2-1-Class文件的标志——魔数"><a href="#9-2-1-Class文件的标志——魔数" class="headerlink" title="9.2.1 Class文件的标志——魔数"></a>9.2.1 Class文件的标志——魔数</h3><p>​    魔数作为Class文件的标志，用来告诉Java虚拟机，这是一个Class文件。固定为0xCAFEBABE。</p>
<h3 id="9-2-2-Class文件的版本"><a href="#9-2-2-Class文件的版本" class="headerlink" title="9.2.2 Class文件的版本"></a>9.2.2 Class文件的版本</h3><p>​    魔数后面，紧跟Class的小版本号和大版本号。首先是小版本号，2字节无符号整数，之后是大版本号，也是2字节。</p>
<p><img src="https://pic.imgdb.cn/item/5f709386160a154a67c9bad4.jpg" alt=""></p>
<p>​    目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。</p>
<h3 id="9-2-3-存放所有常数——常量池"><a href="#9-2-3-存放所有常数——常量池" class="headerlink" title="9.2.3 存放所有常数——常量池"></a>9.2.3 存放所有常数——常量池</h3><p>​    在版本号之后，紧跟的是常量池的数量以及若干个常量池表项。</p>
<p>​    在详细解析常量池之之前，先给出常量池表项类型及TAG值。</p>
<p><img src="https://pic.imgdb.cn/item/5f709417160a154a67c9ef46.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f709576160a154a67ca6cc0.jpg" alt=""></p>
<p>​    UTF8常量经常被其他类型的常量引用。</p>
<p><img src="https://pic.imgdb.cn/item/5f7095ab160a154a67ca831c.jpg" alt=""></p>
<p>​    其中tag为7，name_index表示常量池的索引，该索引指向的常量必须是CONSTANT_Utf8</p>
<p><img src="https://pic.imgdb.cn/item/5f709665160a154a67cad823.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f7096b8160a154a67cafad9.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f70972e160a154a67cb322c.jpg" alt=""></p>
<p>类的方法和字段分别用CONSTANT_Methodref和CONSTANT_Fieldref表示。</p>
<p><img src="https://pic.imgdb.cn/item/5f709757160a154a67cb4595.jpg" alt=""></p>
<p>其他暂略</p>
<h3 id="9-2-4-CLass的访问标记-Access-Flag"><a href="#9-2-4-CLass的访问标记-Access-Flag" class="headerlink" title="9.2.4 CLass的访问标记(Access Flag)"></a>9.2.4 CLass的访问标记(Access Flag)</h3><p><img src="https://pic.imgdb.cn/item/5f70987b160a154a67cbc7b3.jpg" alt=""></p>
<h3 id="9-2-5-当前类、父类和接口"><a href="#9-2-5-当前类、父类和接口" class="headerlink" title="9.2.5 当前类、父类和接口"></a>9.2.5 当前类、父类和接口</h3><p>​    在访问标记后，会指定该类的类别、父类类别及实现的接口。</p>
<p><img src="https://pic.imgdb.cn/item/5f709965160a154a67cc37d7.jpg" alt=""></p>
<h3 id="9-2-6-Class文件的字段"><a href="#9-2-6-Class文件的字段" class="headerlink" title="9.2.6 Class文件的字段"></a>9.2.6 Class文件的字段</h3><p>​    由于一个类有多个字段，所以需要首先指明字段的个数。</p>
<p><img src="https://pic.imgdb.cn/item/5f709a68160a154a67ccb0ee.jpg" alt=""></p>
<p>(1) 字段的访问标记，非常类似于类的访问标记。</p>
<p><img src="https://pic.imgdb.cn/item/5f709a86160a154a67ccc1e1.jpg" alt=""></p>
<p>(2) 一个2字节整数，表示字段的名称，它指向常量池中的CONSTANT_Utf8结构</p>
<p>(3) 名称后的descriptor_index也指向Utf8，用于描述字段的类型。</p>
<p>(4) 一个字段可能还拥有一些属性，用于存储更多的额外信息，比如初始值、一些注释信息等。</p>
<p><img src="https://pic.imgdb.cn/item/5f709c3a160a154a67cda807.jpg" alt=""></p>
<h3 id="9-2-7-Class文件的方法基本结构"><a href="#9-2-7-Class文件的方法基本结构" class="headerlink" title="9.2.7 Class文件的方法基本结构"></a>9.2.7 Class文件的方法基本结构</h3><p><img src="https://pic.imgdb.cn/item/5f709c80160a154a67cdc902.jpg" alt=""></p>
<h3 id="9-2-8-方法的执行主体——Code属性"><a href="#9-2-8-方法的执行主体——Code属性" class="headerlink" title="9.2.8 方法的执行主体——Code属性"></a>9.2.8 方法的执行主体——Code属性</h3><p>​    <img src="https://pic.imgdb.cn/item/5f709cc3160a154a67cde87c.jpg" alt=""></p>
<h3 id="9-2-9-记录行号——LineNumberTable属性"><a href="#9-2-9-记录行号——LineNumberTable属性" class="headerlink" title="9.2.9 记录行号——LineNumberTable属性"></a>9.2.9 记录行号——LineNumberTable属性</h3><p><img src="https://pic.imgdb.cn/item/5f709d16160a154a67ce1dd2.jpg" alt=""></p>
<h3 id="9-2-10-保存局部变量和参数——LocalVariableTable属性"><a href="#9-2-10-保存局部变量和参数——LocalVariableTable属性" class="headerlink" title="9.2.10 保存局部变量和参数——LocalVariableTable属性"></a>9.2.10 保存局部变量和参数——LocalVariableTable属性</h3><p>​    局部变量表。</p>
<p><img src="https://pic.imgdb.cn/item/5f709d38160a154a67ce2fd9.jpg" alt=""></p>
<h3 id="9-2-11-加快字节码校验——StackMapTable属性"><a href="#9-2-11-加快字节码校验——StackMapTable属性" class="headerlink" title="9.2.11 加快字节码校验——StackMapTable属性"></a>9.2.11 加快字节码校验——StackMapTable属性</h3><p>​    <img src="https://pic.imgdb.cn/item/5f709d9d160a154a67ce65ac.jpg" alt=""></p>
<h3 id="9-2-12-Code属性总结"><a href="#9-2-12-Code属性总结" class="headerlink" title="9.2.12 Code属性总结"></a>9.2.12 Code属性总结</h3><p><img src="https://pic.imgdb.cn/item/5f709e26160a154a67cea364.jpg" alt=""></p>
<h3 id="9-2-13-抛出异常——Exceptions属性"><a href="#9-2-13-抛出异常——Exceptions属性" class="headerlink" title="9.2.13 抛出异常——Exceptions属性"></a>9.2.13 抛出异常——Exceptions属性</h3><p><img src="https://pic.imgdb.cn/item/5f709e5b160a154a67ceb932.jpg" alt=""></p>
<h3 id="9-2-14-用实例分析Class的方法结构"><a href="#9-2-14-用实例分析Class的方法结构" class="headerlink" title="9.2.14 用实例分析Class的方法结构"></a>9.2.14 用实例分析Class的方法结构</h3><p>略</p>
<h3 id="9-2-15-我来自哪里——SourceFile属性"><a href="#9-2-15-我来自哪里——SourceFile属性" class="headerlink" title="9.2.15 我来自哪里——SourceFile属性"></a>9.2.15 我来自哪里——SourceFile属性</h3><p><img src="https://pic.imgdb.cn/item/5f709ea2160a154a67ced659.jpg" alt=""></p>
<h3 id="9-2-16-强大的动态调用——BootstrapMethods属性"><a href="#9-2-16-强大的动态调用——BootstrapMethods属性" class="headerlink" title="9.2.16 强大的动态调用——BootstrapMethods属性"></a>9.2.16 强大的动态调用——BootstrapMethods属性</h3><p>​    为了支持JDK1.7中的invokeDynamic指令，增加了BootstrapMethods属性。</p>
<p><img src="https://pic.imgdb.cn/item/5f709eed160a154a67cef4a5.jpg" alt=""></p>
<h3 id="9-2-17-内部类——InnerClasses属性"><a href="#9-2-17-内部类——InnerClasses属性" class="headerlink" title="9.2.17 内部类——InnerClasses属性"></a>9.2.17 内部类——InnerClasses属性</h3><p><img src="https://pic.imgdb.cn/item/5f709f33160a154a67cf18bb.jpg" alt=""></p>
<h3 id="9-2-18-将要废弃的通知——Deprecated属性"><a href="#9-2-18-将要废弃的通知——Deprecated属性" class="headerlink" title="9.2.18 将要废弃的通知——Deprecated属性"></a>9.2.18 将要废弃的通知——Deprecated属性</h3><p><img src="https://pic.imgdb.cn/item/5f709f53160a154a67cf2501.jpg" alt=""></p>
<h2 id="9-3-操作字节码：走进ASM"><a href="#9-3-操作字节码：走进ASM" class="headerlink" title="9.3 操作字节码：走进ASM"></a>9.3 操作字节码：走进ASM</h2><h3 id="9-3-1-ASM体系结构"><a href="#9-3-1-ASM体系结构" class="headerlink" title="9.3.1 ASM体系结构"></a>9.3.1 ASM体系结构</h3><p>​    以ASM5.0作为基础进行讲解。</p>
<p><img src="https://pic.imgdb.cn/item/5f709faf160a154a67cf537a.jpg" alt=""></p>
<p>略</p>
<h3 id="9-3-2-ASM之Hello-World"><a href="#9-3-2-ASM之Hello-World" class="headerlink" title="9.3.2 ASM之Hello World"></a>9.3.2 ASM之Hello World</h3><p>略</p>
<h1 id="第10章-Class装载系统"><a href="#第10章-Class装载系统" class="headerlink" title="第10章 Class装载系统"></a>第10章 Class装载系统</h1><p>知识点：</p>
<ul>
<li>Class文件的加载过程。</li>
<li>ClassLoader的工作模式。</li>
<li>有关类的热加载</li>
</ul>
<h2 id="10-1-来去都有序-看懂Class文件的装载过程"><a href="#10-1-来去都有序-看懂Class文件的装载过程" class="headerlink" title="10.1 来去都有序: 看懂Class文件的装载过程"></a>10.1 来去都有序: 看懂Class文件的装载过程</h2><p>​    Class通常以文件形式存在，只有被Java虚拟机装载的Class类型才能在程序中使用。系统装载Class可以分为加载、连接和初始化3步。连接又可分为验证、准备和解析3步。</p>
<p><img src="https://pic.imgdb.cn/item/5f71d354160a154a672bcd00.jpg" alt=""></p>
<h3 id="10-1-1-类装载的条件"><a href="#10-1-1-类装载的条件" class="headerlink" title="10.1.1 类装载的条件"></a>10.1.1 类装载的条件</h3><p>​    Class文件只有在必须要使用的时候才会被装载，不会无条件装载Class。一个类或接口在初次使用前，必须进行初始化。主动使用只有下列几种情况：</p>
<p><img src="https://pic.imgdb.cn/item/5f71d3b3160a154a672be445.jpg" alt=""></p>
<p>​    如果使用-XX:+TraceClassLoading参数，可以跟踪类加载。</p>
<p>​    在使用一个字段时，只有直接定义该字段的类才会被初始化。</p>
<p>​    final常量不会引起类初始化。</p>
<p>​    javac在编译时，将常量直接植入目标类，不再使用被引用类。</p>
<p>​    注意：并不是在代码中出现的类就一定会被加载或初始化。</p>
<h3 id="10-1-2-加载类"><a href="#10-1-2-加载类" class="headerlink" title="10.1.2 加载类"></a>10.1.2 加载类</h3><p>​    加载类是第一个阶段，在该阶段，必须完成以下工作：</p>
<ul>
<li>通过类的全面获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区的数据结构。</li>
<li>创建java.lang.Class类的实例，表示该类型。</li>
</ul>
<h3 id="10-1-3-验证类"><a href="#10-1-3-验证类" class="headerlink" title="10.1.3 验证类"></a>10.1.3 验证类</h3><p>​    开始连接操作，第一步是验证，目的是保证加载的字节码是合法、合理并且规范的。验证的步骤比较复杂，实际要验证的项目很繁多。虚拟机要做的检查如图</p>
<p><img src="https://pic.imgdb.cn/item/5f71d837160a154a672d0fc2.jpg" alt=""></p>
<p>(1) 必须判断类的二进制数据是否符合格式要求和规范，比如魔数、主版本和肖版本号，数据中的每一项的长度的正确性，等等。</p>
<p>(2) 语义检查，父类是否存在，final方法或类是否被重载或继承了，非抽象类是否实现了所有抽象方法或接口方法，是佛存在不兼容的方法。</p>
<p>(3) 字节码验证</p>
<p>(4) 进行符号引用验证。Class文件在常量池会通过字符串记录自己将要使用的其他类或方法，会验证这些类或方法是否存在，以及是否有权限访问。如果无法找到，就会抛出NoClassDefFoundError。</p>
<h3 id="10-1-4-准备"><a href="#10-1-4-准备" class="headerlink" title="10.1.4 准备"></a>10.1.4 准备</h3><p>​    在这个阶段，会为类分配响应的内存空间，并设置初始值。</p>
<p><img src="https://pic.imgdb.cn/item/5f71d99d160a154a672d64c3.jpg" alt=""></p>
<p>​    如果类存在常量字段，那么常量字段也会在准备阶段被赋予上正确的值，这个赋值属于Java虚拟机行为，属于变量初始化。但是，在准备阶段不会有任何代码被执行。</p>
<p>​    如果没有final修饰，此时constString的复制在函数<code>&lt;client&gt;</code>中发生，属于Java字节码的行为。</p>
<p>​    注意：ldc字节码会加载一个常量到操作数栈中，putstatic字节码设置给定的静态字段的值。</p>
<h3 id="10-1-5-解析类"><a href="#10-1-5-解析类" class="headerlink" title="10.1.5 解析类"></a>10.1.5 解析类</h3><p>​    解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。</p>
<p>​    符号引用就是一些字面量的引用，和虚拟机的内部数据结构与内存布局无关。</p>
<p>​    所谓的解析就是将符号引用转换为直接引用，也就是得到类或者字段、方法在内存中的指针或偏移量。</p>
<h3 id="10-1-6-初始化"><a href="#10-1-6-初始化" class="headerlink" title="10.1.6 初始化"></a>10.1.6 初始化</h3><p>​    初始化阶段的重要工作就是执行类的初始化方法<code>&lt;client&gt;</code>。由编译器自动生成，是类静态成员复制语句以及static块共同产生。</p>
<p>​    虚拟机会在内部确保其多线程环境中的安全性。只有一个线程可以进入<code>&lt;client&gt;</code>方法。带锁安全，可能出现死锁，很难发现，而且没有可用的锁信息。</p>
<p><img src="https://pic.imgdb.cn/item/5f71dd60160a154a672e9ed2.jpg" alt=""></p>
<h2 id="10-2-一切Class从这里开始-掌握Classloader"><a href="#10-2-一切Class从这里开始-掌握Classloader" class="headerlink" title="10.2 一切Class从这里开始: 掌握Classloader"></a>10.2 一切Class从这里开始: 掌握Classloader</h2><p>​    它主要工作在Class装载的加载阶段，主要作用是从系统外部获得Class二进制流。</p>
<h3 id="10-2-1-认识ClassLoader，看懂类加载"><a href="#10-2-1-认识ClassLoader，看懂类加载" class="headerlink" title="10.2.1 认识ClassLoader，看懂类加载"></a>10.2.1 认识ClassLoader，看懂类加载</h3><p>​    只能印象类的加载。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f71ddcb160a154a672ec4ec.jpg" alt=""></p>
<h3 id="10-2-2-ClassLoader的分类。"><a href="#10-2-2-ClassLoader的分类。" class="headerlink" title="10.2.2 ClassLoader的分类。"></a>10.2.2 ClassLoader的分类。</h3><p>​    在标准Java程序中，会创建3类ClassLoader为整个应用程序服务。</p>
<ul>
<li>BootStrap ClassLoader: 启动类加载器。</li>
<li>Extension ClassLoader: 扩展类加载器。</li>
<li>App ClassLoader: 应用类加载器。</li>
</ul>
<p>每一个应用程序还可以拥有自定义的ClassLoader，以扩展Java虚拟机获取Class数据的能力。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f71de71160a154a672f0456.jpg" alt=""></p>
<p>​    判断类是否已经被加载时，会从底层类加载器来时判断，需要加载类会从顶层类开始加载。</p>
<p>​    任何在启动类中加载的类是无法获取其ClassLoader实例，因为它是一个系统级的纯C语言的实现。</p>
<h3 id="10-2-3-ClassLoader的双亲委派模式"><a href="#10-2-3-ClassLoader的双亲委派模式" class="headerlink" title="10.2.3 ClassLoader的双亲委派模式"></a>10.2.3 ClassLoader的双亲委派模式</h3><p>​    在类加载时，会判断类是否已经被加载，如果已经被加载，就会直接返回可用类，否则会尝试加载。在加载时，会先请求双亲处理。</p>
<p><img src="https://pic.imgdb.cn/item/5f71e091160a154a672fa450.jpg" alt=""></p>
<p>提示：双亲为null有连中华情况：第一，双亲就是启动类加载器，第二，当前就是启动类加载器。</p>
<p><img src="https://pic.imgdb.cn/item/5f71e10e160a154a672fc848.jpg" alt=""></p>
<p>-Xbootclasspath参数可以修改启动ClassPath。</p>
<h3 id="10-2-4-双亲委派模式的弊端"><a href="#10-2-4-双亲委派模式的弊端" class="headerlink" title="10.2.4 双亲委派模式的弊端"></a>10.2.4 双亲委派模式的弊端</h3><p>​    检查类是否已经加载的委托过程是单向的，但是会带来一个问题，上层的ClassLoader无法访问下层ClassLoader所加载的类。</p>
<h3 id="10-2-5-双亲委派模式的补充"><a href="#10-2-5-双亲委派模式的补充" class="headerlink" title="10.2.5 双亲委派模式的补充"></a>10.2.5 双亲委派模式的补充</h3><p>​    通常把狠心类(rt.jar)中提供外部服务、可由应用层自行实现的接口称为Service Provider Interface，即SPI。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f71e2bf160a154a67302c7f.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f71e2ce160a154a67303010.jpg" alt=""></p>
<h3 id="10-2-6-突破双亲模式"><a href="#10-2-6-突破双亲模式" class="headerlink" title="10.2.6 突破双亲模式"></a>10.2.6 突破双亲模式</h3><p>​    双亲模式是默认行为，但是并非必须这么做，通过重载ClassLoader可以修改该行为。</p>
<h3 id="10-2-7-热替换的实现"><a href="#10-2-7-热替换的实现" class="headerlink" title="10.2.7 热替换的实现"></a>10.2.7 热替换的实现</h3><p>​    Java并非天生就支持热替换，实现这个功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f71e458160a154a6730a6c9.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f71e492160a154a6730b668.jpg" alt=""></p>
<h1 id="第11章-字节码执行"><a href="#第11章-字节码执行" class="headerlink" title="第11章 字节码执行"></a>第11章 字节码执行</h1><p>知识点：</p>
<ul>
<li>使用javap查看Class文件信息。</li>
<li>了解字节码执行过程。</li>
<li>熟悉常用字节码。</li>
<li>学习JIT相关参数配置。</li>
<li>通过ASM增强方法的功能。</li>
<li>使用Java Agent动态修改字节码。</li>
</ul>
<h2 id="11-1-代码如何执行：字节码执行案例"><a href="#11-1-代码如何执行：字节码执行案例" class="headerlink" title="11.1 代码如何执行：字节码执行案例"></a>11.1 代码如何执行：字节码执行案例</h2><p>​    <img src="https://pic.imgdb.cn/item/5f71e88b160a154a6731f85a.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f71e899160a154a6731fc90.jpg" alt=""></p>
<p>​    calc()方法里面显示了栈大小、局部变量表大小、字节码指令、行号、局部变量表。</p>
<h2 id="11-2-执行的基础-Java虚拟机常用指令介绍"><a href="#11-2-执行的基础-Java虚拟机常用指令介绍" class="headerlink" title="11.2 执行的基础: Java虚拟机常用指令介绍"></a>11.2 执行的基础: Java虚拟机常用指令介绍</h2><h3 id="11-2-1-常量入栈指令"><a href="#11-2-1-常量入栈指令" class="headerlink" title="11.2.1 常量入栈指令"></a>11.2.1 常量入栈指令</h3><p>​    const系列指令用于特定的常量入栈，入栈的常量隐含在指令本身。</p>
<p><img src="https://pic.imgdb.cn/item/5f71e9af160a154a67325139.jpg" alt=""></p>
<h3 id="11-2-2-局部变量压栈指令"><a href="#11-2-2-局部变量压栈指令" class="headerlink" title="11.2.2 局部变量压栈指令"></a>11.2.2 局部变量压栈指令</h3><p><img src="https://pic.imgdb.cn/item/5f71e9cc160a154a6732587e.jpg" alt=""></p>
<h3 id="11-2-3-出栈装入局部变量表指令"><a href="#11-2-3-出栈装入局部变量表指令" class="headerlink" title="11.2.3 出栈装入局部变量表指令"></a>11.2.3 出栈装入局部变量表指令</h3><p>​    主要以store形式存在，比如xstore(x为i、l、f、d、a)、xstore_n(x为i、l、f、d、a，n为0到3)和xstore(x为i、l、f、d、a、b、c、s)。</p>
<h3 id="11-2-4-通用型操作"><a href="#11-2-4-通用型操作" class="headerlink" title="11.2.4 通用型操作"></a>11.2.4 通用型操作</h3><p>​    通用性操作提供了无须指明数据类型的操作。</p>
<p>​    指令NOP是一个非常特殊指令，字节码位0x00，表示什么都不做。用于调试、占位等。</p>
<p>​    还有两个比较重要的dup和pop，前者是复制，复制栈顶元素并压栈。pop则是把一个元素从栈顶弹出，并直接废弃。</p>
<p>​    注意：pop指令只能丢弃一个字节长，如果要丢弃栈顶64位数据，则需要pop2，同理还有dup2指令。</p>
<h3 id="11-2-5-类型转换指令"><a href="#11-2-5-类型转换指令" class="headerlink" title="11.2.5 类型转换指令"></a>11.2.5 类型转换指令</h3><p><img src="https://pic.imgdb.cn/item/5f71ec6b160a154a67334faa.jpg" alt=""></p>
<h3 id="11-2-6-运算指令"><a href="#11-2-6-运算指令" class="headerlink" title="11.2.6 运算指令"></a>11.2.6 运算指令</h3><p><img src="https://pic.imgdb.cn/item/5f71ec94160a154a67336000.jpg" alt=""></p>
<h3 id="11-2-7-对象操作指令"><a href="#11-2-7-对象操作指令" class="headerlink" title="11.2.7 对象操作指令"></a>11.2.7 对象操作指令</h3><h4 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1.创建指令"></a>1.创建指令</h4><p>​    主要有new, newarrray, anewarray和multianewarray。</p>
<h4 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2. 字段访问指令"></a>2. 字段访问指令</h4><p>​    主要有getfield, putfield, getstatic, putstatic</p>
<h4 id="3-类型检查指令"><a href="#3-类型检查指令" class="headerlink" title="3. 类型检查指令"></a>3. 类型检查指令</h4><p>​    主要有checkcast和instanceof。</p>
<h4 id="4-数组操作指令"><a href="#4-数组操作指令" class="headerlink" title="4. 数组操作指令"></a>4. 数组操作指令</h4><p>​    主要有xastore和xload。</p>
<h3 id="11-2-8-比较控制指令"><a href="#11-2-8-比较控制指令" class="headerlink" title="11.2.8 比较控制指令"></a>11.2.8 比较控制指令</h3><h4 id="1-比较指令"><a href="#1-比较指令" class="headerlink" title="1.比较指令"></a>1.比较指令</h4><p>​    有dcmpg, fcmpg, fcmpl, lcmp。</p>
<h4 id="2-条件跳转指令"><a href="#2-条件跳转指令" class="headerlink" title="2. 条件跳转指令"></a>2. 条件跳转指令</h4><p>​    有ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnotnull。</p>
<h4 id="3-比较跳转指令"><a href="#3-比较跳转指令" class="headerlink" title="3. 比较跳转指令"></a>3. 比较跳转指令</h4><p>​    比较指令和条件跳转指令的结合体。</p>
<p>​    有if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpge, if_acmpeq和if_acmpne.</p>
<p>​    如果条件成立则跳转。</p>
<h4 id="4-多分支跳转指令"><a href="#4-多分支跳转指令" class="headerlink" title="4.  多分支跳转指令"></a>4.  多分支跳转指令</h4><p>​    专门为swtich-case准备，主要有tableswitch和lookupswitch。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f71eea6160a154a673404f1.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f71eeb7160a154a673408cf.jpg" alt=""></p>
<h4 id="5-无条件跳转指令"><a href="#5-无条件跳转指令" class="headerlink" title="5.无条件跳转指令"></a>5.无条件跳转指令</h4><p>​    主要是goto。指令jsr、ret虽然也是无条件跳转，但是主要用于try-finally语句，而且逐渐被废弃。</p>
<p>​    goto接收两个字节的操作数，goto_w接收4个字节操作数，可以表示更大的地址范围。</p>
<h3 id="11-2-9-函数调用与返回指令"><a href="#11-2-9-函数调用与返回指令" class="headerlink" title="11.2.9 函数调用与返回指令"></a>11.2.9 函数调用与返回指令</h3><p>​    支持函数调用与返回值处理，提供了：</p>
<ul>
<li>invokevirtual</li>
<li>invokeinterface</li>
<li>invokespecial</li>
<li>invokestatic</li>
<li>invokedynamic</li>
</ul>
<h3 id="11-2-10-同步控制"><a href="#11-2-10-同步控制" class="headerlink" title="11.2.10 同步控制"></a>11.2.10 同步控制</h3><p>​    为了实现多线程同步，提供了monitorenter、moniterexit来完成临界区的进入和离开操作。</p>
<p>​    进入同步块时，当前对象的监视器数为0则准许进入，若为1，则判断持有当前监视器的线程是否是自己，如果是，则进入，否则进行等待，直到对象的监视器技术为0，才会允许进入同步块。虚拟机中，任何对象都有一个监视器与之关联，用来判断对象是否被锁定，监视器被持有后，对象处于锁定状态。</p>
<h3 id="11-2-11-再看Class的方法结构"><a href="#11-2-11-再看Class的方法结构" class="headerlink" title="11.2.11 再看Class的方法结构"></a>11.2.11 再看Class的方法结构</h3><p>​    略</p>
<h2 id="11-3-更上一层楼：再看ASM"><a href="#11-3-更上一层楼：再看ASM" class="headerlink" title="11.3 更上一层楼：再看ASM"></a>11.3 更上一层楼：再看ASM</h2><h3 id="11-3-1-为类增加安全控制"><a href="#11-3-1-为类增加安全控制" class="headerlink" title="11.3.1 为类增加安全控制"></a>11.3.1 为类增加安全控制</h3><p>略</p>
<h3 id="11-3-2-统计函数执行时间"><a href="#11-3-2-统计函数执行时间" class="headerlink" title="11.3.2 统计函数执行时间"></a>11.3.2 统计函数执行时间</h3><p>略</p>
<h2 id="11-4-谁说Java太刻板-Java-Agent运行时修改类"><a href="#11-4-谁说Java太刻板-Java-Agent运行时修改类" class="headerlink" title="11.4 谁说Java太刻板: Java Agent运行时修改类"></a>11.4 谁说Java太刻板: Java Agent运行时修改类</h2><h3 id="11-4-1-使用-javaagent参数启动虚拟机"><a href="#11-4-1-使用-javaagent参数启动虚拟机" class="headerlink" title="11.4.1 使用-javaagent参数启动虚拟机"></a>11.4.1 使用-javaagent参数启动虚拟机</h3><p>可以指定一个jar包，对该jar包有如下要求：</p>
<p>(1) 这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</p>
<p>(2)Premain-Class指定哪个类必须实现premain()方法。</p>
<p><img src="https://pic.imgdb.cn/item/5f71f493160a154a6735ca01.jpg" alt=""></p>
<h3 id="11-4-2-使用Java-Agent为函数增加计时功能"><a href="#11-4-2-使用Java-Agent为函数增加计时功能" class="headerlink" title="11.4.2 使用Java Agent为函数增加计时功能"></a>11.4.2 使用Java Agent为函数增加计时功能</h3><p>略</p>
<h3 id="11-4-3-动态重转换类"><a href="#11-4-3-动态重转换类" class="headerlink" title="11.4.3 动态重转换类"></a>11.4.3 动态重转换类</h3><p>略</p>
<h3 id="11-4-4-有关Java-Agent的总结"><a href="#11-4-4-有关Java-Agent的总结" class="headerlink" title="11.4.4 有关Java Agent的总结"></a>11.4.4 有关Java Agent的总结</h3><p>略</p>
<h2 id="11-5-与时俱进：动态方法调用"><a href="#11-5-与时俱进：动态方法调用" class="headerlink" title="11.5 与时俱进：动态方法调用"></a>11.5 与时俱进：动态方法调用</h2><p>这章没看明白</p>
<h3 id="11-5-1-方法句柄使用实例"><a href="#11-5-1-方法句柄使用实例" class="headerlink" title="11.5.1 方法句柄使用实例"></a>11.5.1 方法句柄使用实例</h3><p>略。</p>
<h3 id="11-5-2-调用点使用实例"><a href="#11-5-2-调用点使用实例" class="headerlink" title="11.5.2 调用点使用实例"></a>11.5.2 调用点使用实例</h3><p>略</p>
<h3 id="11-5-3-反射和方法句柄"><a href="#11-5-3-反射和方法句柄" class="headerlink" title="11.5.3 反射和方法句柄"></a>11.5.3 反射和方法句柄</h3><p>略</p>
<h3 id="11-5-4-指令invokedynamic"><a href="#11-5-4-指令invokedynamic" class="headerlink" title="11.5.4 指令invokedynamic"></a>11.5.4 指令invokedynamic</h3><p>略</p>
<h2 id="11-6-跑得再快点：静态编译优化"><a href="#11-6-跑得再快点：静态编译优化" class="headerlink" title="11.6 跑得再快点：静态编译优化"></a>11.6 跑得再快点：静态编译优化</h2><p>略</p>
<h2 id="11-7-提高虚拟机的执行效率-JIT及其相关参数"><a href="#11-7-提高虚拟机的执行效率-JIT及其相关参数" class="headerlink" title="11.7 提高虚拟机的执行效率:JIT及其相关参数"></a>11.7 提高虚拟机的执行效率:JIT及其相关参数</h2><p>略</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"># Java虚拟机</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/14/manacher%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="next" title="manacher算法笔记">
                <i class="fa fa-chevron-left"></i> manacher算法笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpg"
                alt="宋梓立 sorie" />
            
              <p class="site-author-name" itemprop="name">宋梓立 sorie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ewasong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:819294006@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-初探Java虚拟机"><span class="nav-number">1.</span> <span class="nav-text">第1章 初探Java虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-认识Java虚拟机的基本结构"><span class="nav-number">2.</span> <span class="nav-text">第2章 认识Java虚拟机的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-谋全局者才能成大器：看穿Java虚拟机的架构"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 谋全局者才能成大器：看穿Java虚拟机的架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-小参数能解决大问题：学会设置Java虚拟机参数"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 小参数能解决大问题：学会设置Java虚拟机参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-对象去哪儿：辨清Java堆"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 对象去哪儿：辨清Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-函数如何调用：出入Java栈"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 函数如何调用：出入Java栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-局部变量表"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-操作数栈"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-帧数据区"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 帧数据区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-栈上分配"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4 栈上分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-类去哪儿了：识别方法区"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 类去哪儿了：识别方法区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-常用Java虚拟机参数"><span class="nav-number">3.</span> <span class="nav-text">第3章 常用Java虚拟机参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-一切运行都有迹可循：掌握跟踪调试参数"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 一切运行都有迹可循：掌握跟踪调试参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-跟踪垃圾回收——读懂虚拟机日志"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 跟踪垃圾回收——读懂虚拟机日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-类加载-卸载的追踪"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 类加载&#x2F;卸载的追踪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-查看系统参数"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 查看系统参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-让性能飞起来：学习堆的配置参数"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 让性能飞起来：学习堆的配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-最大堆和初始堆的设置"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 最大堆和初始堆的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-新生代的配置"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 新生代的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-堆溢出处理"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 堆溢出处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-别让性能有缺口：了解非堆内存的参数配置"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 别让性能有缺口：了解非堆内存的参数配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-方法区配置"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 方法区配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-栈配置"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 栈配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-直接内存配置"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 直接内存配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Client和Server二选一：虚拟机工作模式"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Client和Server二选一：虚拟机工作模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-垃圾回收的概念与算法"><span class="nav-number">4.</span> <span class="nav-text">第4章 垃圾回收的概念与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-内存管理清洁工：认识垃圾回收"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 内存管理清洁工：认识垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-清洁工具打PK：讨论常用的垃圾回收算法"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 清洁工具打PK：讨论常用的垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-引用计数法-Reference-Counting"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 引用计数法(Reference Counting)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-标记清除算法-Mark-Sweep"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 标记清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-复制算法-Copying"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 复制算法(Copying)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-标记压缩算法-Mark-Compact"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 标记压缩算法(Mark-Compact)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-分代算法-Generational-Collecting"><span class="nav-number">4.2.5.</span> <span class="nav-text">4.2.5 分代算法(Generational Collecting)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-分区算法-Region"><span class="nav-number">4.2.6.</span> <span class="nav-text">4.2.6 分区算法(Region)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-谁才是真正的垃圾：判断可触及性"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 谁才是真正的垃圾：判断可触及性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-对象的复活"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 对象的复活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-引用和可触及性的强度"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 引用和可触及性的强度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-软引用——可被回收的引用"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 软引用——可被回收的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-弱引用——发现即回收"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4 弱引用——发现即回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-虚引用——对象回收跟踪"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5 虚引用——对象回收跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-垃圾回收时的停顿现象：Stop-TheWorld实战"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 垃圾回收时的停顿现象：Stop-TheWorld实战</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-垃圾收集器和内存分配"><span class="nav-number">5.</span> <span class="nav-text">第5章 垃圾收集器和内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-一心一意一件事：串行回收器"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 一心一意一件事：串行回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-新生代串行回收器"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 新生代串行回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-老年代串行回收器"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 老年代串行回收器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-人多力量大：并行回收器"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 人多力量大：并行回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-新生代ParNew回收器"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 新生代ParNew回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-新生代ParallelGC回收器"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 新生代ParallelGC回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-老年代ParallelOldGC会后器"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 老年代ParallelOldGC会后器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-一心多用都不落下：CMS回收器-JDK8及之前的版本"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 一心多用都不落下：CMS回收器(JDK8及之前的版本)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-CMS主要工作步骤"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 CMS主要工作步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-CMS主要的参数"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 CMS主要的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-CMS的日志分析"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 CMS的日志分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-有关Class的回收"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 有关Class的回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-未来我做主-G1回收器-JDK9及之后版本的默认回收器"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 未来我做主:G1回收器(JDK9及之后版本的默认回收器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-G1的内存划分和主要收集过程"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 G1的内存划分和主要收集过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-G1的新生代GC"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 G1的新生代GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-3-G1的并发标记周期"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.4.3 G1的并发标记周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-4-混合回收"><span class="nav-number">5.4.4.</span> <span class="nav-text">5.4.4 混合回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-5-必要时的Full-GC"><span class="nav-number">5.4.5.</span> <span class="nav-text">5.4.5 必要时的Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-6-G1的日志"><span class="nav-number">5.4.6.</span> <span class="nav-text">5.4.6 G1的日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-7-G1相关参数"><span class="nav-number">5.4.7.</span> <span class="nav-text">5.4.7 G1相关参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-回眸：有关对象内存分配和回收的一些细节问题"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 回眸：有关对象内存分配和回收的一些细节问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-禁用System-gc"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1  禁用System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-System-gc-使用并发回收"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2 System.gc()使用并发回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-并行GC前额外触发的新生代GC"><span class="nav-number">5.5.3.</span> <span class="nav-text">5.5.3 并行GC前额外触发的新生代GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-4-对象何时进入老年代"><span class="nav-number">5.5.4.</span> <span class="nav-text">5.5.4 对象何时进入老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-初创的对象在eden区"><span class="nav-number">5.5.4.1.</span> <span class="nav-text">1. 初创的对象在eden区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-老年对象进入老年代"><span class="nav-number">5.5.4.2.</span> <span class="nav-text">3. 老年对象进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-大对象进入老年代"><span class="nav-number">5.5.4.3.</span> <span class="nav-text">4. 大对象进入老年代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-5-在TLAB上分配对象"><span class="nav-number">5.5.5.</span> <span class="nav-text">5.5.5 在TLAB上分配对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-6-finalize-函数对垃圾回收的影响"><span class="nav-number">5.5.6.</span> <span class="nav-text">5.5.6 finalize()函数对垃圾回收的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-温故而知新"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 温故而知新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-与串行回收器相关的参数"><span class="nav-number">5.6.0.1.</span> <span class="nav-text">1. 与串行回收器相关的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-与并行GC相关的参数"><span class="nav-number">5.6.0.2.</span> <span class="nav-text">2. 与并行GC相关的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-与-CMS-回收-器-相关-的-参数（-JDK9、-JDK10-已经-开始-废弃-CMS-回收-器，-建议-使用-G1-回收-器）"><span class="nav-number">5.6.0.3.</span> <span class="nav-text">3. 与 CMS 回收 器 相关 的 参数（ JDK9、 JDK10 已经 开始 废弃 CMS 回收 器， 建议 使用 G1 回收 器）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-与-G1-回收-器-相关-的-参数"><span class="nav-number">5.6.0.3.1.</span> <span class="nav-text">4. 与 G1 回收 器 相关 的 参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-TLAB相关"><span class="nav-number">5.6.0.4.</span> <span class="nav-text">5. TLAB相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-其他参数"><span class="nav-number">5.6.0.5.</span> <span class="nav-text">6. 其他参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-动手才是真英雄"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 动手才是真英雄</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-1-配置实验环境"><span class="nav-number">5.7.1.</span> <span class="nav-text">5.7.1 配置实验环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-2-配置-性能-测试-工具-JMeter"><span class="nav-number">5.7.2.</span> <span class="nav-text">5.7.2 配置 性能 测试 工具 JMeter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-3-配置Web应用服务器Tomcat"><span class="nav-number">5.7.3.</span> <span class="nav-text">5.7.3 配置Web应用服务器Tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-4-实战-案例-1—-初试-串行-回收-器"><span class="nav-number">5.7.4.</span> <span class="nav-text">5.7.4 实战 案例 1— 初试 串行 回收 器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-5-实战-案例-2—-扩-大堆-以-提升-系统-性能"><span class="nav-number">5.7.5.</span> <span class="nav-text">5.7.5 实战 案例 2— 扩 大堆 以 提升 系统 性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-6-实战-案例-3—-调整-初始-堆-大小"><span class="nav-number">5.7.6.</span> <span class="nav-text">5.7.6 实战 案例 3— 调整 初始 堆 大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-7-实战-案例-4—-使用-ParrellOldGC-回收-器"><span class="nav-number">5.7.7.</span> <span class="nav-text">5.7.7 实战 案例 4— 使用 ParrellOldGC 回收 器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-8-实战-案例-5—-使用-较小-堆-提高-GC-压力"><span class="nav-number">5.7.8.</span> <span class="nav-text">5.7.8 实战 案例 5— 使用 较小 堆 提高 GC 压力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-9-实战-案例-6—-测试-ParallelOldGC-的-表现"><span class="nav-number">5.7.9.</span> <span class="nav-text">5.7.9 实战 案例 6— 测试 ParallelOldGC 的 表现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-10-实战-案例-7—-测试-ParNew-回收-器-的-表现"><span class="nav-number">5.7.10.</span> <span class="nav-text">5.7.10 实战 案例 7— 测试 ParNew 回收 器 的 表现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-11-实战-案例-8—-测试-JDK-1-8-的-表现"><span class="nav-number">5.7.11.</span> <span class="nav-text">5.7.11 实战 案例 8— 测试 JDK 1. 8 的 表现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-12-实战-案例-9—-使用-高-版本-虚拟-机-提升-性能"><span class="nav-number">5.7.12.</span> <span class="nav-text">5.7.12 实战 案例 9— 使用 高 版本 虚拟 机 提升 性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-性能监控工具"><span class="nav-number">6.</span> <span class="nav-text">第6章 性能监控工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-有我更高效-Linux下的性能监控工具"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 有我更高效:Linux下的性能监控工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-显示系统整体资源使用情况-top命令。"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 显示系统整体资源使用情况-top命令。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-监控内存和CPU-vmstat命令"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 监控内存和CPU-vmstat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-监控I-O-iostat命令"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 监控I&#x2F;O-iostat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-多功能诊断器——pidstat工具"><span class="nav-number">6.1.4.</span> <span class="nav-text">6.1.4 多功能诊断器——pidstat工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-CPU-使用-率-监控"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">1.CPU 使用 率 监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-I-O使用情况监控"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">2. I&#x2F;O使用情况监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-内存监控"><span class="nav-number">6.1.4.3.</span> <span class="nav-text">3.内存监控</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-用我更高效-Windows下的性能监控工具"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 用我更高效:Windows下的性能监控工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-任务管理器"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 任务管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-perfmon性能监控工具"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 perfmon性能监控工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-ProcessExplorer进行管理工具"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 ProcessExplorer进行管理工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-pslist工具——Windows下也有命令行工具"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.2.4 pslist工具——Windows下也有命令行工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-外科手术刀-JDK性能监控工具"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 外科手术刀: JDK性能监控工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-查看Java进程——jps命令"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 查看Java进程——jps命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-查看虚拟机运行时信息——jstat命令"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 查看虚拟机运行时信息——jstat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6。3-3-查看虚拟机参数——jinfo命令"><span class="nav-number">6.3.3.</span> <span class="nav-text">6。3.3 查看虚拟机参数——jinfo命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-导出堆到文件——jmap命令"><span class="nav-number">6.3.4.</span> <span class="nav-text">6.3.4 导出堆到文件——jmap命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5-JDK自带的堆分析工具——jhat命令"><span class="nav-number">6.3.5.</span> <span class="nav-text">6.3.5 JDK自带的堆分析工具——jhat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-查看线程对堆栈——jstack命令"><span class="nav-number">6.3.6.</span> <span class="nav-text">6.3.6 查看线程对堆栈——jstack命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-7-远程主机信息收集——jstatd命令"><span class="nav-number">6.3.7.</span> <span class="nav-text">6.3.7 远程主机信息收集——jstatd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-8-多功能命令行——jcmd命令"><span class="nav-number">6.3.8.</span> <span class="nav-text">6.3.8 多功能命令行——jcmd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-9-性能统计工具——hprof"><span class="nav-number">6.3.9.</span> <span class="nav-text">6.3.9 性能统计工具——hprof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-10-扩展jps命令"><span class="nav-number">6.3.10.</span> <span class="nav-text">6.3.10 扩展jps命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-你是我的眼-图形化虚拟机监控工具JConsole"><span class="nav-number">6.4.</span> <span class="nav-text">6.4  你是我的眼:图形化虚拟机监控工具JConsole</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-Jconsole连接Java程序"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 Jconsole连接Java程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-Java程序概况"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 Java程序概况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-内存监控"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3 内存监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-线程监控"><span class="nav-number">6.4.4.</span> <span class="nav-text">6.4.4 线程监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-类加载情况"><span class="nav-number">6.4.5.</span> <span class="nav-text">6.4.5 类加载情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-6-虚拟机信息"><span class="nav-number">6.4.6.</span> <span class="nav-text">6.4.6 虚拟机信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-一目了然-可视化性能监控工具Visual-VM"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 一目了然: 可视化性能监控工具Visual VM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-Visual-VM连接应用程序"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 Visual VM连接应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-监控应用程序"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 监控应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-Thread-Dump和分析"><span class="nav-number">6.5.3.</span> <span class="nav-text">6.5.3 Thread Dump和分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-性能分析"><span class="nav-number">6.5.4.</span> <span class="nav-text">6.5.4 性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5-内存快照分析"><span class="nav-number">6.5.5.</span> <span class="nav-text">6.5.5 内存快照分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-6-BTrace介绍"><span class="nav-number">6.5.6.</span> <span class="nav-text">6.5.6 BTrace介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-来自JRockit的礼物-虚拟机诊断工具"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 来自JRockit的礼物: 虚拟机诊断工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-MBean服务器"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.6.1 MBean服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-飞行记录器-Flight-Recorder"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.6.2 飞行记录器(Flight Recorder)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-分析Java堆"><span class="nav-number">7.</span> <span class="nav-text">第7章 分析Java堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-堆溢出"><span class="nav-number">7.0.1.</span> <span class="nav-text">7.1.1 堆溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-直接内存溢出"><span class="nav-number">7.0.2.</span> <span class="nav-text">7.1.2 直接内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-过多线程导致OOM"><span class="nav-number">7.0.3.</span> <span class="nav-text">7.1.3 过多线程导致OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-4-永久区溢出"><span class="nav-number">7.0.4.</span> <span class="nav-text">7.1.4 永久区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-5-GC效率低下引起的OOM"><span class="nav-number">7.0.5.</span> <span class="nav-text">7.1.5 GC效率低下引起的OOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-无处不在的字符串-String在虚拟机中的实现"><span class="nav-number">7.1.</span> <span class="nav-text">7.2 无处不在的字符串:String在虚拟机中的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-String对象的特点"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.2.1 String对象的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-不变性"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">1.不变性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-针对常量池的优化"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">2. 针对常量池的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类的定义"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">3.类的定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-有关String的内存泄露"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.2.2 有关String的内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-有关String常量池的位置"><span class="nav-number">7.1.3.</span> <span class="nav-text">7.2.3 有关String常量池的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-虚拟机也有内窥镜：使用MAT分析Java堆"><span class="nav-number">7.2.</span> <span class="nav-text">7.3 虚拟机也有内窥镜：使用MAT分析Java堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-初始MAT"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.3.1 初始MAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-浅堆和深堆"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.3.2 浅堆和深堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-MAT堆分析案例解析"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.3.3 MAT堆分析案例解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-支配树-Domainator-Tree"><span class="nav-number">7.2.4.</span> <span class="nav-text">7.3.4 支配树(Domainator Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-Tomcat堆溢出分析"><span class="nav-number">7.2.5.</span> <span class="nav-text">7.3.5 Tomcat堆溢出分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-筛选对对象-MAT对OQL的支持"><span class="nav-number">7.3.</span> <span class="nav-text">7.4 筛选对对象:MAT对OQL的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-SELECT子句"><span class="nav-number">7.3.1.</span> <span class="nav-text">7.4.1 SELECT子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-FROM子句"><span class="nav-number">7.3.2.</span> <span class="nav-text">7.4.2 FROM子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-Where子句"><span class="nav-number">7.3.3.</span> <span class="nav-text">7.4.3 Where子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-内置对象与方法"><span class="nav-number">7.3.4.</span> <span class="nav-text">7.4.4 内置对象与方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-更精彩的查找-Visual-VM对OQL的支持"><span class="nav-number">7.4.</span> <span class="nav-text">7.5 更精彩的查找: Visual VM对OQL的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-Visual-VM的OQL的基本语法"><span class="nav-number">7.4.1.</span> <span class="nav-text">7.5.1 Visual VM的OQL的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-内置heap对象"><span class="nav-number">7.4.2.</span> <span class="nav-text">7.5.2 内置heap对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-3-对象函数"><span class="nav-number">7.4.3.</span> <span class="nav-text">7.5.3 对象函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-classof-函数"><span class="nav-number">7.4.3.1.</span> <span class="nav-text">1.classof() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-objectid-函数"><span class="nav-number">7.4.3.2.</span> <span class="nav-text">2.objectid()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-reachables-函数"><span class="nav-number">7.4.3.3.</span> <span class="nav-text">3.reachables()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-referrers-函数"><span class="nav-number">7.4.3.4.</span> <span class="nav-text">4.referrers()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-referees-函数"><span class="nav-number">7.4.3.5.</span> <span class="nav-text">5.referees()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-sizeof-函数"><span class="nav-number">7.4.3.6.</span> <span class="nav-text">6.sizeof()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-rsizeof-函数"><span class="nav-number">7.4.3.7.</span> <span class="nav-text">7.rsizeof()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-toHtml-函数"><span class="nav-number">7.4.3.8.</span> <span class="nav-text">8.toHtml()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-4-集合-统计函数"><span class="nav-number">7.4.4.</span> <span class="nav-text">7.5.4 集合&#x2F;统计函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-5-程序化OSQL分析Tomcat堆"><span class="nav-number">7.4.5.</span> <span class="nav-text">7.5.5 程序化OSQL分析Tomcat堆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第8章-锁与并发"><span class="nav-number">8.</span> <span class="nav-text">第8章 锁与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-安全就是锁存在的理由-锁的基本概念和实现"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 安全就是锁存在的理由: 锁的基本概念和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-理解线程安全"><span class="nav-number">8.1.1.</span> <span class="nav-text">8.1.1 理解线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-对象头和锁"><span class="nav-number">8.1.2.</span> <span class="nav-text">8.1.2 对象头和锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-避免残酷的竞争-锁在Java虚拟机中的实现与优化"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 避免残酷的竞争: 锁在Java虚拟机中的实现与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-偏向锁"><span class="nav-number">8.2.1.</span> <span class="nav-text">8.2.1 偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-轻量级锁"><span class="nav-number">8.2.2.</span> <span class="nav-text">8.2.2 轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-锁膨胀"><span class="nav-number">8.2.3.</span> <span class="nav-text">8.2.3 锁膨胀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-自旋锁"><span class="nav-number">8.2.4.</span> <span class="nav-text">8.2.4 自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5-锁消除"><span class="nav-number">8.2.5.</span> <span class="nav-text">8.2.5 锁消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-应对残酷的竞争-锁在应用层的优化思路"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 应对残酷的竞争: 锁在应用层的优化思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-减少锁持有时间"><span class="nav-number">8.3.1.</span> <span class="nav-text">8.3.1 减少锁持有时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-减少锁粒度"><span class="nav-number">8.3.2.</span> <span class="nav-text">8.3.2 减少锁粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-锁分离"><span class="nav-number">8.3.3.</span> <span class="nav-text">8.3.3 锁分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-4-锁粗化"><span class="nav-number">8.3.4.</span> <span class="nav-text">8.3.4 锁粗化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-无招胜有招-无锁"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 无招胜有招: 无锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-理解CAS"><span class="nav-number">8.4.1.</span> <span class="nav-text">8.4.1 理解CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-原子操作"><span class="nav-number">8.4.2.</span> <span class="nav-text">8.4.2 原子操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-3-新宠儿LongAddr"><span class="nav-number">8.4.3.</span> <span class="nav-text">8.4.3 新宠儿LongAddr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-将随机变为可控-理解Java内存模型"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 将随机变为可控: 理解Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-原子性"><span class="nav-number">8.5.1.</span> <span class="nav-text">8.5.1 原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-2-有序性"><span class="nav-number">8.5.2.</span> <span class="nav-text">8.5.2 有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-3-可见性"><span class="nav-number">8.5.3.</span> <span class="nav-text">8.5.3 可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-4-Happens-Befor原则"><span class="nav-number">8.5.4.</span> <span class="nav-text">8.5.4 Happens-Befor原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第9章-Class文件结构"><span class="nav-number">9.</span> <span class="nav-text">第9章 Class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-不仅跨平台，还能跨语言-语言无关性"><span class="nav-number">9.1.</span> <span class="nav-text">9.1 不仅跨平台，还能跨语言: 语言无关性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-虚拟机的基石-Class文件"><span class="nav-number">9.2.</span> <span class="nav-text">9.2 虚拟机的基石:Class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-Class文件的标志——魔数"><span class="nav-number">9.2.1.</span> <span class="nav-text">9.2.1 Class文件的标志——魔数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-Class文件的版本"><span class="nav-number">9.2.2.</span> <span class="nav-text">9.2.2 Class文件的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-存放所有常数——常量池"><span class="nav-number">9.2.3.</span> <span class="nav-text">9.2.3 存放所有常数——常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-4-CLass的访问标记-Access-Flag"><span class="nav-number">9.2.4.</span> <span class="nav-text">9.2.4 CLass的访问标记(Access Flag)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-5-当前类、父类和接口"><span class="nav-number">9.2.5.</span> <span class="nav-text">9.2.5 当前类、父类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-6-Class文件的字段"><span class="nav-number">9.2.6.</span> <span class="nav-text">9.2.6 Class文件的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-7-Class文件的方法基本结构"><span class="nav-number">9.2.7.</span> <span class="nav-text">9.2.7 Class文件的方法基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-8-方法的执行主体——Code属性"><span class="nav-number">9.2.8.</span> <span class="nav-text">9.2.8 方法的执行主体——Code属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-9-记录行号——LineNumberTable属性"><span class="nav-number">9.2.9.</span> <span class="nav-text">9.2.9 记录行号——LineNumberTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-10-保存局部变量和参数——LocalVariableTable属性"><span class="nav-number">9.2.10.</span> <span class="nav-text">9.2.10 保存局部变量和参数——LocalVariableTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-11-加快字节码校验——StackMapTable属性"><span class="nav-number">9.2.11.</span> <span class="nav-text">9.2.11 加快字节码校验——StackMapTable属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-12-Code属性总结"><span class="nav-number">9.2.12.</span> <span class="nav-text">9.2.12 Code属性总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-13-抛出异常——Exceptions属性"><span class="nav-number">9.2.13.</span> <span class="nav-text">9.2.13 抛出异常——Exceptions属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-14-用实例分析Class的方法结构"><span class="nav-number">9.2.14.</span> <span class="nav-text">9.2.14 用实例分析Class的方法结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-15-我来自哪里——SourceFile属性"><span class="nav-number">9.2.15.</span> <span class="nav-text">9.2.15 我来自哪里——SourceFile属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-16-强大的动态调用——BootstrapMethods属性"><span class="nav-number">9.2.16.</span> <span class="nav-text">9.2.16 强大的动态调用——BootstrapMethods属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-17-内部类——InnerClasses属性"><span class="nav-number">9.2.17.</span> <span class="nav-text">9.2.17 内部类——InnerClasses属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-18-将要废弃的通知——Deprecated属性"><span class="nav-number">9.2.18.</span> <span class="nav-text">9.2.18 将要废弃的通知——Deprecated属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-操作字节码：走进ASM"><span class="nav-number">9.3.</span> <span class="nav-text">9.3 操作字节码：走进ASM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-ASM体系结构"><span class="nav-number">9.3.1.</span> <span class="nav-text">9.3.1 ASM体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-ASM之Hello-World"><span class="nav-number">9.3.2.</span> <span class="nav-text">9.3.2 ASM之Hello World</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第10章-Class装载系统"><span class="nav-number">10.</span> <span class="nav-text">第10章 Class装载系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-来去都有序-看懂Class文件的装载过程"><span class="nav-number">10.1.</span> <span class="nav-text">10.1 来去都有序: 看懂Class文件的装载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-1-类装载的条件"><span class="nav-number">10.1.1.</span> <span class="nav-text">10.1.1 类装载的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-2-加载类"><span class="nav-number">10.1.2.</span> <span class="nav-text">10.1.2 加载类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-3-验证类"><span class="nav-number">10.1.3.</span> <span class="nav-text">10.1.3 验证类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-4-准备"><span class="nav-number">10.1.4.</span> <span class="nav-text">10.1.4 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-5-解析类"><span class="nav-number">10.1.5.</span> <span class="nav-text">10.1.5 解析类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-6-初始化"><span class="nav-number">10.1.6.</span> <span class="nav-text">10.1.6 初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-一切Class从这里开始-掌握Classloader"><span class="nav-number">10.2.</span> <span class="nav-text">10.2 一切Class从这里开始: 掌握Classloader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-认识ClassLoader，看懂类加载"><span class="nav-number">10.2.1.</span> <span class="nav-text">10.2.1 认识ClassLoader，看懂类加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-ClassLoader的分类。"><span class="nav-number">10.2.2.</span> <span class="nav-text">10.2.2 ClassLoader的分类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-ClassLoader的双亲委派模式"><span class="nav-number">10.2.3.</span> <span class="nav-text">10.2.3 ClassLoader的双亲委派模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-双亲委派模式的弊端"><span class="nav-number">10.2.4.</span> <span class="nav-text">10.2.4 双亲委派模式的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-5-双亲委派模式的补充"><span class="nav-number">10.2.5.</span> <span class="nav-text">10.2.5 双亲委派模式的补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-6-突破双亲模式"><span class="nav-number">10.2.6.</span> <span class="nav-text">10.2.6 突破双亲模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-7-热替换的实现"><span class="nav-number">10.2.7.</span> <span class="nav-text">10.2.7 热替换的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第11章-字节码执行"><span class="nav-number">11.</span> <span class="nav-text">第11章 字节码执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-代码如何执行：字节码执行案例"><span class="nav-number">11.1.</span> <span class="nav-text">11.1 代码如何执行：字节码执行案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-执行的基础-Java虚拟机常用指令介绍"><span class="nav-number">11.2.</span> <span class="nav-text">11.2 执行的基础: Java虚拟机常用指令介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-常量入栈指令"><span class="nav-number">11.2.1.</span> <span class="nav-text">11.2.1 常量入栈指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-局部变量压栈指令"><span class="nav-number">11.2.2.</span> <span class="nav-text">11.2.2 局部变量压栈指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-出栈装入局部变量表指令"><span class="nav-number">11.2.3.</span> <span class="nav-text">11.2.3 出栈装入局部变量表指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-4-通用型操作"><span class="nav-number">11.2.4.</span> <span class="nav-text">11.2.4 通用型操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-5-类型转换指令"><span class="nav-number">11.2.5.</span> <span class="nav-text">11.2.5 类型转换指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-6-运算指令"><span class="nav-number">11.2.6.</span> <span class="nav-text">11.2.6 运算指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-7-对象操作指令"><span class="nav-number">11.2.7.</span> <span class="nav-text">11.2.7 对象操作指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建指令"><span class="nav-number">11.2.7.1.</span> <span class="nav-text">1.创建指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字段访问指令"><span class="nav-number">11.2.7.2.</span> <span class="nav-text">2. 字段访问指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类型检查指令"><span class="nav-number">11.2.7.3.</span> <span class="nav-text">3. 类型检查指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-数组操作指令"><span class="nav-number">11.2.7.4.</span> <span class="nav-text">4. 数组操作指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-8-比较控制指令"><span class="nav-number">11.2.8.</span> <span class="nav-text">11.2.8 比较控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-比较指令"><span class="nav-number">11.2.8.1.</span> <span class="nav-text">1.比较指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-条件跳转指令"><span class="nav-number">11.2.8.2.</span> <span class="nav-text">2. 条件跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-比较跳转指令"><span class="nav-number">11.2.8.3.</span> <span class="nav-text">3. 比较跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-多分支跳转指令"><span class="nav-number">11.2.8.4.</span> <span class="nav-text">4.  多分支跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-无条件跳转指令"><span class="nav-number">11.2.8.5.</span> <span class="nav-text">5.无条件跳转指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-9-函数调用与返回指令"><span class="nav-number">11.2.9.</span> <span class="nav-text">11.2.9 函数调用与返回指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-10-同步控制"><span class="nav-number">11.2.10.</span> <span class="nav-text">11.2.10 同步控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-11-再看Class的方法结构"><span class="nav-number">11.2.11.</span> <span class="nav-text">11.2.11 再看Class的方法结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-更上一层楼：再看ASM"><span class="nav-number">11.3.</span> <span class="nav-text">11.3 更上一层楼：再看ASM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-为类增加安全控制"><span class="nav-number">11.3.1.</span> <span class="nav-text">11.3.1 为类增加安全控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-统计函数执行时间"><span class="nav-number">11.3.2.</span> <span class="nav-text">11.3.2 统计函数执行时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-谁说Java太刻板-Java-Agent运行时修改类"><span class="nav-number">11.4.</span> <span class="nav-text">11.4 谁说Java太刻板: Java Agent运行时修改类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-1-使用-javaagent参数启动虚拟机"><span class="nav-number">11.4.1.</span> <span class="nav-text">11.4.1 使用-javaagent参数启动虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-2-使用Java-Agent为函数增加计时功能"><span class="nav-number">11.4.2.</span> <span class="nav-text">11.4.2 使用Java Agent为函数增加计时功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-3-动态重转换类"><span class="nav-number">11.4.3.</span> <span class="nav-text">11.4.3 动态重转换类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-4-有关Java-Agent的总结"><span class="nav-number">11.4.4.</span> <span class="nav-text">11.4.4 有关Java Agent的总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-与时俱进：动态方法调用"><span class="nav-number">11.5.</span> <span class="nav-text">11.5 与时俱进：动态方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-1-方法句柄使用实例"><span class="nav-number">11.5.1.</span> <span class="nav-text">11.5.1 方法句柄使用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-2-调用点使用实例"><span class="nav-number">11.5.2.</span> <span class="nav-text">11.5.2 调用点使用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-3-反射和方法句柄"><span class="nav-number">11.5.3.</span> <span class="nav-text">11.5.3 反射和方法句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-4-指令invokedynamic"><span class="nav-number">11.5.4.</span> <span class="nav-text">11.5.4 指令invokedynamic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-跑得再快点：静态编译优化"><span class="nav-number">11.6.</span> <span class="nav-text">11.6 跑得再快点：静态编译优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-7-提高虚拟机的执行效率-JIT及其相关参数"><span class="nav-number">11.7.</span> <span class="nav-text">11.7 提高虚拟机的执行效率:JIT及其相关参数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宋梓立 sorie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  









  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'XTY8e76465N8ugbyhpCoS88f-gzGzoHsz',
        appKey: 'dwWTNcurePtzzBdMO62hSRMy',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
