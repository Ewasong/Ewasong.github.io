<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,挑战," />










<meta name="description" content="第1章 蓄势待发——准备篇略 第2章 初出茅庐——初级篇2.1 最基础的“穷竭搜索”2.1.1 递归函数计算递推式 n! &#x3D; n * (n-1)! 1234567int fact(int n) &amp;#123;	if (n &#x3D;&#x3D; 0) &amp;#123;		return 1;	&amp;#125; else &amp;#123;		n * fact(n - 1);	&amp;#125;&amp;#125;  可以缓存结果 12345678">
<meta property="og:type" content="article">
<meta property="og:title" content="挑战程序设计竞赛笔记">
<meta property="og:url" content="http://yoursite.com/2020/06/15/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="宋二的小窝">
<meta property="og:description" content="第1章 蓄势待发——准备篇略 第2章 初出茅庐——初级篇2.1 最基础的“穷竭搜索”2.1.1 递归函数计算递推式 n! &#x3D; n * (n-1)! 1234567int fact(int n) &amp;#123;	if (n &#x3D;&#x3D; 0) &amp;#123;		return 1;	&amp;#125; else &amp;#123;		n * fact(n - 1);	&amp;#125;&amp;#125;  可以缓存结果 12345678">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f466b60160a154a67971adb.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f466d08160a154a6797cf0b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f466d32160a154a6797e35f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f466daf160a154a6798174a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47b9b6160a154a676c86d7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47bc8d160a154a676d716a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47be66160a154a676e1e7d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47bf11160a154a676e5872.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47bf35160a154a676e62a1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49e9ff160a154a67f85a7b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49fefb160a154a67fe9b4f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4a0621160a154a6700d71c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4a0745160a154a67012ed1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4a0848160a154a670175a0.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4a08b1160a154a670194f0.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4a090b160a154a6701b1e2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bae26160a154a6780c53f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4baf14160a154a67810726.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4baf95160a154a67812a53.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bafb7160a154a678136d4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bafe3160a154a67814486.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb002160a154a67814d60.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb018160a154a6781546b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb055160a154a678165d9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb0af160a154a67818383.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb0e3160a154a67819326.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb16e160a154a6781d073.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb17f160a154a6781db01.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb1a1160a154a6781f0dc.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb213160a154a67821974.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb336160a154a67826d9a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bb321160a154a67826815.jpg">
<meta property="article:published_time" content="2020-06-15T14:35:30.000Z">
<meta property="article:modified_time" content="2020-08-30T14:13:25.662Z">
<meta property="article:author" content="宋梓立 sorie">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="挑战">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/5f466b60160a154a67971adb.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/15/挑战程序设计竞赛笔记/"/>





  <title>挑战程序设计竞赛笔记 | 宋二的小窝</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Ewasong" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">宋二的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/15/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宋梓立 sorie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宋二的小窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">挑战程序设计竞赛笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-15T22:35:30+08:00">
                2020-06-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/15/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/15/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第1章-蓄势待发——准备篇"><a href="#第1章-蓄势待发——准备篇" class="headerlink" title="第1章 蓄势待发——准备篇"></a>第1章 蓄势待发——准备篇</h1><p>略</p>
<h1 id="第2章-初出茅庐——初级篇"><a href="#第2章-初出茅庐——初级篇" class="headerlink" title="第2章 初出茅庐——初级篇"></a>第2章 初出茅庐——初级篇</h1><h2 id="2-1-最基础的“穷竭搜索”"><a href="#2-1-最基础的“穷竭搜索”" class="headerlink" title="2.1 最基础的“穷竭搜索”"></a>2.1 最基础的“穷竭搜索”</h2><h3 id="2-1-1-递归函数"><a href="#2-1-1-递归函数" class="headerlink" title="2.1.1 递归函数"></a>2.1.1 递归函数</h3><p>计算递推式 n! = n * (n-1)!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n * fact(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以缓存结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> memo[MAX_N+<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (memo[n] != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> memo[n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> memo[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-栈"><a href="#2-1-2-栈" class="headerlink" title="2.1.2 栈"></a>2.1.2 栈</h3><p>java栈使用如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        stack.push(<span class="number">2</span>);  <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">        stack.push(<span class="number">3</span>);  <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">        System.out.println(stack.peek());   <span class="comment">//3</span></span><br><span class="line">        stack.pop();    <span class="comment">// &#123;1,2&#125;</span></span><br><span class="line">        System.out.println(stack.peek());   <span class="comment">// 2</span></span><br><span class="line">        stack.pop();    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        System.out.println(stack.peek());   <span class="comment">// 1</span></span><br><span class="line">        stack.pop();    <span class="comment">// &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-队列"><a href="#2-1-3-队列" class="headerlink" title="2.1.3 队列"></a>2.1.3 队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuqueUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">1</span>);  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        queue.offer(<span class="number">2</span>);  <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">        queue.offer(<span class="number">3</span>);  <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line">        System.out.println(queue.peek());   <span class="comment">//1</span></span><br><span class="line">        queue.poll();    <span class="comment">// &#123;2,3&#125;</span></span><br><span class="line">        System.out.println(queue.peek());   <span class="comment">// 2</span></span><br><span class="line">        queue.poll();    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        System.out.println(queue.peek());   <span class="comment">// 3</span></span><br><span class="line">        queue.poll();    <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-深度优先搜索"><a href="#2-1-4-深度优先搜索" class="headerlink" title="2.1.4 深度优先搜索"></a>2.1.4 深度优先搜索</h3><p>​    搜索手段之一。从某个状态开始，不断地转移状态直到无法转移，然后退到前一步的状态，不断重复，直到找到最终解。</p>
<p>​    通常实现的方式有递归和栈。</p>
<h3 id="2-1-5-宽度优先搜索"><a href="#2-1-5-宽度优先搜索" class="headerlink" title="2.1.5 宽度优先搜索"></a>2.1.5 宽度优先搜索</h3><p>​    总是先搜索距离初始状态近的状态。</p>
<p>​    实现方式使用队列。</p>
<p>​    很容哟用来秋最短路径、最少操作等答案。</p>
<h3 id="2-1-6-特殊状态枚举"><a href="#2-1-6-特殊状态枚举" class="headerlink" title="2.1.6 特殊状态枚举"></a>2.1.6 特殊状态枚举</h3><p>​    C++提供了next_permutation函数用于生成n个函数的不同的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">while</span>(next_permutation(perm2, perm2 + n));</span><br></pre></td></tr></table></figure>

<h3 id="2-1-7-剪枝"><a href="#2-1-7-剪枝" class="headerlink" title="2.1.7 剪枝"></a>2.1.7 剪枝</h3><p>​    搜索时，有时很早明确知道当前状态无论如何转移都不会存在解。这种情况下，不再继续搜索而是直接跳过，这一方法被称作剪枝。</p>
<h2 id="2-2-一往直前！-贪心法"><a href="#2-2-一往直前！-贪心法" class="headerlink" title="2.2 一往直前！ 贪心法"></a>2.2 一往直前！ 贪心法</h2><p>​    贪心法就是遵循某种规则，不断贪心地选取当前最优策略的算法设计方法。</p>
<h3 id="2-2-1-硬币问题"><a href="#2-2-1-硬币问题" class="headerlink" title="2.2.1 硬币问题"></a>2.2.1 硬币问题</h3><p>​    有1元，5元，10元，50元，100元，500元的硬币各C1,C5,C10,C50,C100,C500枚。现在要用这些硬币来支付A元，最少需要多少硬币。</p>
<p>​    思路：尽可能多地用面值更大的硬币即可。</p>
<h3 id="2-2-2-区间问题"><a href="#2-2-2-区间问题" class="headerlink" title="2.2.2 区间问题"></a>2.2.2 区间问题</h3><p>​    有n项工作，分别在si时间开始，在ti时间结束。对于每项工作，可以选择是否参加。如果参加就得全程参加。参与工作的时间段不能重叠，那么最多可以参加几项工作。</p>
<p>​    思路：在可选的工作中，每次都选取结束时间最早的工作。</p>
<h3 id="2-2-3-字典序最小问题"><a href="#2-2-3-字典序最小问题" class="headerlink" title="2.2.3 字典序最小问题"></a>2.2.3 字典序最小问题</h3><p>​    <strong>POJ 3617</strong></p>
<p>​    <a href="https://vjudge.net/problem/POJ-3617" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3617</a></p>
<pre><code>&gt; 给定长度N的字符串S，要构造一个长度为N的字符串T。起初，T是一个空串，虽有反复进行下列任意操作。
&gt;
&gt; * 从S头部删除一个字符，加到T的尾部
&gt; * 从S的尾部删除一个字符，加到T的尾部
&gt;
&gt; 目标是要构造字典序尽量小的的字符串T</code></pre><p>​    思路：</p>
<ul>
<li>按照字典序比较S和将S反转后的字符串S1</li>
<li>如果S较小。就从S的开头取出一个文字，追加到T的末尾</li>
<li>如果S较小，就从S的末尾取出一个文字，追加到T的末尾</li>
</ul>
<h3 id="2-2-4-其他例题"><a href="#2-2-4-其他例题" class="headerlink" title="2.2.4 其他例题"></a>2.2.4 其他例题</h3><p>​    <strong>POJ 3069</strong>    </p>
<p>​    <a href="https://vjudge.net/problem/POJ-3069" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3069</a></p>
<pre><code>&gt; 直线上有N个点。点i的位置是X[i]。从这N个点钟选择若干个，给它们加上标记。对于每一个点，其距离为R以内的区域必须带有标记的点。在满足这个条件的情况下，希望能为尽可能少的点添加标记。请问至少有多少点要被加上标记。</code></pre><p>​    思路：第一个点开始+R，然后找此范围中最右边的点X[i]，然后从X[i+1]开始不断重复该过程。</p>
<p>​    <strong>POJ 3253</strong></p>
<p>​        <a href="https://vjudge.net/problem/POJ-3253" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3253</a></p>
<pre><code>&gt; 农夫约翰为了修理栅栏，要讲一块很长的木板切割成N块。准备切成的模板的长度为L1、L2、...L[N], 未被切割的木板长度恰好为切割后木板长度的总和。每次切断木板时，需要的开销为这块模板的长度。请求出按目标要求将木板切割完最小的开销是多少？</code></pre><p>​    用二叉树的来模拟切割程序，开销合计就是各个叶子节点就可以这样计算：</p>
<p>​    木板长度 * 节点的深度。</p>
<p>​    最佳切割方法首先应该具有如下性质：</p>
<p>​    最短的板与次短的板的节点应当是兄弟节点。对于最优解来讲，最短的板应当是深度最大的叶子节点之一。</p>
<p>​    时间复杂度是O（N^2)，不过可以用O(NlogN)，在2.4节介绍</p>
<h3 id="专栏-Huffman编码"><a href="#专栏-Huffman编码" class="headerlink" title="专栏 Huffman编码"></a>专栏 Huffman编码</h3><p>​    <a href="https://www.cnblogs.com/kubixuesheng/p/4397798.html" target="_blank" rel="noopener">https://www.cnblogs.com/kubixuesheng/p/4397798.html</a></p>
<h2 id="2-3记录结果再利用的动态规划"><a href="#2-3记录结果再利用的动态规划" class="headerlink" title="2.3记录结果再利用的动态规划"></a>2.3记录结果再利用的动态规划</h2><h3 id="2-3-1-记忆化搜索与动态规划"><a href="#2-3-1-记忆化搜索与动态规划" class="headerlink" title="2.3.1 记忆化搜索与动态规划"></a>2.3.1 记忆化搜索与动态规划</h3><pre><code>&gt; 01背包问题 有n个重量和价值分别w[i],v[i]的物品。从这些武平中挑选出总重量不超过W的物品，求所有挑选方案中价值总和最大的值。</code></pre><p>朴素搜索算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="comment">// 从第i个物品开始挑选总重小于j的部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="comment">//已经没有物品了</span></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">       	<span class="comment">//无法挑选这个物品</span></span><br><span class="line">        res = rec(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//挑选和不挑选的两种情况都要尝试一下</span></span><br><span class="line">        res = <span class="built_in">max</span>(rec(i + <span class="number">1</span>, j), rec(i + <span class="number">1</span>, j - w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rec(<span class="number">0</span>, W));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索深度为n，每层搜索都有两个分支，最坏就需要O(2^n)的时间。</p>
<p>记忆化搜索算法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_W + <span class="number">1</span>]; <span class="comment">//记忆化数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第i个物品开始挑选总重小于j的部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="comment">//已经没有物品了</span></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">       	<span class="comment">//无法挑选这个物品</span></span><br><span class="line">        res = rec(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//挑选和不挑选的两种情况都要尝试一下</span></span><br><span class="line">        res = <span class="built_in">max</span>(rec(i + <span class="number">1</span>, j), rec(i + <span class="number">1</span>, j - w[i]) + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用-1表示尚未计算过，初始化整个数组</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rec(<span class="number">0</span>, W));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用memset进行初始化"><a href="#使用memset进行初始化" class="headerlink" title="使用memset进行初始化"></a>使用memset进行初始化</h4><p>​    虽然memset按照1字节单位对内存进行填充，但是-1的每一位进制为都是1，所以可以像0一样用memset进行初始化。注意无法初始化成1之类的数值。</p>
<p>不用递归的动态规划</p>
<p>递推式定义dp[i] [j] 为根据rec的定义，从第i个物品开始挑选总重小于j时，总价值的最大值。</p>
<p>$$<br>dp[n][j] = 0 \<br>\begin{equation}<br>d[i][j]=\left{<br>\begin{array}{lcl}<br>dp[i+1][j] &amp; &amp; {j &lt; w[i]}\<br>max(dp[i+1][j], dp[i+1][j-w[i]] + v[i]) &amp; &amp; {其他}\<br>\end{array} \right.<br>\end{equation}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_W + <span class="number">1</span>]; <span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[<span class="number">0</span>][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意不要忘记初始化</strong></p>
<h4 id="各种各样的dp"><a href="#各种各样的dp" class="headerlink" title="各种各样的dp"></a>各种各样的dp</h4><p>​    刚刚dp关于i的循环是逆向进行的。反之，如果按照如下的方式定义递推关系，就可以正向进行。</p>
<p>​    定义d[i+1] [j] := 从0到i这i+1个物品中挑选出总重量不超过j的物品时总价值的最大值</p>
<p>​<br>$$<br>dp[0][j] = 0 \<br>\begin{equation}<br>d[i+1][j]=\left{<br>\begin{array}{lcl}<br>dp[i][j] &amp; &amp; {j &lt; w[i]}\<br>max(dp[i][j], dp[i][j-w[i]] + v[i]) &amp; &amp; {其他}\<br>\end{array} \right.<br>\end{equation}<br>$$</p>
<p>​    代码略</p>
<p>​    </p>
<p>​    还可以想象成从”前i个物品中选取总重要不超过j的状态”向”前i+1个物品中选取总重要不超过j + w[i]的状态”转移。</p>
<blockquote>
<p>最长公共子序列问题 给定两个字符串s和t，长度分别为n和m，长度一样，秋出这两个字符串最长子序列。子序列不是连续子序列，注意一下。</p>
</blockquote>
<p>递推公式为</p>
<p>$$<br>dp[i][j] := s[1]…s[i]和t[1]…t[j]对应的LCS长度<br>\begin{equation}<br>dp[i+1][j+1]=\left{<br>\begin{array}{lcl}<br>max(dp[i][j] + 1, dp[i][j+1], d[i+1][j]) &amp; &amp; {s[i+1] = t[j+1]}\<br>max(dp[i][j+1], d[i+1][j]) &amp; &amp; {其他}\<br>\end{array} \right.<br>\end{equation}<br>$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稍微思考一下就发现当s[i+1]&#x3D;t[j+1]时，只需令dp[i+1][j+1]&#x3D;d[i][j] + 1 就可以了。</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-进一步探讨递推关系"><a href="#2-3-2-进一步探讨递推关系" class="headerlink" title="2.3.2 进一步探讨递推关系"></a>2.3.2 进一步探讨递推关系</h3><blockquote>
<p>完全背包问题 有n种重量为w[i]价值为v[i]的物品，从这些物品挑选总重量不超过W的物品，求出挑选物品价值总和的最大值。每样物品可以挑选任意多件。</p>
</blockquote>
<p>尝试写出递推关系</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i+1][j]:=从前i种物品中挑选出总重量不超过j的总价值的最大值。那么递推关系为:</span><br><span class="line">	dp[0][j]=0</span><br><span class="line">	dp[i+1][j] = max&#123;dp[i][j-k*w[i]] + k * v[i] | k &gt;= 0&#125;</span><br></pre></td></tr></table></figure>

<p>这样写出程序的循环成了三重循环，算法复杂度为O(nW^2)</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在dp[i+1][j]计算中选择k的情况，与在dp[i+1][j-w[i]]中选择k-1个的情况是相同的，所以dp[i+1][j]的递推块中k&gt;=1的部分已经在dp[i+1][j-w[i]]中完成了。那么可以按照如下形式进行变形</span><br><span class="line">dp[i+1][j] = max&#123;dp[i][j-k*w[i]] + k * v[i] | k &gt;= 0&#125;</span><br><span class="line">= max(dp[i][j], max&#123;dp[i][j-k*w[i]] + k * v[i] | k &gt;= 1&#125;)</span><br><span class="line">= max(dp[i][j], max&#123;dp[i][(j - w[i])-k*w[i]] + k * v[i] | k &gt;= 0&#125; + v[i])</span><br><span class="line">= max(dp[i][j], d[i+1][j-w[i]] + v[i])</span><br></pre></td></tr></table></figure>

<p>此外，此前提到的01背包问题因为只依赖于前一行以及前一列的数据，所以可以只用一个数组来重复利用实现。</p>
<p>01背包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAX_W+<span class="number">1</span>]; DP数组</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全背包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAX_W+<span class="number">1</span>]; DP数组</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= W; j--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">               dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>, dp[W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>01背包问题 限制条件变化 w[i] &lt;= 10^7, W &lt;= 10^9， 1&lt;= n &lt;= 100, 1&lt;= v[i] &lt;= 100</p>
</blockquote>
<p>​    之前求解的复杂度是O(nW),如果W很大，就不够用了。</p>
<p>​    调整一下dp策略即可</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i+1][j]:&#x3D; 前i个物品中挑出总价值为j的总重量最小值。</span><br><span class="line">初始条件</span><br><span class="line">dp[0][0] &#x3D; 0;</span><br><span class="line">dp[0][j] &#x3D; INF;</span><br><span class="line"></span><br><span class="line">dp[i+1][j] &#x3D; min(dp[i][j], dp[i][j-v[i]] + w[i]);</span><br><span class="line">复杂度是O(n*v[i]之和),这里是可以解出来的。 如果价值变大也可能不可行。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多重部分和问题</p>
</blockquote>
<p>略 //todo</p>
<blockquote>
<p>最长上升子序列问题</p>
</blockquote>
<p>略//todo</p>
<h3 id="2-3-3-有关计数问题的DP"><a href="#2-3-3-有关计数问题的DP" class="headerlink" title="2.3.3 有关计数问题的DP"></a>2.3.3 有关计数问题的DP</h3><blockquote>
<p>有n个无区别的物品，将它们划分成不超过m组，求出划分方法数模M的余数。</p>
</blockquote>
<p>这种划分被称作n的m划分，特别地，m=n时称作n的划分数。DP不仅对求解最优问题有效，对于各种排列组合的个数、概率或者期望之类的计算同样很有用。</p>
<p>定义如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =j的i划分总数</span><br><span class="line">有如下递推式</span><br><span class="line">dp[i][j] = dp[i-1][j-k]之和</span><br><span class="line">但是这个递推式不正确，1+1+2和1+2+1划分被当成不同的划分来计数了。</span><br><span class="line">考虑n的m划分a[i](a[i]=n(1~m)之和)，如果对于每个i都有a[i]&gt;0, 那么&#123;a[i] - 1&#125; 就对应了n-m的m划分。另外，如果存在a[i]=0,那么这就对应了n的m-1划分。</span><br><span class="line">dp[i][j] = dp[i][j-i] + dp[i-1][j]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>多重集组合数，有n个物品，第i种有a[i]个。不同种类的物品可以互相区分但相同种类的无法区分。从这些物品取出m个的话，有多少种取法。求出方案数模M的余数。</p>
</blockquote>
<p>​    </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line">dp[i+1][j] := 从前i种物品中取出j个的组合总数</span><br><span class="line">递推式为</span><br><span class="line">dp[i+1][j] = dp[i][j-k]之和(k=0~min(j,a[i]))</span><br><span class="line">这个递推式复杂度是O(nm^2)</span><br><span class="line">不过有</span><br><span class="line">dp[i][j-k]之和(k=0~min(j,a[i])) = dp[i][j-1-k]之和(k=0~min(j-1,a[i])) + dp[i][j] - dp[i][j-1-a[i]]</span><br><span class="line">所以</span><br><span class="line">dp[i+1][j] = dp[i+1][j-1] + dp[i][j] - dp[i][j-1-a[i]];</span><br></pre></td></tr></table></figure>

<h2 id="2-4-加工并存储数据的数据结构"><a href="#2-4-加工并存储数据的数据结构" class="headerlink" title="2.4 加工并存储数据的数据结构"></a>2.4 加工并存储数据的数据结构</h2><h3 id="2-4-1-树和二叉树"><a href="#2-4-1-树和二叉树" class="headerlink" title="2.4.1 树和二叉树"></a>2.4.1 树和二叉树</h3><p>略</p>
<h3 id="2-4-2-优先队列和堆"><a href="#2-4-2-优先队列和堆" class="headerlink" title="2.4.2 优先队列和堆"></a>2.4.2 优先队列和堆</h3><p>略</p>
<h3 id="2-4-3-二叉搜索树"><a href="#2-4-3-二叉搜索树" class="headerlink" title="2.4.3 二叉搜索树"></a>2.4.3 二叉搜索树</h3><p>略</p>
<h3 id="2-4-4-并查集"><a href="#2-4-4-并查集" class="headerlink" title="2.4.4 并查集"></a>2.4.4 并查集</h3><p><strong>1.并查集是什么</strong></p>
<p>​    并查集是用来管理分组情况的数据结构。并查集可以高效地进行如下操作。</p>
<ul>
<li>查询元素a和元素b是否属于同一组</li>
<li>合并元素a和元素b所在的组</li>
</ul>
<p><strong>2.并查集的结构</strong></p>
<p>​    并查集也是使用树形结构来实现的</p>
<p>（1）初始化</p>
<p>​    准备n个节点代表n个元素</p>
<p>（2）合并</p>
<p>​    从一个组的根向另外一个组的根两遍，这两两棵树就变成了一棵树，也就把两个组合并成一个组了</p>
<p>（3）查询</p>
<p>​    查询两个组是否属于同一组，沿着树往上走，查询包含这个元素的根是谁，如果是同一个根，那么就可以知道它们我是同一组。</p>
<p><strong>3.并查集实现中要注意的点</strong></p>
<p>​    需要注意退化的情况</p>
<ul>
<li>对于每棵树，记录这棵树的高度</li>
<li>合并时如果两棵树的rank不同，那么从rank小的向rankda的连边</li>
</ul>
<p>此外，通过路径压缩，可以使得并查集更加高效。对于每个节点，一旦向上走到一次根节点，就把这个点到父亲的边改为直接连向根。</p>
<p><strong>4.复杂度</strong></p>
<p>​    比O(log(n))还快</p>
<p><strong>5.并查集的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] par = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            par[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (par[x] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并x y的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">            par[x] = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            par[y] = x;</span><br><span class="line">            <span class="keyword">if</span> (rank[x] == rank[y]) &#123;</span><br><span class="line">                rank[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否同一集合</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.需要用到并查集的问题</strong></p>
<p>POJ1182 食物链</p>
<h2 id="2-5-它们其实都是“图”"><a href="#2-5-它们其实都是“图”" class="headerlink" title="2.5 它们其实都是“图”"></a>2.5 它们其实都是“图”</h2><h3 id="2-5-1-什么是图？"><a href="#2-5-1-什么是图？" class="headerlink" title="2.5.1 什么是图？"></a>2.5.1 什么是图？</h3><p>​    图由顶点和边组成。</p>
<p><strong>1.图的种类</strong></p>
<p>​    图大体分为2种。边没有指向性的图叫无向图，边具有指向性的图叫做有向图。</p>
<p><strong>2.无向图的术语</strong></p>
<p>​    两个顶点有边连接，视为两个顶点相邻。</p>
<p>​    相邻顶点的序列称为路径。</p>
<p>​    起点和终点重合的路径叫做圈。</p>
<p>​    任意两点之间都有路径的图叫连通图。</p>
<p>​    没有圈的连通图叫做树。</p>
<p>​    没有圈的非连通图叫做森林。</p>
<p>​    一棵树的边前好事顶点-1。</p>
<p>​    反之，边数等于顶点-1的连通图就是一棵树。</p>
<p><strong>3.有向图的术语</strong></p>
<p>​    以顶点v为起点的边的集合记作$\delta_+(v)$,以顶点v为终点的边的集合记作$\delta_-(v)$。</p>
<p>​    |$\delta_+(v)$|叫做v的出度，|$\delta_-(v)$|叫做v的入度。<br>​    没有圈的有向图叫DAG。</p>
<p>​    DAG可以按拓扑排序从左到右排序。通过这样的编号方式，有些DAG问题可以用DP来解决。</p>
<h3 id="2-5-2-图的表示"><a href="#2-5-2-图的表示" class="headerlink" title="2.5.2 图的表示"></a>2.5.2 图的表示</h3><p><strong>1.邻接矩阵</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g[i][j];</span><br></pre></td></tr></table></figure>

<p>带权图，值可以使权值。</p>
<p>如果不连通可以选择较大常数INF作为值。</p>
<p>此外，在带权图中，两点之间有重边或者自环，邻接矩阵可能有点问题（大部分情况下存最小权值或者最大权值就可以了)。</p>
<p>必须保存所有边可以用邻接表。</p>
<p><strong>2.邻接表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; G;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">List&lt;List&lt;Edge&gt;&gt; G;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-图的搜索"><a href="#2-5-3-图的搜索" class="headerlink" title="2.5.3 图的搜索"></a>2.5.3 图的搜索</h3><pre><code>&gt; 2分图，用两种颜色，相邻顶点不能是同一种颜色。</code></pre><p>​    以上面这种叫2分图。</p>
<h3 id="2-5-4-最短路问题"><a href="#2-5-4-最短路问题" class="headerlink" title="2.5.4 最短路问题"></a>2.5.4 最短路问题</h3><p><strong>单源最短路径(Bellman-Ford算法)</strong></p>
<p>​    $d[i] = min {d[j] + (从j到i边的权值)|e = (j,i) \in E }$</p>
<p>​    如果给定图是一个DAG，就可以按拓扑序给顶点编号，并利用这条递推关系计算出d。但是如果图中有圈，就无法依赖这样的顺序进行计算。在这种情况下，记当前顶点i的最短路径为d[i],并设值d[s]=0,d[i]=INF(足够大的常数), 在不断使用这条递推关系式更新d的值，就可以推算出新的d。只要图中不存在负圈，这样的更新操作就是有限的。结束只有d就是所求的最短距离了。</p>
<p>​    如果途中不存在s可达的负圈，那么最短路不会经过同一个顶点两次(也就是说，通过|V|-1条边), while(true)最多执行|V|-1次，因此，如果复杂度是O(|V|*E)</p>
<p>​    可以用这个性质来检查负圈，把所有顶点d[i]初始化为0，就可以检查出所有的负圈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge edges[] = <span class="keyword">new</span> Edge[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">//到起点的最短距离</span></span><br><span class="line">    <span class="keyword">int</span> d[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> V, E; <span class="comment">//V是起点数，E是边数。</span></span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(d, <span class="number">0</span>, V, INF);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> updateFlag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">                Edge e = edges[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[e.from] + e.cost;</span><br><span class="line">                    updateFlag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!updateFlag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">findNegativeLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(d, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</span><br><span class="line">                Edge e = edges[j];</span><br><span class="line">                <span class="keyword">if</span> (d[e.to] &gt; d[e.from] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[e.from] + e.cost;</span><br><span class="line">                    <span class="keyword">if</span> (i == V - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.单源最短路径2（Dijkstra算法）</strong></p>
<p>​    考虑没有负边的情况。</p>
<pre><code>1. 找到最短距离已经确定的顶点，从它触发更新相邻顶点的最短距离。
 2. 此后不需要关系1中的“最短距离已经确定的顶点”</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> challenge.commmon.CommonStatic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> cost[][] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V][MAX_V];   <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> d[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];   <span class="comment">//最短距离</span></span><br><span class="line">    <span class="keyword">boolean</span> used[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_V];    <span class="comment">//已经使用过的顶点</span></span><br><span class="line">    <span class="keyword">int</span> V;  <span class="comment">//顶点数</span></span><br><span class="line">    <span class="comment">//求最短路径</span></span><br><span class="line">    <span class="comment">//O(|V|^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(d, CommonStatic.INF);</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[u] &amp;&amp; (v == -<span class="number">1</span> || d[u] &lt; d[v])) &#123;</span><br><span class="line">                    u = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[v] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">                d[u] = Math.min(d[u], d[v] + cost[v][u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用邻接矩阵的Dijkstra算法的复杂度是O(|V|^2)，使用邻接表也是类似。</p>
<p>​    不过大部分时间花在了查找下一个使用的顶点上，因此需要使PriorityQueue对其进行优化。</p>
<p>​    元素有O(|V|)个，更新和去除数值的操作有O(|E|)次，因此整个算法的复杂度是O(|E|log(|V|))</p>
<p>​    下图的算法同时求出了最短的具体路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> challenge.commmon.CommonStatic;</span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    List&lt;Edge&gt; G[] = <span class="keyword">new</span> ArrayList[MAX_V];</span><br><span class="line">    <span class="keyword">int</span> d[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="keyword">int</span> pre[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="comment">//复杂度 O(|E|log|V|)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//key是路径长度，val是顶点</span></span><br><span class="line">        PriorityQueue&lt;Pair&lt;Integer,Integer&gt;&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> Comparator&lt;Pair&lt;Integer,Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair&lt;Integer,Integer&gt; o1, Pair&lt;Integer,Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> o1.getKey() - o2.getKey();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Arrays.fill(d, CommonStatic.INF);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        que.offer(<span class="keyword">new</span> Pair&lt;&gt;(<span class="number">0</span>, s));</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Pair&lt;Integer, Integer&gt; p = que.poll();</span><br><span class="line">            <span class="keyword">int</span> v = p.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d[v] &lt; p.getKey()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">                Edge e = G[v].get(i);</span><br><span class="line">                <span class="keyword">if</span> (d[e.to] &gt; d[v] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[v] + e.cost;</span><br><span class="line">                    pre[e.to] = v;</span><br><span class="line">                    que.offer(<span class="keyword">new</span> Pair&lt;&gt;(d[e.to], e.to));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (; t != -<span class="number">1</span>; t = pre[t]) path.add(t);</span><br><span class="line">        Collections.reverse(path);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 任意两点间的最短路问题（Floyd-warshall算法）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydWarshall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> d[][] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V][MAX_V];</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    <span class="comment">//复杂度O(|V|^3)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">warshallFloyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d[i][k] + d[k][j] &lt; d[i][j]) d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>4.路径还原</strong></p>
<p>​    记录前驱即可。</p>
<p>​    参考第2点的最后部分代码。</p>
<h3 id="2-5-5-最小生成树"><a href="#2-5-5-最小生成树" class="headerlink" title="2.5.5  最小生成树"></a>2.5.5  最小生成树</h3><p>​    给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫生成树。</p>
<p>​    如果边上有权值，那么使得壁安全和最小的生成树叫做最小生成树。</p>
<p>​    <strong>1. 最小生成树问题1（Prim算法）</strong></p>
<p>​    和Dijkstra算法十分相似，都是从某个顶点触发，不断添加边的算法。</p>
<p>​    假设只包含一个顶点的树T。然后贪心地选取T和其他顶点之间相连的最小权值的边，并把它加到T中。</p>
<p>​    如果每次遍历未包含在X中的点mincost(v),需要O(|V|^2)的时间。如果用堆来维护minCost时间复杂度就是O(|E|log|V|)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> challenge.commmon.CommonStatic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> cost[][] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V][MAX_V];</span><br><span class="line">    <span class="keyword">int</span> mincost[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="keyword">boolean</span> used[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_V];</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(mincost, CommonStatic.INF);</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">        mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[u] &amp;&amp; (v == -<span class="number">1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            used[v] = <span class="keyword">true</span>;</span><br><span class="line">            res += mincost[v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u ++) &#123;</span><br><span class="line">                mincost[u] = Math.min(mincost[u], cost[v][u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                            </p>
<p>优先队列实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> challenge.commmon.CommonStatic;</span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 不太确定写得对不对</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prime2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    List&lt;Edge&gt; G[] = <span class="keyword">new</span> ArrayList[MAX_V];</span><br><span class="line">    <span class="keyword">int</span> mincost[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="keyword">boolean</span> used[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_V];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prime2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(mincost, CommonStatic.INF);</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">        mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Pair&lt;Integer,Integer&gt;&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> Comparator&lt;Pair&lt;Integer,Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair&lt;Integer,Integer&gt; o1, Pair&lt;Integer,Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> o1.getKey() - o2.getKey();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G[<span class="number">0</span>]) &#123;</span><br><span class="line">            que.offer(<span class="keyword">new</span> Pair&lt;&gt;(e.to, e.cost));</span><br><span class="line">            mincost[e.to] = e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Pair&lt;Integer, Integer&gt; p = que.poll();</span><br><span class="line">            used[p.getKey()] = <span class="keyword">true</span>;</span><br><span class="line">            res += mincost[p.getKey()];</span><br><span class="line">            <span class="keyword">for</span> (Edge e: G[p.getKey()]) &#123;</span><br><span class="line">                mincost[e.to] = Math.min(mincost[e.to], e.cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.最小生成树问题2(Kruskal算法）</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p>
<p>​    Kruskal算法按照边的权值顺序从小到大看一遍，如果不产生圈(重边等也算在内)，就把当前这条边加入到生成树中。</p>
<p>​    算法复杂度是O(|E|log|V|)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span>, MAX_E = <span class="number">1000</span>;</span><br><span class="line">    List&lt;Edge&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(edges, <span class="keyword">new</span> Comparator&lt;Edge&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.cost - o2.cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        initUnion(V);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!same(e.from, e.to)) &#123;</span><br><span class="line">                unite(e.from, e.to);</span><br><span class="line">                res += e.cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> par[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="keyword">int</span> rank[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_V];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initUnion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            par[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (par[x] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        par[x] = find(par[x]);</span><br><span class="line">        <span class="keyword">return</span> par[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x);</span><br><span class="line">        <span class="keyword">int</span> py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px == py) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rank[py] &lt; rank[px]) &#123;</span><br><span class="line">            par[py] = px;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            par[px] = py;</span><br><span class="line">            <span class="keyword">if</span> (rank[py] == rank[px]) &#123;</span><br><span class="line">                rank[py]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-6-应用问题"><a href="#2-5-6-应用问题" class="headerlink" title="2.5.6 应用问题"></a>2.5.6 应用问题</h3><p>//todo 暂略，后面有空做</p>
<p><strong>POJ 3255</strong></p>
<p><strong>POJ 3723</strong></p>
<p><strong>POJ 3169</strong></p>
<h1 id="2-6-数学问题的解题窍门"><a href="#2-6-数学问题的解题窍门" class="headerlink" title="2.6 数学问题的解题窍门"></a>2.6 数学问题的解题窍门</h1><h3 id="2-6-1-辗转相除法"><a href="#2-6-1-辗转相除法" class="headerlink" title="2.6.1 辗转相除法"></a>2.6.1 辗转相除法</h3><p><strong>1.求最大公约数</strong></p>
<blockquote>
<p>线段上格点（横坐标和纵坐标都是整数的点）的个数。</p>
<p>给定两个平面两个格点P1(x1, y1)和P2(x2, y2)线段上，一共有几个格点。</p>
</blockquote>
<p>这道题的答案其实是最大公约数-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gcd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a % b == <span class="number">0</span> ? b : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.复杂度</strong></p>
<p>​    复杂度在O(log(max(a,b)))以内。</p>
<p><strong>3.扩展欧几里得算法</strong></p>
<p>​    求解ax + by = gcd(a, b)</p>
<p>​    需要扩展上面的辗转相除法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exgcd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = a;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            d = exgcd(b, a % b);</span><br><span class="line">            y -= (a / b) * x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-有关素数的基础算法"><a href="#2-6-2-有关素数的基础算法" class="headerlink" title="2.6.2 有关素数的基础算法"></a>2.6.2 有关素数的基础算法</h3><p><strong>1.素数测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//素数测试 O(sqrt(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//约数枚举 O(sqrt(n))</span></span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">divisor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">                <span class="keyword">if</span> (i != n / i) res.add(n / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数分解 O(sqrt(n))</span></span><br><span class="line">    <span class="function">Map&lt;Integer, Integer&gt; <span class="title">primeFactor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(i)) map.put(i, <span class="number">0</span>);</span><br><span class="line">                map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>) map.put(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.埃氏筛法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeSieve</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 埃氏筛法  O(sqrt(n))</span></span><br><span class="line">    <span class="keyword">int</span> prime[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">boolean</span> isPrime[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回n以内素数个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(isPrime, <span class="keyword">true</span>);</span><br><span class="line">        isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                prime[p++] = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j+= i) isPrime[j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.区间筛法</strong></p>
<p>求解[a,b)区间中素数个数</p>
<p>a &lt; b &lt;= 10 ^12</p>
<p>b - a &lt;= 10 ^ 6</p>
<p>b以内的合数的的最大质因数一定不超过sqrt(b)。有sqrt(b)以内的素数表，就可以把筛法运用在[a,b)上了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentPrimeSieve</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isPrim[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">boolean</span> isPrimeSmall[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求[a,b)以内素数个数</span></span><br><span class="line">    <span class="comment">// isPrime[i - a] = true =&gt; i是素数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">segementSieve</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  (<span class="keyword">long</span>)i * i &lt; b; i++) isPrimeSmall[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b - a; i++) isPrim[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; (<span class="keyword">long</span>)i * i &lt; b; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimeSmall[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; (<span class="keyword">long</span>) j * j &lt; b; j += i) isPrimeSmall[j] = <span class="keyword">false</span>; <span class="comment">//筛 [2, srqt(b))</span></span><br><span class="line">                <span class="comment">//筛[a,b)</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> j = Math.max(<span class="number">2L</span>, (a + i -<span class="number">1</span>) / i) * i; j &lt; b; j += b) isPrim[(<span class="keyword">int</span>)(j-a)] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-3-模运算"><a href="#2-6-3-模运算" class="headerlink" title="2.6.3 模运算"></a>2.6.3 模运算</h3><p><strong>1.为什么需要求余数</strong></p>
<p>​    超出64位整数范围</p>
<p><strong>2.基本模运算</strong></p>
<p>假设 $a \equiv c (mod ;m) 且b \equiv d (mod ; m)$</p>
<p>$a+b \equiv (c+d)(mod;m)$</p>
<p>$a-b \equiv (c-d)(mod;m)$</p>
<p>$a<em>b \equiv (c</em>d)(mod;m)$</p>
<p>$a/b \equiv (c/d)(mod;m)$</p>
<p>注意事项：</p>
<ul>
<li>溢出</li>
<li>被除数为负数</li>
</ul>
<h3 id="2-6-4-快速幂运算"><a href="#2-6-4-快速幂运算" class="headerlink" title="2.6.4 快速幂运算"></a>2.6.4 快速幂运算</h3><p>​    时间复杂度O(logn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> challenge.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModPow</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">modPow</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">modPow2</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = modPow2(x * x % mod, n / <span class="number">2</span>, mod);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-一起来挑战GCJ的题目-1"><a href="#2-7-一起来挑战GCJ的题目-1" class="headerlink" title="2.7 一起来挑战GCJ的题目(1)"></a>2.7 一起来挑战GCJ的题目(1)</h2><p>//todo</p>
<h1 id="第3章-出类拔萃——中级篇"><a href="#第3章-出类拔萃——中级篇" class="headerlink" title="第3章 出类拔萃——中级篇"></a>第3章 出类拔萃——中级篇</h1><h2 id="3-1-不光是查找值！“二分搜索”"><a href="#3-1-不光是查找值！“二分搜索”" class="headerlink" title="3.1 不光是查找值！“二分搜索”"></a>3.1 不光是查找值！“二分搜索”</h2><h3 id="3-1-1-从有序数组中查找某个值"><a href="#3-1-1-从有序数组中查找某个值" class="headerlink" title="3.1.1 从有序数组中查找某个值"></a>3.1.1 从有序数组中查找某个值</h3><p>略</p>
<h3 id="3-1-2-假定一个解判断是否可行"><a href="#3-1-2-假定一个解判断是否可行" class="headerlink" title="3.1.2 假定一个解判断是否可行"></a>3.1.2 假定一个解判断是否可行</h3><blockquote>
<p>POJ 1064 有N条绳子，它们的长度分别为L[i]。如果从它们中切割出K条长度相同的绳子的话，这K条绳子每条最长能有多长。答案保留到小数点后两位。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int N, K;</span><br><span class="line">double L[MAX_N];</span><br><span class="line">double C(double x) &#123;</span><br><span class="line">	int num &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">		num +&#x3D; (int) (L[i] &#x2F; x);</span><br><span class="line">	&#125;</span><br><span class="line">	return num &gt;&#x3D; K;</span><br><span class="line">&#125;</span><br><span class="line">void solve() &#123;</span><br><span class="line">	double lb &#x3D; 0, ub &#x3D; INF;</span><br><span class="line">	&#x2F;&#x2F;不断循环，直到解足够小</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">		double mid &#x3D; (lb + ub) &#x2F; 2;</span><br><span class="line">		if (C(mid)) lb &#x3D; mid;</span><br><span class="line">		else ub &#x3D; mid;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.2f\n&quot;, floor(ub * 100) &#x2F; 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>专栏 二分搜索结束的判定</strong></p>
<blockquote>
<p>在输出小数问题中，一般都会制定允许的误差范围或者是制定输出中小数点后面的位数。因此在使用二分搜索法时，有必要设置合理的结束条件来满足经度要求。在上面的程序中，指定了循环次数来作为终止条件。1次循环可以把范围缩小一半，100次可以到达10^-30的精度范围，基本是没有问题的。除此之外，也可以把终止条件设置成像(ub-lb) &gt; EPS这样，指定一个区间的大小。在这种情况下，如果EPS取的太小了，就有可能会因为浮点小数的经度的原因导致陷入死循环。</p>
</blockquote>
<h3 id="3-1-3-最大化最小值"><a href="#3-1-3-最大化最小值" class="headerlink" title="3.1.3  最大化最小值"></a>3.1.3  最大化最小值</h3><blockquote>
<p> POJ 2456     N间牛舍，在一条线上，第i号牛舍在X[i]的位置。但是他的M头牛对小屋很不满。为了防止牛之间相互伤害，决定把每头牛都放在离其他牛舍尽可能远的牛舍。也就是要最大化最近两头牛之间的距离。</p>
</blockquote>
<p>​    定义C(d):= 可以安排牛的位置使得最近的两头牛距离不小于d</p>
<p>​    问题就变成了求满足C(d)的最大值。最近的间距不小于d也可以说成所有牛的间距不小于d，因此就有：</p>
<p>​        C(d)=可以安排牛的位置使得任意牛的间距都不小于d</p>
<ul>
<li>对牛舍位置进行排序</li>
<li>把第一头牛放入x[0]</li>
<li>如果第i头牛放入了x[j]的话，第i+1头牛就要放入满足x[j]+d&lt;=x[k]的最小的x[k]中</li>
</ul>
<p>代码略</p>
<h3 id="3-1-4-最大化平均值"><a href="#3-1-4-最大化平均值" class="headerlink" title="3.1.4 最大化平均值"></a>3.1.4 最大化平均值</h3><blockquote>
<p>最大化平均值 有n个物品的重量和价值分别是w[i]和v[i]。从中选出k个物品使得单位重量的价值最大。</p>
<p>限制条件</p>
<p>1 &lt;= k &lt;= n &lt;= 10^4</p>
<p>1 &lt;= w[i],v[i] &lt;= 10^6</p>
</blockquote>
<p>​    条件C(x):=可以选择使得单位重量的价值不小于x</p>
<p>​    sum(v[i]) /sum(w[i]) &gt;= x</p>
<p>​    把这个不等式进行变形就得到</p>
<p>​    sum(v[i] - x*w[i]) &gt;= 0</p>
<p>​    因此可以对v[i] - x*w[i]的值进行排序贪心的选取。因此就变成了</p>
<p>​    C(x) = (v[i]-x*w[i])从大到小排列中前k个的和不小于0</p>
<p>​    每次判断的复杂度是O(nlogn)</p>
<h2 id="3-2-常用技巧精选（一）"><a href="#3-2-常用技巧精选（一）" class="headerlink" title="3.2 常用技巧精选（一）"></a>3.2 常用技巧精选（一）</h2><h3 id="3-2-1-尺取法"><a href="#3-2-1-尺取法" class="headerlink" title="3.2.1 尺取法"></a>3.2.1 尺取法</h3><p>略</p>
<h3 id="3-2-2-反转-开关问题"><a href="#3-2-2-反转-开关问题" class="headerlink" title="3.2.2 反转(开关问题)"></a>3.2.2 反转(开关问题)</h3><blockquote>
<p>POJ 3276 N头牛排成一列。每头牛或者向前或者向后。为了让所有牛都面向前方，农夫约翰买了一台自动转向机器。这个机器在购买时就必须设置一个K值，每次连续K头牛转向，为了让所有牛都面向前方最少操作数M和对应的最小K值。</p>
</blockquote>
<p>遍历0-N的K，然后验证可以符合的K，然后取答案</p>
<blockquote>
<p>POJ 3279 略</p>
</blockquote>
<p><strong>专栏 集合的整数表示</strong></p>
<p>​    元素较少，可以用二进制表示</p>
<p>​    空集：0</p>
<p>​    只有第i个元素的集合{i}:1&lt;&lt;i</p>
<p>​    含有全部n个元素的集合{0,1,…,n-1}: (1&lt;&lt;n) - 1</p>
<p>​    判断第i个元素是否属于集合S：if (S&gt;&gt; i &amp; 1)</p>
<p>​    向集合中加入第i个元素S ∪ {i}:    S|1&lt;&lt;i</p>
<p>​    从集合中去掉元素i: S &amp; ~(1&lt;&lt;i)</p>
<p>​    并集：S|T</p>
<p>​    交集：S&amp;T</p>
<p>​    枚举sup的子集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sub &#x3D; sup</span><br><span class="line">od &#123;</span><br><span class="line">	&#x2F;&#x2F;对子集的处理</span><br><span class="line">	sub &#x3D; (sub - 1) &amp; sup</span><br><span class="line">&#125;while(sub !&#x3D; sup)</span><br></pre></td></tr></table></figure>



<p>枚举集合{0,1,…,n-1}所包含的所有大小为k的子集的方法。</p>
<p>这里搞得不是很懂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int comb &#x3D; (1 &lt;&lt; k) - 1</span><br><span class="line"></span><br><span class="line">while (comb &lt; 1 &lt;&lt; n) &#123;</span><br><span class="line">	&#x2F;&#x2F;对于非零整数，x&amp;-x就是将其最低的位的1独立出来的值</span><br><span class="line">	int x &#x3D; comb &amp; -comb, y &#x3D; comb + x;</span><br><span class="line">	comb &#x3D; ((comb &amp; ~y) &#x2F; x &gt;&gt; 1) | y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-弹性碰撞"><a href="#3-2-3-弹性碰撞" class="headerlink" title="3.2.3 弹性碰撞"></a>3.2.3 弹性碰撞</h3><p>可以视为穿过</p>
<h3 id="3-2-4-折半搜索（双向搜索）"><a href="#3-2-4-折半搜索（双向搜索）" class="headerlink" title="3.2.4 折半搜索（双向搜索）"></a>3.2.4 折半搜索（双向搜索）</h3><blockquote>
<p>POJ 2785 给定各有n个整数的四个数列A,B,C,D。要从数列中各取出1个数，使得四个数的和为0.求出这样组合的个数。当一个数中有多个相同的数字时，把它们作为不同的数字看。</p>
</blockquote>
<p>​    先从AB中取出a、b，为使得总和为0，先将C、D中取数字的n^2方法全部枚举出来，将这些和排好序，就可以进行二分搜索了。有时候无法枚举所有的元素，只能枚举一半元素的组合。将它们拆分成两半后分别进行搜索，结果往往非常有效。</p>
<p>​    &gt; 超大背包问题(第二章介绍过了), 但是n&lt;=40, W,V &lt;= 10^15</p>
<p>DP求解是O(nW)</p>
<p>分一半进行枚举</p>
<h3 id="3-2-5-坐标离散化"><a href="#3-2-5-坐标离散化" class="headerlink" title="3.2.5 坐标离散化"></a>3.2.5 坐标离散化</h3><blockquote>
<p>区域的个数 w*h的格子画了n条水平或者垂直的宽度为1的直线。求出这些线将格子划分成了多少个区域</p>
<p>w和h比较大， n &lt;= 500</p>
</blockquote>
<p>搜索不了，用坐标离散化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">int</span> W,H,N;</span><br><span class="line"><span class="keyword">int</span> X1[MAX_N],X2[MAX_N],Y1[MAX_N],Y2[MAX_N];</span><br><span class="line"><span class="comment">//填充用</span></span><br><span class="line"><span class="keyword">bool</span> fld[MAX_N * <span class="number">6</span>][MAX_N*<span class="number">6</span>];</span><br><span class="line"><span class="comment">//对x1和x2进行坐标离散化，big返回离散化后的宽度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> *x1, <span class="keyword">int</span> *x2, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">-1</span>; d &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx1 = x1[i] + d, tx2 = x2[i] + d;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= tx1 &amp;&amp; tx1 &lt;= w) xs.push_back(tx1);</span><br><span class="line">           	<span class="keyword">if</span> (<span class="number">1</span> &lt;= tx2 &amp;&amp; tx2 &lt;= w) xs.push_back(tx2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>());</span><br><span class="line">    xs.erase(unique(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>), xs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        x1[i] = <span class="built_in">find</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>(), x1[i]) - xs.<span class="built_in">begin</span>();</span><br><span class="line">        x2[i] = <span class="built_in">find</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>(), x2[i]) - xs.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//坐标离散化</span></span><br><span class="line">    W = compress(X1, X2, W);</span><br><span class="line">    H = compress(Y1, Y2, H);</span><br><span class="line">   	<span class="comment">//填充有直线的部分</span></span><br><span class="line">    <span class="built_in">memset</span>(fld, <span class="number">0</span>, <span class="keyword">sizeof</span> fld);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = Y1[i]; y &lt;= Y2[i]; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = X1[i]; x &lt;= X2[i]; x++) &#123;</span><br><span class="line">                fld[y][x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽度优先搜索 代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-活用各种数据结构"><a href="#3-3-活用各种数据结构" class="headerlink" title="3.3 活用各种数据结构"></a>3.3 活用各种数据结构</h2><h3 id="3-3-1-线段树"><a href="#3-3-1-线段树" class="headerlink" title="3.3.1 线段树"></a>3.3.1 线段树</h3><h4 id="1-线段树的概念"><a href="#1-线段树的概念" class="headerlink" title="1.线段树的概念"></a>1.线段树的概念</h4><p>​    线段树擅长处理区间，是形如下图的数据结构。</p>
<p>​    是一颗完美二叉树(所有的叶子深度都相同，一个节点要么是叶子，要么有两个儿子)。</p>
<p>​    根维护整个区间，每个节点维护父亲区间的二等分后的一个子区间。</p>
<p>​    对区间的操作都可以在O(log n)的时间内完成。</p>
<p><img src="https://pic.imgdb.cn/item/5f466b60160a154a67971adb.jpg" alt=""></p>
<h4 id="2-基于线段树的RMQ结构"><a href="#2-基于线段树的RMQ结构" class="headerlink" title="2.基于线段树的RMQ结构"></a>2.基于线段树的RMQ结构</h4><p>​    下面要简历线段树在给定数列a0到a(n-1)的情况下，可以O(log n)时间内完成如下两种操作</p>
<ul>
<li>给定s和t，求a[s]到a[t]的最小值</li>
<li>给定i和x，把a[i]的值改成x</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/5f466d08160a154a6797cf0b.jpg" alt=""></p>
<h4 id="3-基于线段树的RMQ的查询"><a href="#3-基于线段树的RMQ的查询" class="headerlink" title="3.基于线段树的RMQ的查询"></a>3.基于线段树的RMQ的查询</h4><p>​    要求a[0]到a[6]的最小值，只需要求三个阶段的最小值即可。</p>
<p><img src="https://pic.imgdb.cn/item/5f466d32160a154a6797e35f.jpg" alt=""></p>
<p>​    按递归处理即可：</p>
<ul>
<li>如果所查询区间和当前节点对应的区间完全没有交集，那么就返回一个不影响答案的值(例如INT_MAX)。</li>
<li>如果所查询的区间完全包含了当前节点对应的区间，那么就返回当前节点的值。</li>
<li>以上两种情况都不满足的话，就对两个儿子递归处理，返回较小者。</li>
</ul>
<h4 id="4-基于线段树RMQ的值的更新"><a href="#4-基于线段树RMQ的值的更新" class="headerlink" title="4.基于线段树RMQ的值的更新"></a>4.基于线段树RMQ的值的更新</h4><p>​    更新a[0]，需要重新计算下图所示的4个节点的值。</p>
<p><img src="https://pic.imgdb.cn/item/5f466daf160a154a6798174a.jpg" alt=""></p>
<h4 id="5-基于线段树的RMQ的复杂度"><a href="#5-基于线段树的RMQ的复杂度" class="headerlink" title="5. 基于线段树的RMQ的复杂度"></a>5. 基于线段树的RMQ的复杂度</h4><p>​    每次操作都是O(log n)。n个元素的线段树的初始化的时间复杂度和总的空间复杂度都是O(n)。这是因为节点数是n+n/2+n/4+…=2n。只觉上很容易让人产生复杂度是O(nlogn)的错觉。</p>
<h4 id="6-基于线段树RMQ的实现"><a href="#6-基于线段树RMQ的实现" class="headerlink" title="6.基于线段树RMQ的实现"></a>6.基于线段树RMQ的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树</span></span><br><span class="line"><span class="comment"> * 初始化是O(n)</span></span><br><span class="line"><span class="comment"> * 更新查询操作是O(log n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, dat[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> maxn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.dat = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * maxn - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n_)</span> </span>&#123;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; n_) n *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 所有值设为INT_MAX</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dat[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把第k个值更新为a</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        k += n - <span class="number">1</span>;</span><br><span class="line">        dat[k] = a;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            dat[k] = Math.min(dat[k * <span class="number">2</span> + <span class="number">1</span>], dat[k * <span class="number">2</span> + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求[a,b)最小值</span></span><br><span class="line"><span class="comment">     * k是节点编号，l,r是表示这个节点对应的是[l,r)节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= a || l &gt;= b) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果[a,b)包含[l,r)，就返回当前节点值</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">            <span class="keyword">return</span> dat[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则返回两个儿子节点中较小者</span></span><br><span class="line">            <span class="keyword">int</span> v1 = <span class="keyword">this</span>.query(a, b, k * <span class="number">2</span> + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> v2 = <span class="keyword">this</span>.query(a, b, k * <span class="number">2</span> + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">            <span class="keyword">return</span> Math.min(v1, v2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-需要运用线段树的问题"><a href="#7-需要运用线段树的问题" class="headerlink" title="7. 需要运用线段树的问题"></a>7. 需要运用线段树的问题</h4><p><img src="https://pic.imgdb.cn/item/5f47b9b6160a154a676c86d7.jpg" alt=""></p>
<p>本题可以使用线段树来解决。每个阶段代表一段连续的线段的集合，并且维护下面两个值。</p>
<ul>
<li>把对应的线段中的第一条线段转至垂直方向后，从第一条线段的起点指向最后一条线段的重点的向量。</li>
<li>如果该节点有儿子节点， 两个儿子节点对应的部分连接之后，右儿子需要转动的角度。</li>
</ul>
<p>​    如果节点i表示的向量是vx[i], vy[i], 角度是ang[i],两个儿子节点是chl和chr。</p>
<p>​    那么就有</p>
<p>​    vx[i]= vx[chl] + (cos(ang[i]) * vx[chr] - sin(ang[i]) * vy[chr])</p>
<p>​    vy[i]= vy[chl] + (sin(ang[i]) * vx[chr] - sin(ang[i]) * vy[chr])</p>
<p>​    代码暂略</p>
<h4 id="专栏-基于稀疏表的RMQ"><a href="#专栏-基于稀疏表的RMQ" class="headerlink" title="专栏 基于稀疏表的RMQ"></a>专栏 基于稀疏表的RMQ</h4><p>​    <img src="https://pic.imgdb.cn/item/5f47bc8d160a154a676d716a.jpg" alt=""></p>
<h3 id="3-3-2-BIT-树状数组"><a href="#3-3-2-BIT-树状数组" class="headerlink" title="3.3.2 BIT(树状数组)"></a>3.3.2 BIT(树状数组)</h3><ul>
<li>初始值全为0的数列</li>
<li>给定i，计算a1到a[i]</li>
<li>给定i和x，执行a[i]+=x</li>
</ul>
<h4 id="1-基于线段树的实现"><a href="#1-基于线段树的实现" class="headerlink" title="1.基于线段树的实现"></a>1.基于线段树的实现</h4><p><img src="https://pic.imgdb.cn/item/5f47be66160a154a676e1e7d.jpg" alt=""></p>
<p>​    会发现每个节点的右儿子的值都不需要了。</p>
<p><img src="https://pic.imgdb.cn/item/5f47bf11160a154a676e5872.jpg" alt=""></p>
<h4 id="2-BIT的结构"><a href="#2-BIT的结构" class="headerlink" title="2.BIT的结构"></a>2.BIT的结构</h4><p>​    维护如下的部分和。</p>
<p><img src="https://pic.imgdb.cn/item/5f47bf35160a154a676e62a1.jpg" alt=""></p>
<h4 id="3-BIT的求和"><a href="#3-BIT的求和" class="headerlink" title="3.BIT的求和"></a>3.BIT的求和</h4><p>​    计算前i项和，需要从i开始，不断把i的值加入到结果中，并且减去二进制最低0位对应的幂，知道i变为0位置。i的最后一个1可以通过i&amp;-i得到</p>
<h4 id="4-BIT值的更新"><a href="#4-BIT值的更新" class="headerlink" title="4.BIT值的更新"></a>4.BIT值的更新</h4><p>​    从i开始，不断把i位置的值增加x，并把i的二进制最低非0位对应的幂加到i上。</p>
<h4 id="5-BIT的复杂度"><a href="#5-BIT的复杂度" class="headerlink" title="5.BIT的复杂度"></a>5.BIT的复杂度</h4><p>​    总攻需要对应O(log n)个值，所以复杂度是O(log n)</p>
<h4 id="6-BIT的实现"><a href="#6-BIT的实现" class="headerlink" title="6.BIT的实现"></a>6.BIT的实现</h4><p>​    顺便提一下， i -= i&amp;(i-1)也可以写作 i = i &amp; (i - 1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> bit[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += bit[i];</span><br><span class="line">            i -= i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            bit[i] += x;</span><br><span class="line">            i += i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-二维BIT"><a href="#7-二维BIT" class="headerlink" title="7.二维BIT"></a>7.二维BIT</h4><p>​    可以方便扩展到二维，对于W * H的二维BIT只需要建立H个大小为x轴元素个数为W的BIT。</p>
<p>​    然后通过这些BIT通过y轴方向的BIT管理起来就可以了。y轴方向的BIT的每个元素不是整数，而是一个x轴的BIT，这样所有操作的复杂度都是O(log W * log H)。用同样的方法可以扩展到更高的纬度。</p>
<h4 id="8-需要运用BIT的问题"><a href="#8-需要运用BIT的问题" class="headerlink" title="8.需要运用BIT的问题"></a>8.需要运用BIT的问题</h4><p><img src="https://pic.imgdb.cn/item/5f49e9ff160a154a67f85a7b.jpg" alt=""></p>
<p>​    所求交换次数等价于满足求i&lt;j, a[i] &gt; a[j]的(i,j)数对的个数。构建一个值的范围是1~n的BIT，按照j=0,1,2,…，n-1的顺序进行如下操作</p>
<ul>
<li>把j-(BIT查询得到的前a[j]项的和)加到答案中</li>
<li>把BIT中a[j]位置上的+1</li>
</ul>
<p>​    对每一个j，(BIT查询得到的钱a[j]项的和)就是满足i&lt;j,a[i]&lt;=a[j]的i个数，因此把这个值从j中减去之后，得到的就是满足i&lt;j,a[i]&gt;a[j]的个数。对于每一个j的复杂度是O(log n)，所以复杂度是O(nlogn)。更简单的做法是归并排序。</p>
<p>​    <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> getOffer.Pro51;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ac</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">new</span> Solution().reversePairs(a);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bit[], n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        <span class="keyword">int</span> temp[] = Arrays.copyOf(nums, nums.length);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lowerBound(temp, <span class="number">0</span>, nums.length, nums[i]) + <span class="number">1</span>;</span><br><span class="line">            nums[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = nums.length;</span><br><span class="line">        bit = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i - query(nums[i]);</span><br><span class="line">            ans += k;</span><br><span class="line">            add(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            bit[i] += x;</span><br><span class="line">            i += (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += bit[i];</span><br><span class="line">            i -= (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic.imgdb.cn/item/5f49fefb160a154a67fe9b4f.jpg" alt=""></p>
<p>暂时跳过</p>
<p>//todo</p>
<h3 id="3-3-3-分桶法与平方分割"><a href="#3-3-3-分桶法与平方分割" class="headerlink" title="3.3.3  分桶法与平方分割"></a>3.3.3  分桶法与平方分割</h3><p>​    分桶法时把一排物品或平台分成桶，每个桶分别维护自己内部的信息，以达到高效计算的目的的方法。</p>
<p><img src="https://pic.imgdb.cn/item/5f4a0621160a154a6700d71c.jpg" alt=""></p>
<p>​    平方分割是把一排的n个元素，每sqrt(n)个分在同一个桶内进行维护方法的统称。可以使对区间的操作复杂度降至O(sqrt(n))。</p>
<h4 id="1-基于平方分割的RMQ"><a href="#1-基于平方分割的RMQ" class="headerlink" title="1.基于平方分割的RMQ"></a>1.基于平方分割的RMQ</h4><p>​    给定数列，在O(sqrt(n))复杂度实现以下两个功能</p>
<ul>
<li>给定s,t, 求a[s]到a[t]的最小值</li>
<li>给定i,x,把a[i]的值变为x。</li>
</ul>
<h4 id="2-基于平方分割的预处理"><a href="#2-基于平方分割的预处理" class="headerlink" title="2.基于平方分割的预处理"></a>2.基于平方分割的预处理</h4><p>​    令b = floor(sqrt(n))，把a中的元素每b分成一个桶，并计算出每个桶内最小值。</p>
<h4 id="3-基于平方分割的RMQ查询"><a href="#3-基于平方分割的RMQ查询" class="headerlink" title="3.基于平方分割的RMQ查询"></a>3.基于平方分割的RMQ查询</h4><ul>
<li>如果桶完全包含在区间内，则查询桶的最小值</li>
<li>如果元素所在的桶不完全被区间包含，则逐个检查最小值。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/5f4a0745160a154a67012ed1.jpg" alt=""></p>
<h4 id="4-基于平方分割的RMQ的值的更新"><a href="#4-基于平方分割的RMQ的值的更新" class="headerlink" title="4.基于平方分割的RMQ的值的更新"></a>4.基于平方分割的RMQ的值的更新</h4><p>​    在更新时，需要跟新所在桶的最小值，这时候，只要遍历一遍桶内的元素就可以了。</p>
<h4 id="5-基于平方分割的RMQ的复杂度"><a href="#5-基于平方分割的RMQ的复杂度" class="headerlink" title="5.基于平方分割的RMQ的复杂度"></a>5.基于平方分割的RMQ的复杂度</h4><p>​    更新时，因为桶内有b个元素，所以复杂度是O(b)=O(sqrt(n))。</p>
<p>​    而在查询时</p>
<ul>
<li>完全包含在区间内的桶的个数是O(n/b)</li>
<li>所在的桶不被区间完全包含的个数是O(b)</li>
</ul>
<p>​    所以复杂度是O(sqrt(n))</p>
<h4 id="6-平方分割和线段树"><a href="#6-平方分割和线段树" class="headerlink" title="6. 平方分割和线段树"></a>6. 平方分割和线段树</h4><p>​    大多数情况下，线段树比平方分割块，但是平方分割在实现上比线段树简单，所以如果运行时间限制不是太紧时，可以考虑使用平方分割。除此之外，有一些功能是线段树无法高效维护但是平方分割却可以做到。</p>
<h4 id="7-需要运用平方分割的题目"><a href="#7-需要运用平方分割的题目" class="headerlink" title="7.需要运用平方分割的题目"></a>7.需要运用平方分割的题目</h4><p><img src="https://pic.imgdb.cn/item/5f4a0848160a154a670175a0.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4a08b1160a154a670194f0.jpg" alt=""></p>
<p>线段树做法</p>
<p><img src="https://pic.imgdb.cn/item/5f4a090b160a154a6701b1e2.jpg" alt=""></p>
<h4 id="专栏-区域树"><a href="#专栏-区域树" class="headerlink" title="专栏 区域树"></a>专栏 区域树</h4><p>​    上面提到每个节点维护一个数组的线段树和每个节点维护一棵树的线段树也叫做区域树。</p>
<h2 id="3-4-熟练掌握动态规划"><a href="#3-4-熟练掌握动态规划" class="headerlink" title="3.4 熟练掌握动态规划"></a>3.4 熟练掌握动态规划</h2><h3 id="3-4-1-状态压缩DP"><a href="#3-4-1-状态压缩DP" class="headerlink" title="3.4.1 状态压缩DP"></a>3.4.1 状态压缩DP</h3><p><img src="https://pic.imgdb.cn/item/5f4bae26160a154a6780c53f.jpg" alt=""></p>
<p>​    著名旅行商问题(TSP)。是NP困难的。可能路线有(n-1)!种，可以用DP来解决。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设现在已经访问过的顶点集合为S，当前所在的顶点为v，用dp[S][v]表示从v触发访问剩余所有节点，最终回到顶点0的路径权重的最小值。由于从v触发可以移动到任意一个节点，就有如下递推式。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/5f4baf14160a154a67810726.jpg" alt=""></p>
<p>​    递推式中，有一个下标是集合不是普通整数，因此需要稍加处理，把它编码成一个整数，或者给他们定义一个全序关系并用二叉搜索树存储，从而可以使用记忆化搜索来处理。对于集合可以把每一个元素选取与否存储到一个二进制位里，从而把状态压缩成一个整数。</p>
<p><img src="https://pic.imgdb.cn/item/5f4baf95160a154a67812a53.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bafb7160a154a678136d4.jpg" alt=""></p>
<p>可以在O(2^n n^2)时间内完成计算。也可以通过循环求出答案</p>
<p><img src="https://pic.imgdb.cn/item/5f4bafe3160a154a67814486.jpg" alt=""></p>
<p>​    针对这样集合的DP，一般叫做状态压缩DP。</p>
<p><img src="https://pic.imgdb.cn/item/5f4bb002160a154a67814d60.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bb018160a154a6781546b.jpg" alt=""></p>
<p>略 todo</p>
<h3 id="3-4-2-矩阵的幂"><a href="#3-4-2-矩阵的幂" class="headerlink" title="3.4.2 矩阵的幂"></a>3.4.2 矩阵的幂</h3><p><img src="https://pic.imgdb.cn/item/5f4bb055160a154a678165d9.jpg" alt=""></p>
<p>​    通过逐项计算这个递推式，可以在O(n)算出答案，但是效率太低了，大规模的n不好求解，通项公式包含无理数，无法简单求得模10^4之后的结果。</p>
<p><img src="https://pic.imgdb.cn/item/5f4bb0af160a154a67818383.jpg" alt=""></p>
<p>​    递推式表示成矩阵就得到下面的式子</p>
<p><img src="https://pic.imgdb.cn/item/5f4bb0e3160a154a67819326.jpg" alt=""></p>
<p>​    然后通过矩阵快速幂，就可以求出F(n)了。</p>
<p>​    代码暂略 todo</p>
<p><img src="https://pic.imgdb.cn/item/5f4bb16e160a154a6781d073.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bb17f160a154a6781db01.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bb1a1160a154a6781f0dc.jpg" alt=""></p>
<h4 id="专栏-更快地计算递推式"><a href="#专栏-更快地计算递推式" class="headerlink" title="专栏 更快地计算递推式"></a>专栏 更快地计算递推式</h4><p>​    事实上，要求m项递推式的第n项的值是可以不使用矩阵，而是使用初项的线性表示，通过快速幂在O(m^2log n)的时间内求出答案。</p>
<p><img src="https://pic.imgdb.cn/item/5f4bb213160a154a67821974.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bb336160a154a67826d9a.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4bb321160a154a67826815.jpg" alt=""></p>
<p>​    代码暂略。</p>
<h3 id="3-4-3-利用数据结构高效求解"><a href="#3-4-3-利用数据结构高效求解" class="headerlink" title="3.4.3 利用数据结构高效求解"></a>3.4.3 利用数据结构高效求解</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
            <a href="/tags/%E6%8C%91%E6%88%98/" rel="tag"># 挑战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/10/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="next" title="redis源码阅读">
                <i class="fa fa-chevron-left"></i> redis源码阅读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/20/Spring%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Spring实战学习笔记">
                Spring实战学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpg"
                alt="宋梓立 sorie" />
            
              <p class="site-author-name" itemprop="name">宋梓立 sorie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ewasong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:819294006@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-蓄势待发——准备篇"><span class="nav-number">1.</span> <span class="nav-text">第1章 蓄势待发——准备篇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-初出茅庐——初级篇"><span class="nav-number">2.</span> <span class="nav-text">第2章 初出茅庐——初级篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-最基础的“穷竭搜索”"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 最基础的“穷竭搜索”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-递归函数"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 递归函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-栈"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-队列"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-深度优先搜索"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-宽度优先搜索"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 宽度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-6-特殊状态枚举"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.6 特殊状态枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-7-剪枝"><span class="nav-number">2.1.7.</span> <span class="nav-text">2.1.7 剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-一往直前！-贪心法"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 一往直前！ 贪心法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-硬币问题"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 硬币问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-区间问题"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 区间问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-字典序最小问题"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 字典序最小问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-其他例题"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4 其他例题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专栏-Huffman编码"><span class="nav-number">2.2.5.</span> <span class="nav-text">专栏 Huffman编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3记录结果再利用的动态规划"><span class="nav-number">2.3.</span> <span class="nav-text">2.3记录结果再利用的动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-记忆化搜索与动态规划"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 记忆化搜索与动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用memset进行初始化"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">使用memset进行初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种各样的dp"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">各种各样的dp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-进一步探讨递推关系"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 进一步探讨递推关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-有关计数问题的DP"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 有关计数问题的DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-加工并存储数据的数据结构"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 加工并存储数据的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-树和二叉树"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 树和二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-优先队列和堆"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 优先队列和堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-二叉搜索树"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-并查集"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4 并查集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-它们其实都是“图”"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 它们其实都是“图”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-什么是图？"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 什么是图？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-图的表示"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 图的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-图的搜索"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 图的搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-最短路问题"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4 最短路问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-5-最小生成树"><span class="nav-number">2.5.5.</span> <span class="nav-text">2.5.5  最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-6-应用问题"><span class="nav-number">2.5.6.</span> <span class="nav-text">2.5.6 应用问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-6-数学问题的解题窍门"><span class="nav-number">3.</span> <span class="nav-text">2.6 数学问题的解题窍门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-辗转相除法"><span class="nav-number">3.0.1.</span> <span class="nav-text">2.6.1 辗转相除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-有关素数的基础算法"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.6.2 有关素数的基础算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-模运算"><span class="nav-number">3.0.3.</span> <span class="nav-text">2.6.3 模运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-4-快速幂运算"><span class="nav-number">3.0.4.</span> <span class="nav-text">2.6.4 快速幂运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-一起来挑战GCJ的题目-1"><span class="nav-number">3.1.</span> <span class="nav-text">2.7 一起来挑战GCJ的题目(1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-出类拔萃——中级篇"><span class="nav-number">4.</span> <span class="nav-text">第3章 出类拔萃——中级篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-不光是查找值！“二分搜索”"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 不光是查找值！“二分搜索”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-从有序数组中查找某个值"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.1.1 从有序数组中查找某个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-假定一个解判断是否可行"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.1.2 假定一个解判断是否可行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-最大化最小值"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.1.3  最大化最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-最大化平均值"><span class="nav-number">4.1.4.</span> <span class="nav-text">3.1.4 最大化平均值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-常用技巧精选（一）"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 常用技巧精选（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-尺取法"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1 尺取法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-反转-开关问题"><span class="nav-number">4.2.2.</span> <span class="nav-text">3.2.2 反转(开关问题)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-弹性碰撞"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.2.3 弹性碰撞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-折半搜索（双向搜索）"><span class="nav-number">4.2.4.</span> <span class="nav-text">3.2.4 折半搜索（双向搜索）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-坐标离散化"><span class="nav-number">4.2.5.</span> <span class="nav-text">3.2.5 坐标离散化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-活用各种数据结构"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 活用各种数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-线段树"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.3.1 线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-线段树的概念"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">1.线段树的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-基于线段树的RMQ结构"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">2.基于线段树的RMQ结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-基于线段树的RMQ的查询"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">3.基于线段树的RMQ的查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-基于线段树RMQ的值的更新"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">4.基于线段树RMQ的值的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-基于线段树的RMQ的复杂度"><span class="nav-number">4.3.1.5.</span> <span class="nav-text">5. 基于线段树的RMQ的复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-基于线段树RMQ的实现"><span class="nav-number">4.3.1.6.</span> <span class="nav-text">6.基于线段树RMQ的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-需要运用线段树的问题"><span class="nav-number">4.3.1.7.</span> <span class="nav-text">7. 需要运用线段树的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专栏-基于稀疏表的RMQ"><span class="nav-number">4.3.1.8.</span> <span class="nav-text">专栏 基于稀疏表的RMQ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-BIT-树状数组"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.3.2 BIT(树状数组)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-基于线段树的实现"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">1.基于线段树的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-BIT的结构"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">2.BIT的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-BIT的求和"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">3.BIT的求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-BIT值的更新"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">4.BIT值的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-BIT的复杂度"><span class="nav-number">4.3.2.5.</span> <span class="nav-text">5.BIT的复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-BIT的实现"><span class="nav-number">4.3.2.6.</span> <span class="nav-text">6.BIT的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-二维BIT"><span class="nav-number">4.3.2.7.</span> <span class="nav-text">7.二维BIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-需要运用BIT的问题"><span class="nav-number">4.3.2.8.</span> <span class="nav-text">8.需要运用BIT的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-分桶法与平方分割"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3.3  分桶法与平方分割</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-基于平方分割的RMQ"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">1.基于平方分割的RMQ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-基于平方分割的预处理"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">2.基于平方分割的预处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-基于平方分割的RMQ查询"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">3.基于平方分割的RMQ查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-基于平方分割的RMQ的值的更新"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">4.基于平方分割的RMQ的值的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-基于平方分割的RMQ的复杂度"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">5.基于平方分割的RMQ的复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-平方分割和线段树"><span class="nav-number">4.3.3.6.</span> <span class="nav-text">6. 平方分割和线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-需要运用平方分割的题目"><span class="nav-number">4.3.3.7.</span> <span class="nav-text">7.需要运用平方分割的题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专栏-区域树"><span class="nav-number">4.3.3.8.</span> <span class="nav-text">专栏 区域树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-熟练掌握动态规划"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 熟练掌握动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-状态压缩DP"><span class="nav-number">4.4.1.</span> <span class="nav-text">3.4.1 状态压缩DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-矩阵的幂"><span class="nav-number">4.4.2.</span> <span class="nav-text">3.4.2 矩阵的幂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#专栏-更快地计算递推式"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">专栏 更快地计算递推式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-利用数据结构高效求解"><span class="nav-number">4.4.3.</span> <span class="nav-text">3.4.3 利用数据结构高效求解</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宋梓立 sorie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  









  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'XTY8e76465N8ugbyhpCoS88f-gzGzoHsz',
        appKey: 'dwWTNcurePtzzBdMO62hSRMy',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
