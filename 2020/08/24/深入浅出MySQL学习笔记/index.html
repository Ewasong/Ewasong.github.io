<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="mysql,数据库," />










<meta name="description" content="第一部分 基础篇第1章 MySQL的安装与配置1.1 MySQL的下载1.1.1 在Window平台下下载MySQL​    直接搜索Mysql官网下载即可。 1.1.2 在Linux平台下下载Mysql1.通过网页直接下载​    在网页下载后用FTP等工具传送到Linux服务器上。 2.通过命令行方式下载​    wget + url的形式。 1.2 MySQL的安装1.2.1 在Wiindo">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出MySQL学习笔记">
<meta property="og:url" content="http://yoursite.com/2020/08/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="宋二的小窝">
<meta property="og:description" content="第一部分 基础篇第1章 MySQL的安装与配置1.1 MySQL的下载1.1.1 在Window平台下下载MySQL​    直接搜索Mysql官网下载即可。 1.1.2 在Linux平台下下载Mysql1.通过网页直接下载​    在网页下载后用FTP等工具传送到Linux服务器上。 2.通过命令行方式下载​    wget + url的形式。 1.2 MySQL的安装1.2.1 在Wiindo">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f45218e160a154a677a2b8f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f452158160a154a6779f8a9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f45227e160a154a677b0767.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f464f3d160a154a67890a8d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4653cc160a154a678b9c5a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4653da160a154a678ba3cb.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f465937160a154a678e5f3d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4659ce160a154a678eb77e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f465a5e160a154a678f074f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f465c78160a154a67901409.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f465d5b160a154a67908550.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a459160a154a6766008e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a466160a154a67660473.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a4a1160a154a676616a5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a4ef160a154a67662cf9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a583160a154a676659af.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a696160a154a6766ae6a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a757160a154a6766e93c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a8a4160a154a6767537b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47a82b160a154a67672ee8.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47aa85160a154a6767d6b2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f47adca160a154a6768d9ba.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49a6b7160a154a67e55484.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49b76a160a154a67e9a32e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49ba1d160a154a67ea5a4c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f49c157160a154a67ec6d28.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4af50e160a154a674d3812.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4af534160a154a674d453b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4b998b160a154a677a8cf2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4b9e49160a154a677c186a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4b9e9b160a154a677c2e3c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4b9eb0160a154a677c335b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba05e160a154a677ca559.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba0c0160a154a677cc272.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba10f160a154a677cd658.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba2a5160a154a677d433d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba2b2160a154a677d469f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba220160a154a677d228d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba3c5160a154a677d954d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba3e6160a154a677d9dcc.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba3f3160a154a677da103.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba4ea160a154a677de33d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba5bc160a154a677e2334.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba5dc160a154a677e2cbd.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba69f160a154a677e5fd7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba6b2160a154a677e64a3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba6c3160a154a677e6a17.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba6d0160a154a677e6f73.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba6f3160a154a677e796f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba71f160a154a677e8603.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba783160a154a677ea36c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba78e160a154a677ea848.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba7bc160a154a677eb7f4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba7d1160a154a677ebea3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba7e2160a154a677ec42e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba8ff160a154a677f1f3f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba99b160a154a677f489a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4ba9f2160a154a677f61f5.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4baad4160a154a677fa31c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4bab9e160a154a677fe8a4.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf151160a154a67fa62f3.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf38b160a154a67fc6ab9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf39d160a154a67fc759f.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf5bb160a154a67fe690c.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf728160a154a67ffca79.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4cf733160a154a67ffd50b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4e5a36160a154a67a7f01a.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4e5b8f160a154a67a84940.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4e5baa160a154a67a85056.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4f9b0a160a154a67f57c8d.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4f9d21160a154a67f6251b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f4f9d50160a154a67f63886.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f50e568160a154a673d02c2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f50e97a160a154a673e6bff.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f50f18e160a154a674091a7.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f56247c160a154a6760d5a1.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f562917160a154a67622404.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f56317b160a154a676427d9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f5632e0160a154a676494ec.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f564492160a154a67699ece.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f577a2d160a154a67ac147b.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f577cc3160a154a67ad0ffe.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f577cdc160a154a67ad17a2.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f5a1334160a154a67c70de8.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f5a1660160a154a67c871f9.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/5f5a3811160a154a67d4ff4a.jpg">
<meta property="article:published_time" content="2020-08-24T13:45:40.000Z">
<meta property="article:modified_time" content="2020-09-10T14:43:02.809Z">
<meta property="article:author" content="宋梓立 sorie">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/5f45218e160a154a677a2b8f.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/24/深入浅出MySQL学习笔记/"/>





  <title>深入浅出MySQL学习笔记 | 宋二的小窝</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Ewasong" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">宋二的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="宋梓立 sorie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宋二的小窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入浅出MySQL学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-24T21:45:40+08:00">
                2020-08-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一部分-基础篇"><a href="#第一部分-基础篇" class="headerlink" title="第一部分 基础篇"></a>第一部分 基础篇</h1><h1 id="第1章-MySQL的安装与配置"><a href="#第1章-MySQL的安装与配置" class="headerlink" title="第1章 MySQL的安装与配置"></a>第1章 MySQL的安装与配置</h1><h2 id="1-1-MySQL的下载"><a href="#1-1-MySQL的下载" class="headerlink" title="1.1 MySQL的下载"></a>1.1 MySQL的下载</h2><h3 id="1-1-1-在Window平台下下载MySQL"><a href="#1-1-1-在Window平台下下载MySQL" class="headerlink" title="1.1.1 在Window平台下下载MySQL"></a>1.1.1 在Window平台下下载MySQL</h3><p>​    直接搜索Mysql官网下载即可。</p>
<h3 id="1-1-2-在Linux平台下下载Mysql"><a href="#1-1-2-在Linux平台下下载Mysql" class="headerlink" title="1.1.2 在Linux平台下下载Mysql"></a>1.1.2 在Linux平台下下载Mysql</h3><h4 id="1-通过网页直接下载"><a href="#1-通过网页直接下载" class="headerlink" title="1.通过网页直接下载"></a>1.通过网页直接下载</h4><p>​    在网页下载后用FTP等工具传送到Linux服务器上。</p>
<h4 id="2-通过命令行方式下载"><a href="#2-通过命令行方式下载" class="headerlink" title="2.通过命令行方式下载"></a>2.通过命令行方式下载</h4><p>​    wget + url的形式。</p>
<h2 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h2><h3 id="1-2-1-在Wiindows平台下安装MySQL"><a href="#1-2-1-在Wiindows平台下安装MySQL" class="headerlink" title="1.2.1 在Wiindows平台下安装MySQL"></a>1.2.1 在Wiindows平台下安装MySQL</h3><p>​    略</p>
<h3 id="1-2-2-在Linux平台下安装MySQL"><a href="#1-2-2-在Linux平台下安装MySQL" class="headerlink" title="1.2.2 在Linux平台下安装MySQL"></a>1.2.2 在Linux平台下安装MySQL</h3><p>​    也略</p>
<h2 id="1-3-MySQL的配置"><a href="#1-3-MySQL的配置" class="headerlink" title="1.3 MySQL的配置"></a>1.3 MySQL的配置</h2><h3 id="1-3-1-Windows平台下配置MySQL"><a href="#1-3-1-Windows平台下配置MySQL" class="headerlink" title="1.3.1 Windows平台下配置MySQL"></a>1.3.1 Windows平台下配置MySQL</h3><p>​    略</p>
<h3 id="1-3-2-Linux平台下配置MySQL"><a href="#1-3-2-Linux平台下配置MySQL" class="headerlink" title="1.3.2 Linux平台下配置MySQL"></a>1.3.2 Linux平台下配置MySQL</h3><p>​    通过修改cnf文件。</p>
<h2 id="1-4-启动和关闭MySQL服务"><a href="#1-4-启动和关闭MySQL服务" class="headerlink" title="1.4 启动和关闭MySQL服务"></a>1.4 启动和关闭MySQL服务</h2><h3 id="1-4-1-在Windows平台下启动和关闭MySQL服务"><a href="#1-4-1-在Windows平台下启动和关闭MySQL服务" class="headerlink" title="1.4.1 在Windows平台下启动和关闭MySQL服务"></a>1.4.1 在Windows平台下启动和关闭MySQL服务</h3><p>​    略</p>
<h3 id="1-4-2-在Linux平台下启动和关闭MySQL服务"><a href="#1-4-2-在Linux平台下启动和关闭MySQL服务" class="headerlink" title="1.4.2 在Linux平台下启动和关闭MySQL服务"></a>1.4.2 在Linux平台下启动和关闭MySQL服务</h3><h4 id="1-命令行方式"><a href="#1-命令行方式" class="headerlink" title="1.命令行方式"></a>1.命令行方式</h4><ul>
<li><p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /user/bing</span><br><span class="line">./mysqld_safe &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot shutdown</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-服务的方式"><a href="#2-服务的方式" class="headerlink" title="2.服务的方式"></a>2.服务的方式</h4><p>如果mysql是用RPM包安装的</p>
<ul>
<li><p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>

<h2 id="第2章-SQL基础"><a href="#第2章-SQL基础" class="headerlink" title="第2章 SQL基础"></a>第2章 SQL基础</h2><h2 id="2-1-SQL简介"><a href="#2-1-SQL简介" class="headerlink" title="2.1 SQL简介"></a>2.1 SQL简介</h2><p>​    略</p>
<h2 id="2-2-MySQL使用入门"><a href="#2-2-MySQL使用入门" class="headerlink" title="2.2 MySQL使用入门"></a>2.2 MySQL使用入门</h2><h3 id="2-2-1-SQL分类"><a href="#2-2-1-SQL分类" class="headerlink" title="2.2.1 SQL分类"></a>2.2.1 SQL分类</h3><ul>
<li>DDL：数据定义语言，主要定义不同的数据段、数据库、表、列、索引等数据库对象。</li>
<li>DML: 增删改查</li>
<li>DCL: 数据库控制语句，比如grant，revoke等。</li>
</ul>
<h3 id="2-2-2-DDL语句"><a href="#2-2-2-DDL语句" class="headerlink" title="2.2.2 DDL语句"></a>2.2.2 DDL语句</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#-u后面跟连接的数据库用户 -p表示需要输入密码</span></span><br><span class="line">CREATE DATABASE dbname</span><br><span class="line"><span class="comment">#展示有哪些数据库</span></span><br><span class="line">show databases</span><br><span class="line"><span class="comment">#选择数据库</span></span><br><span class="line">use dbname</span><br><span class="line"><span class="comment">#展示数据表</span></span><br><span class="line">show tables</span><br></pre></td></tr></table></figure>

<h4 id="2-删除数据库"><a href="#2-删除数据库" class="headerlink" title="2.删除数据库"></a>2.删除数据库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop databse test1;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3.创建表"></a>3.创建表</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table tablename (</span><br><span class="line">	col_name_1 col_type_1 constraints,</span><br><span class="line">	col_name_2 col_type_2 constraints,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看表定义</span></span><br><span class="line">desc tablename</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看创建表的sql语句</span></span><br><span class="line">show create table tablename;</span><br></pre></td></tr></table></figure>

<h4 id="4-删除表"><a href="#4-删除表" class="headerlink" title="4.删除表"></a>4.删除表</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table tablename;</span><br></pre></td></tr></table></figure>

<h4 id="5-修改表"><a href="#5-修改表" class="headerlink" title="5.修改表"></a>5.修改表</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改表类型</span></span><br><span class="line">ALTER TABLE tablename MODIFY [COLUMN] column_ definition [FIRST | AFTER col_ name];</span><br><span class="line">alter table emp modify ename varchar(20);</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加表字段</span></span><br><span class="line">ALTER TABLE tablename ADD [COLUMN] column_ definition [FIRST | AFTER col_ name];</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除表字段</span></span><br><span class="line">ALTER TABLE tablename DROP [COLUMN] col_ name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段改名</span></span><br><span class="line">ALTER TABLE tablename CHANGE [COLUMN] old_ col_ name column_ definition [FIRST| AFTER col_ name]</span><br><span class="line">alter table emp change age age1 int(4) ;</span><br><span class="line"><span class="comment">#修改字段排序顺序</span></span><br><span class="line"><span class="comment">#放在某个字段后面</span></span><br><span class="line">alter table emp add birth date after ename;</span><br><span class="line"><span class="comment">#放在最前面</span></span><br><span class="line">alter table emp modify age int(3) first;</span><br><span class="line"></span><br><span class="line"><span class="comment">#改表名</span></span><br><span class="line">ALTER TABLE tablename RENAME [TO] new_tablename</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-DML语句"><a href="#2-2-3-DML语句" class="headerlink" title="2.2.3 DML语句"></a>2.2.3 DML语句</h3><h4 id="1-插入记录"><a href="#1-插入记录" class="headerlink" title="1.插入记录"></a>1.插入记录</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入记录</span></span><br><span class="line">INSERT INTO tablename (field1, field2,…, fieldn) VALUES( value1, value2,…, valuen);</span><br><span class="line"><span class="comment"># 不指定字段名称，values和字段排序一样</span></span><br><span class="line">insert into emp values(<span class="string">'lisa'</span>,<span class="string">' 2003- 02- 01'</span>,<span class="string">' 3000'</span>, 2);</span><br><span class="line"><span class="comment">#可以一次性插入多条记录</span></span><br><span class="line">INSERT INTO tablename (field1, field2, …, fieldn) VALUES (record1_ value1, record1_ value2, …, record1_ valuesn), </span><br><span class="line">(record2_ value1, record2_ value2, …, valuesn2);</span><br></pre></td></tr></table></figure>

<h4 id="2-更新语句"><a href="#2-更新语句" class="headerlink" title="2. 更新语句"></a>2. 更新语句</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tablename SET field1= value1, field2.= value2,…, fieldn= valuen [WHERE CONDITION]</span><br></pre></td></tr></table></figure>

<h4 id="3-删除记录"><a href="#3-删除记录" class="headerlink" title="3.删除记录"></a>3.删除记录</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tablename [WHERE CONDITION]</span><br></pre></td></tr></table></figure>

<h4 id="4-查询记录"><a href="#4-查询记录" class="headerlink" title="4.查询记录"></a>4.查询记录</h4><p>这里只介绍最基本的语法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablename [WHERE CONDITION]</span><br><span class="line"><span class="comment">#查询不重复记录</span></span><br><span class="line">select distinct deptno from emp;</span><br><span class="line"><span class="comment">#条件查询</span></span><br><span class="line">select * from emp <span class="built_in">where</span> deptno= 1;</span><br><span class="line"><span class="comment">#多字段条件查询</span></span><br><span class="line">select * from emp <span class="built_in">where</span> deptno= 1 and sal&lt; 3000;</span><br><span class="line"><span class="comment">#排序和限制</span></span><br><span class="line">SELECT * FROM tablename [WHERE CONDITION] [ORDER BY field1 [DESC| ASC]， field2 [DESC| ASC],…, fieldn [DESC| ASC]]</span><br><span class="line">select * from emp order by sal;</span><br><span class="line"><span class="comment">#限制一部分</span></span><br><span class="line">SELECT …[LIMIT offset_ start, row_ count]</span><br><span class="line"><span class="comment">#前三条</span></span><br><span class="line">select * from emp order by sal <span class="built_in">limit</span> 3;</span><br><span class="line"><span class="comment">#第二条记录开始的3条</span></span><br><span class="line">select * from emp order by sal <span class="built_in">limit</span> 1, 3;</span><br><span class="line"></span><br><span class="line"><span class="comment">#聚合</span></span><br><span class="line"><span class="comment">#聚合常用的有sum count max min</span></span><br><span class="line"><span class="comment">#group by是聚合字段</span></span><br><span class="line"><span class="comment">#WITH ROLLUP是可选语法，表明是否对分类聚合后的结果进行再汇总</span></span><br><span class="line"><span class="comment">#HAVING表示对分类后的结果再进行条件的过滤</span></span><br><span class="line"><span class="comment">#建议先用where过滤在用having过滤，可以提高效率</span></span><br><span class="line">SELECT [field1, field2,…, fieldn] fun_ name FROM tablename [WHERE where_ contition] [GROUP BY field1, field2,…, fieldn [WITH ROLLUP]] [HAVING where_ contition]</span><br><span class="line"></span><br><span class="line"><span class="comment">#表连接</span></span><br><span class="line"><span class="comment">#分为内连接和外连接</span></span><br><span class="line"><span class="comment">#内连接仅选出两张表相互匹配的字段</span></span><br><span class="line"><span class="comment">#外连接会选出其他不匹配的记录</span></span><br><span class="line"><span class="comment">#常用内连接</span></span><br><span class="line">select ename, deptname from emp, dept <span class="built_in">where</span> emp. deptno= dept. deptno;</span><br><span class="line"><span class="comment"># 左连接和右连接</span></span><br><span class="line">select ename, deptname from emp left join dept on emp. deptno= dept. deptno;</span><br><span class="line">select ename, deptname from dept right join emp on dept. deptno= emp. deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子查询</span></span><br><span class="line">select * from emp <span class="built_in">where</span> deptno <span class="keyword">in</span>( select deptno from dept);</span><br><span class="line"><span class="comment">#如果子查询记录数唯一可以用=代替</span></span><br><span class="line">select * from emp <span class="built_in">where</span> deptno = (select deptno from dept);</span><br><span class="line"><span class="comment">#某些情况自连接可以转化为表连接</span></span><br><span class="line"><span class="comment">#mysql4.1之前不支持子查询</span></span><br><span class="line"><span class="comment">#表连接在很多情况下用于优化子查询</span></span><br><span class="line">select emp.* from emp ,dept <span class="built_in">where</span> emp. deptno= dept. deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">#记录联合</span></span><br><span class="line"><span class="comment"># UNION是取并集去重</span></span><br><span class="line"><span class="comment"># UNION ALL是不去重</span></span><br><span class="line">SELECT * FROM t1</span><br><span class="line">UNION| UNION ALL</span><br><span class="line">SELECT * FROM t2 </span><br><span class="line">…</span><br><span class="line">UNION| UNION ALL </span><br><span class="line">SELECT * FROM tn;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-DCL语句"><a href="#2-2-4-DCL语句" class="headerlink" title="2.2.4 DCL语句"></a>2.2.4 DCL语句</h3><p>​    DBA用来管理系统中的对象权限时使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个用户z1，具有对sakila数据库中所有表的SELECT/INSERT权限</span></span><br><span class="line">grant select, insert on sakila.* to <span class="string">'z1'</span>@<span class="string">' localhost'</span> identified by <span class="string">'123'</span>;</span><br><span class="line"><span class="comment"># 回收insert权限</span></span><br><span class="line">revoke insert on sakila.* from <span class="string">'z1'</span>@<span class="string">' localhost'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-帮助的使用"><a href="#2-3-帮助的使用" class="headerlink" title="2.3 帮助的使用"></a>2.3 帮助的使用</h2><p>​    使用MySQL安装后自带的帮助文档</p>
<h3 id="2-3-1-按照层次看帮助"><a href="#2-3-1-按照层次看帮助" class="headerlink" title="2.3.1 按照层次看帮助"></a>2.3.1 按照层次看帮助</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不知道帮助能够提供什么 以下命令显示所有可供查询的分类</span></span><br><span class="line">? contents</span><br><span class="line"><span class="comment"># 对于列出的分类， 使用"? 类别名称" 方式进一步查看</span></span><br><span class="line"><span class="comment"># 可以使用? 一层层往下查询</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-快速查阅帮助"><a href="#2-3-2-快速查阅帮助" class="headerlink" title="2.3.2 快速查阅帮助"></a>2.3.2 快速查阅帮助</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要快速查阅某项语法，比如show命令</span></span><br><span class="line">? show</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-常用网络资源"><a href="#2-3-3-常用网络资源" class="headerlink" title="2.3.3 常用网络资源"></a>2.3.3 常用网络资源</h3><pre><code>http:// dev. mysql. com/ downloads 是 MySQL 的 官方 网 站， 可以 下载 到 各个 版本 的 MySQL 以及 相关 客户 端 开发 工具 等。
http:// dev. mysql. com/ doc 提供 了 目前 最 权威 的 MySQL 数据库 及 工具 的 在 线 手册。 
http:// bugs. mysql. com 这里 可以 查看 到 MySQL 已经 发布 的 bug 列表， 或者 向 MySQL 提交 bug 报告。 
http:// www. mysql. com/ news- and- events/ newsletter 通常 会 发布 各种 关于 MySQL 的 最新消息。</code></pre><h2 id="2-4-查询元数据信息"><a href="#2-4-查询元数据信息" class="headerlink" title="2.4 查询元数据信息"></a>2.4 查询元数据信息</h2><p>​    mysql5.0以后，提供了一个新的数据库information_schema，用来记录MySQL中元数据信息。比如表名，列名。</p>
<p>​    它是一个虚拟库，物理上不存在相关的目录和文件。库里show tables 显示的各种表也并不是实际存在的物理表，而全部是视图。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 数据库 test1 下 所有 前缀 为 tmp 的 表； </span></span><br><span class="line">select concat(<span class="string">' drop table test1.'</span>, table_ name,<span class="string">';'</span>) from tables <span class="built_in">where</span> table_ schema=<span class="string">' test1'</span> and table_ name like <span class="string">'tmp%'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#将 数据库 test1 下 所有 存储 引擎 为 myisam 的 表 改为 innodb。</span></span><br><span class="line">select concat(<span class="string">' alter table test1.'</span>, table_ name,<span class="string">' engine= innodb;'</span>) from tables <span class="built_in">where</span> table_ schema=<span class="string">' test1'</span> and engine=<span class="string">' MyISAM'</span>;</span><br></pre></td></tr></table></figure>

<h1 id="第3章-MySQL-支持的数据类型"><a href="#第3章-MySQL-支持的数据类型" class="headerlink" title="第3章 MySQL 支持的数据类型"></a>第3章 MySQL 支持的数据类型</h1><h2 id="3-1-数值类型"><a href="#3-1-数值类型" class="headerlink" title="3.1 数值类型"></a>3.1 数值类型</h2><p><img src="https://pic.imgdb.cn/item/5f45218e160a154a677a2b8f.jpg" alt=""></p>
<p>​    包含严格数值类型</p>
<p>​    INTEGER,SMALLINT,DECIMAL,NUMERIC</p>
<p>​    以及近似数值数据类型</p>
<p>​    FLOAT, REAL, DOUBLE PRECISION</p>
<p>​    并在此基础上做了扩展</p>
<p>​    TINYINT,MEDIUMINT,BIGINT</p>
<p>​    对于整数类型，还支持在类型后面的小括号内指定显示宽度。int默认为int(11)。可以配合zerofill使用，数字位数不够填充前置0。</p>
<p>​    整数类型有一个可选属性 UNSIGNED，保存非负数或者较大上限值，可以用此选项。取值是正常值的下限取0，上限取原值的2倍。</p>
<p>​    整数类型还有一个属性 AUTO_INCREMENT，插入NULL到AUTO_INCREMENT列时，插入一个比该列当前最大值大1的值。</p>
<p>​    对于任何想要使用AUTO_INCREMENT的列，应该定义为NOT NULL，并定义为PRIMARY KEY或定义为UNIQUE键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE AI (ID INT AUTO_ INCREMENT NOT NULL PRIMARY KEY); </span><br><span class="line">CREATE TABLE AI( ID INT AUTO_ INCREMENT NOT NULL ,PRIMARY KEY( ID));</span><br><span class="line">CREATE TABLE AI (ID INT AUTO_ INCREMENT NOT NULL ,UNIQUE( ID));</span><br></pre></td></tr></table></figure>



<p>​    对于小数，有浮点数和定点数。浮点数包括float和double，定点数则只有decimal一种，定点数在MySQL内部以字符串形式存放，比浮点数精确。浮点数和定点数都可以在类型名称后面加(M,D)表示M位数字，其中D位小数位于小数点后面。</p>
<p>​    浮点数跟(M,D)是非标准用法，最好不用这么使用。</p>
<p>​    decimal默认10位，默认小数位为0。</p>
<p>​    BIT(位)类型，用于存放字段值，BIT可以用来存放多位二进制数，M范围从1~64,不写默认1位。直接使用SELECT 不会看到结果，可以使用bin()或者hex()查看二进制数或者16进制结果。</p>
<h2 id="3-2-日期时间类型"><a href="#3-2-日期时间类型" class="headerlink" title="3.2 日期时间类型"></a>3.2 日期时间类型</h2><p>​    <img src="https://pic.imgdb.cn/item/5f452158160a154a6779f8a9.jpg" alt=""></p>
<p>​    如果经常插入或更新日期为当前系统时间，通常使用TIMESTAMP来表示，它返回后显示为”YYYY-MM-DD HH:MM:SS”格式字符串，显示固定宽度为19个字符。如果想获得数字值，应该在列上”+0”</p>
<p>​    如果只是表示年份，可以用YEAR来表示，比DATE占用更少空间。有2位或者4位，4位允许值是1901~2155和0000。2位允许的是70到69，表示从1970到2069。</p>
<p>​    从5.5.27,2为格式的year不被支持。</p>
<p>​    零值显示方式</p>
<p><img src="https://pic.imgdb.cn/item/5f45227e160a154a677b0767.jpg" alt=""></p>
<p>​    </p>
<p>​    可以用now()函数插入当前日期。</p>
<p>​    创建测试表t, id1为TIMESTAMP类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># create table t (id1 timestamp);</span><br></pre></td></tr></table></figure>

<p>​    会发现，系统给tm自动创建了默认值CURRENT_TIMESTAMP,并且设置了not null和 on update CURRENT_TIMESTAMP属性。</p>
<p>​    插入NULL值时，会自动插入系统日期。MySQL只给表的第一个TIMESTAMP字段设置默认值为系统日期，如果有第二个，设置默认值为0值。</p>
<p>​    MySQL5.6之前，可以修改id2的日期为其他常量日期，但是不能再修改为current_timestamp, 之后的版本这个限制已经去掉。</p>
<p>​    如果将explicit_defaults_for_timestamp设置为on，那么刚才哪些默认值和属性都不会设置，需要手动操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区 如果值为'SYSTEM'就和主机的时区一样</span></span><br><span class="line">show variables like <span class="string">'time_zone'</span>;</span><br><span class="line"><span class="comment"># 修改为东9区</span></span><br><span class="line"><span class="built_in">set</span> time_zone = <span class="string">'+9:00'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TIMESTAMP支持的时间范围较小，DATETIME的范围更大。两者都可以设置 ON UPDATE CURRENT_TIMESTAMP属性，使得日期列可以随其他列的更新而自动更新为最新的时间</li>
<li>TIMESTAMP在5.6.6版本只有添加了控制参数explicit_defauts_for_timestamp，如果为on，timestamp需要显式指定默认值和ON UPDATE CURRENT_TIMESTAMP，并且设置为not null。8.0.2版本之后默认为on，之前为off。</li>
<li>explicit_defauts_for_timestamp为off，第一个TIMESTAMP列自动设置为系统时间，如果插入NULL，自动设置为当前的日期和时间，在插入或更新一行， 没有显式给定值，也会设置为当前日期和时间。如果查出取值范围，会认为该值溢出，使用0值进行填补。</li>
<li>TIMESTAMP的插入和查询都受当地时区的影响，更能反映出实际的日期，而DATETIME则只能反映出插入时地区的当地的时区，其他时区的人查看数据必然会有误差。</li>
<li>TIMESTAMP属性受版本和服务器SQLMode的影响很大，本章都是以MySQL5.7为例进行介绍。</li>
</ul>
<p>​    插入日期的支持的格式很多，以DATETIME为例：</p>
<ul>
<li>YYYY-MM-DD HH:MM:SS或YY-MM-DD HH:MM:SS的字符串，允许不严格语法，任何标点都可以用作日期部门或时间部分之间的分隔符，如果日和月小于10，不需要指定两位数。时分秒小于10也不需要指定两位数。</li>
<li>YYYYMMDDHHMMSS或YYMMDDHHMMSS格式的字符串，假定字符串对日期类型是有意义的,就比较严格。数字值应为6、8、12或14位长，8或者14位，则假定为YYYYMMDD或YYYYMMDDHHMMSS。如果是6位或者12位，则认为是YYMMDD或YYMMDDHHMMSS。其他数字被解释仿佛用零填充到了最近的长度。</li>
</ul>
<h2 id="3-3-字符串类型"><a href="#3-3-字符串类型" class="headerlink" title="3.3 字符串类型"></a>3.3 字符串类型</h2><p><img src="https://pic.imgdb.cn/item/5f464f3d160a154a67890a8d.jpg" alt=""></p>
<h3 id="3-3-1-CHAR和VARCHAR型"><a href="#3-3-1-CHAR和VARCHAR型" class="headerlink" title="3.3.1 CHAR和VARCHAR型"></a>3.3.1 CHAR和VARCHAR型</h3><p>​    两者存储方式不同，在检索时CHAR删除了尾部空格,VARCHAR保留</p>
<h3 id="3-3-2-BINARY和VARBINARY类型"><a href="#3-3-2-BINARY和VARBINARY类型" class="headerlink" title="3.3.2 BINARY和VARBINARY类型"></a>3.3.2 BINARY和VARBINARY类型</h3><p>​    类似于CHAR和VARCHAR型，不同的是它们包含二进制字符串，而不包含非二进制字符串。</p>
<pre><code>CREATE TABLE t (c BINARY( 3));
INSERT INTO t SET c=&apos; a&apos;;
select *,hex( c), c=&apos; a&apos;, c=&apos; a\ 0&apos;, c=&apos; a\ 0\ 0&apos; from t;

最终结果是
a | 610000 | 0 | 0| 1
在保存BINARY值时，在值的最后填充&apos;0x00&apos;(零字节)以达到指定字符长度。</code></pre><p>对比</p>
<p><a href="https://www.cnblogs.com/zejin2008/p/6606120.html" target="_blank" rel="noopener">https://www.cnblogs.com/zejin2008/p/6606120.html</a></p>
<p><img src="https://pic.imgdb.cn/item/5f4653cc160a154a678b9c5a.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4653da160a154a678ba3cb.jpg" alt=""></p>
<h3 id="3-3-3-ENUM类型"><a href="#3-3-3-ENUM类型" class="headerlink" title="3.3.3 ENUM类型"></a>3.3.3 ENUM类型</h3><p>​    枚举类型，值范围在创建表时，需要显示指定，1~255个成员需要1个字节存储，255到65536个成员需要两个字节。</p>
<p>​    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t (gender enum(<span class="string">'M'</span>,<span class="string">'F'</span>));</span><br><span class="line">INSERT INTO t VALUES(<span class="string">' M'</span>),(<span class="string">' 1'</span>),(<span class="string">' f'</span>),( NULL);</span><br><span class="line">select * from t;</span><br><span class="line">| M|</span><br><span class="line">| M | </span><br><span class="line">| F|</span><br><span class="line">| NULL |</span><br></pre></td></tr></table></figure>

<p>​    enum忽略大小写，如果不在取值范围内，默认为第一个值。</p>
<h3 id="3-3-4-SET类型"><a href="#3-3-4-SET类型" class="headerlink" title="3.3.4 SET类型"></a>3.3.4 SET类型</h3><p>​    和ENUM类型类似，也是一个字符串对象，可以包含0~64成员</p>
<ul>
<li>1~8成员 1字节</li>
<li>9~16 2字节</li>
<li>17~24 3字节</li>
<li>25~32 4字节</li>
<li>33~64 8字节</li>
</ul>
<p>​    区别在于SET类型可以一次选取多个成员</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Create table t (col <span class="built_in">set</span>（<span class="string">' a'</span>,<span class="string">' b'</span>,<span class="string">' c'</span>,<span class="string">' d'</span>）; </span><br><span class="line">insert into t values(<span class="string">' a, b'</span>),(<span class="string">' a, d, a'</span>),(<span class="string">' a, b'</span>),(<span class="string">' a, c'</span>),(<span class="string">' a'</span>);</span><br><span class="line">select * from t; </span><br><span class="line">+------+ </span><br><span class="line">| col | </span><br><span class="line">+------+ </span><br><span class="line">| a, b | </span><br><span class="line">| a, d | </span><br><span class="line">| a, b | </span><br><span class="line">| a, c | </span><br><span class="line">| a |</span><br></pre></td></tr></table></figure>

<p>​    只允许插入允许的值，多个值合并为一个值。</p>
<h2 id="3-4-JSON类型"><a href="#3-4-JSON类型" class="headerlink" title="3.4 JSON类型"></a>3.4 JSON类型</h2><p>​    从5.7.8之后支持</p>
<ul>
<li>插入时会自动校验数据是否json格式，不是就报错</li>
<li>提供了相关的内置函数吗，可以方便地提取各类数据，可以修改特定的值</li>
<li>优化存储格式，存储在json格式中的数据会被转换成内部的存储格式，允许快速读取。</li>
</ul>
<p>​    支持的数据类型包括NUMBER、STRING、BOOLEAN、NULL、ARRAYA、OBJECT 6种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&quot;abc&quot;, 10, null, true, false]</span><br><span class="line">&#123;&quot;k1&quot;: &quot;value&quot;, &quot;k2&quot;: 10&#125;</span><br><span class="line">[99, &#123;&quot;id&quot;: &quot;hk500&quot;, &quot;cost&quot;: 75.99&#125;]</span><br></pre></td></tr></table></figure>

<p>常见null,true,false必须小写才合法，’null’, ‘false’合法, ‘NULL’或者’FALSE’不合法。</p>
<p>如果要包含单引号或者双引号，需要反斜线转义。</p>
<p>json不可有默认值，最大长度取决于max_allowed_packet(存储时限制，内存中计算允许超过该值)。</p>
<h1 id="第4章-MySQL中的运算符"><a href="#第4章-MySQL中的运算符" class="headerlink" title="第4章 MySQL中的运算符"></a>第4章 MySQL中的运算符</h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h2><p><img src="https://pic.imgdb.cn/item/5f465937160a154a678e5f3d.jpg" alt=""></p>
<p>​    在除法和模运算中，如果除数为0，返回结果为NULL。</p>
<p>​    模运算可以用MOD(a,b)函数。</p>
<h2 id="4-2-比较运算符"><a href="#4-2-比较运算符" class="headerlink" title="4.2 比较运算符"></a>4.2 比较运算符</h2><p><img src="https://pic.imgdb.cn/item/5f4659ce160a154a678eb77e.jpg" alt=""></p>
<p>​    注意：NULL不能用=比较</p>
<h2 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h2><p><img src="https://pic.imgdb.cn/item/5f465a5e160a154a678f074f.jpg" alt=""></p>
<ul>
<li>逻辑非，当操作数为0返回1,1返回0，NULL返回NULL</li>
<li>逻辑与，操作数有一个为NULL就为NULL</li>
<li>逻辑或，两个全为NULL，或者有一个为NULL其他全是0，结果为NULL。</li>
<li>逻辑异或，有NULL则返回NULL。</li>
</ul>
<h2 id="4-4-位运算符"><a href="#4-4-位运算符" class="headerlink" title="4.4 位运算符"></a>4.4 位运算符</h2><p>​    <img src="https://pic.imgdb.cn/item/5f465c78160a154a67901409.jpg" alt=""></p>
<p>​    是将给定的操作数转换成二进制进行计算</p>
<h2 id="4-5-运算符优先级"><a href="#4-5-运算符优先级" class="headerlink" title="4.5 运算符优先级"></a>4.5 运算符优先级</h2><p><img src="https://pic.imgdb.cn/item/5f465d5b160a154a67908550.jpg" alt=""></p>
<h1 id="第5章-常用函数"><a href="#第5章-常用函数" class="headerlink" title="第5章 常用函数"></a>第5章 常用函数</h1><h2 id="5-1-字符串函数"><a href="#5-1-字符串函数" class="headerlink" title="5.1 字符串函数"></a>5.1 字符串函数</h2><p><img src="https://pic.imgdb.cn/item/5f47a459160a154a6766008e.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f47a466160a154a67660473.jpg" alt=""></p>
<h2 id="5-2-数值函数"><a href="#5-2-数值函数" class="headerlink" title="5.2 数值函数"></a>5.2 数值函数</h2><p><img src="https://pic.imgdb.cn/item/5f47a4a1160a154a676616a5.jpg" alt=""></p>
<h2 id="5-3-日期和时间函数"><a href="#5-3-日期和时间函数" class="headerlink" title="5.3 日期和时间函数"></a>5.3 日期和时间函数</h2><p><img src="https://pic.imgdb.cn/item/5f47a4ef160a154a67662cf9.jpg" alt=""></p>
<p>DATE_FORMAT的fmt的时间格式。</p>
<p><img src="https://pic.imgdb.cn/item/5f47a583160a154a676659af.jpg" alt=""></p>
<p>​    DATE_ADD(date, INTERVAL exptr type)函数。其中INTERVAL是间隔类型关键字，expr是一个表达式，type是间隔类型。</p>
<p>​    MySQL的日期间隔类型</p>
<p><img src="https://pic.imgdb.cn/item/5f47a696160a154a6766ae6a.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select now(), date_add(now(), INTERVAL 31 day), date_add(now(), INTERVAL &#39;1_2&#39; year_month);</span><br></pre></td></tr></table></figure>

<h2 id="5-4-流程函数"><a href="#5-4-流程函数" class="headerlink" title="5.4 流程函数"></a>5.4 流程函数</h2><p><img src="https://pic.imgdb.cn/item/5f47a757160a154a6766e93c.jpg" alt=""></p>
<h2 id="5-5-JSON函数"><a href="#5-5-JSON函数" class="headerlink" title="5.5 JSON函数"></a>5.5 JSON函数</h2><p><img src="https://pic.imgdb.cn/item/5f47a8a4160a154a6767537b.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f47a82b160a154a67672ee8.jpg" alt=""></p>
<h2 id="5-6-窗口函数"><a href="#5-6-窗口函数" class="headerlink" title="5.6 窗口函数"></a>5.6 窗口函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ROW_NUMBER()</td>
<td>分区中的行号</td>
</tr>
<tr>
<td>RANK()</td>
<td>当前行在分区中的排名，含序号间隙</td>
</tr>
<tr>
<td>DEMSE_RANK()</td>
<td>当前行在分区中的排名，无序号间隙</td>
</tr>
<tr>
<td>PERCENT_RANK()</td>
<td>百分比等级值</td>
</tr>
<tr>
<td>CUME_DIST()</td>
<td>累计分配值</td>
</tr>
<tr>
<td>FIRST_VALUE()</td>
<td>窗口中第一行的参数值</td>
</tr>
<tr>
<td>LAST_VALUE()</td>
<td>窗口中最后一行的参数值</td>
</tr>
<tr>
<td>LAG()</td>
<td>分区中指定行落后于当前行的参数值</td>
</tr>
<tr>
<td>LEAD()</td>
<td>分区中领先当前行的参数值</td>
</tr>
<tr>
<td>NTH_VALUE()</td>
<td>从第N行窗口框架的参数值</td>
</tr>
<tr>
<td>NTILE()</td>
<td>分区中当前行的桶号</td>
</tr>
</tbody></table>
<h2 id="5-7-其他常用函数"><a href="#5-7-其他常用函数" class="headerlink" title="5.7 其他常用函数"></a>5.7 其他常用函数</h2><p><img src="https://pic.imgdb.cn/item/5f47aa85160a154a6767d6b2.jpg" alt=""></p>
<h1 id="第二部分-开发篇"><a href="#第二部分-开发篇" class="headerlink" title="第二部分 开发篇"></a>第二部分 开发篇</h1><h1 id="第6章-表类型-存储引擎-的选择"><a href="#第6章-表类型-存储引擎-的选择" class="headerlink" title="第6章 表类型(存储引擎)的选择"></a>第6章 表类型(存储引擎)的选择</h1><h2 id="6-1-MySQL存储引擎概述"><a href="#6-1-MySQL存储引擎概述" class="headerlink" title="6.1 MySQL存储引擎概述"></a>6.1 MySQL存储引擎概述</h2><p>​    5.5版本之前默认是MyISAM，之后是InnoDB。</p>
<p>​    通过修改参数文件的default_storage_engine调整引擎。</p>
<p>​    MySQL5.7支持的引擎有InnoDB，MyISAM，MEMORY, CSV, BLACKHOLE, ARCHIVE, MERGE(MRG_MyISAM), FEDERATED, EXAMPLE, NDB等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前默认引擎</span></span><br><span class="line">show variables <span class="string">'default_storage_engine'</span></span><br><span class="line"><span class="comment"># 查询当前数据库支持的存储引擎</span></span><br><span class="line">show engines </span><br><span class="line"><span class="comment"># 修改某个表的存储引擎</span></span><br><span class="line">atler table ai engine = innodb</span><br></pre></td></tr></table></figure>

<h2 id="6-2-各种存储引擎的特性"><a href="#6-2-各种存储引擎的特性" class="headerlink" title="6.2 各种存储引擎的特性"></a>6.2 各种存储引擎的特性</h2><p><img src="https://pic.imgdb.cn/item/5f47adca160a154a6768d9ba.jpg" alt=""></p>
<h3 id="6-2-1-MyISAM"><a href="#6-2-1-MyISAM" class="headerlink" title="6.2.1 MyISAM"></a>6.2.1 MyISAM</h3><p>​    不支持事务、外键。某些场景相对InnoDB访问速度有明显优势。对事务完整性没有要求或者以SELECT、INSERT为主的表可以使用这个引擎来创建表。</p>
<p>​    在磁盘上存储为三个文件，文件名与表名都相同</p>
<ul>
<li>.frm(存储表定义)</li>
<li>.MYD(MYData, 存储数据)</li>
<li>.MYI(MyIndex，存储索引)</li>
</ul>
<p>​    数据文件和索引文件可以防止在不同的目录，平均分布IO，获得更快速度。</p>
<p>​    要指定索引文件和数据文件路径，在创建表时，通过DATA DIRECTORY和INDEX DIRECTORY语句指定。路径需要绝对路径，并且具有访问权限。</p>
<p>​    表可能损坏，损坏后不可访问，需要按提示需要球服或返回访问错误的结果。提供修复工具，可以用CHECK TABLE语句来检查MyISAM表的健康，并用 REPAIR TABLE 语句修复一个损坏的表。</p>
<p>​    表支持三种不同格式</p>
<ul>
<li>静态(固定长度)表</li>
<li>动态表</li>
<li>压缩表</li>
</ul>
<p>​    其中，静态表是默认存储格式，字段都是非边长字段，每个记录都是固定长度。有点事存储迅速，容易缓存，故障易修复，缺点是占用空间更大。会填补空格，并且应用之前去掉空格，如果结尾存储了有空格的数据，应用时会被去掉。</p>
<h3 id="6-2-2-InnoDB"><a href="#6-2-2-InnoDB" class="headerlink" title="6.2.2 InnoDB"></a>6.2.2 InnoDB</h3><p>​    具有提交、回滚和崩溃恢复能力的事务安全保障，提供了更小的锁粒度和更强的并发能力。</p>
<p>​    会比MyISAM占用更多的磁盘以保留数据和索引。</p>
<h4 id="1-自动增长列"><a href="#1-自动增长列" class="headerlink" title="1.自动增长列"></a>1.自动增长列</h4><p>​    自动增长列可以手动插入，但是如果为空，插入的值是自动增长的值。</p>
<p>​    MySQL8之前，重启后，会将自增列设置为当前存储的最大值+1</p>
<p>​    之后得到了修复，实现方式是将自增逐渐的计数器持久化到REDO LOG中，每次计数器发生变化吗，都会将其写入到REDO LOG。重启后，从REDO LOG取值。</p>
<p>​    可以使用LAST_INSERT_ID()查询最后插入记录使用的值，如果人为指定，那么LASTE_INSERT_ID()不会更新。</p>
<h4 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2.外键约束"></a>2.外键约束</h4><p>​    只有innodb支持外键，创建外键，要求父表必须有对应索引。子表创建时，也会自动创建对应的索引。</p>
<p>​    在创建索引时，可以指定删除、更新父表，对字表进行的想要操作，包括RESTRICT、CASCADE, SET NULL和NO ACTION。其中RESTRICT和NO ACTION相同，是指限制字表有关联记录的情况下父表不能更新。</p>
<p>​    CASCADE在父表进行更新或删除时，更新或删除字表对应记录；</p>
<p>​    SET_NULL 代表父表在更新或删除时，字表对应的字段被设置为NULL。</p>
<p>​    选择后两种方式要谨慎，可能会因为错误的操作导致数据的丢失。</p>
<p>​    如果导入多个表的数据，可以暂时先忽略外键检查，SET FOREIGN_KEY_CHECKS = 0,执行完成后，执行 SET FOREIGN_KEY_CHECKS = 1恢复原状态。</p>
<h4 id="3-主键和索引"><a href="#3-主键和索引" class="headerlink" title="3.主键和索引"></a>3.主键和索引</h4><p>​    InnoDB的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引也被称为主索引，而且也是表的主键，表的每行数据保存在主索引的叶子节点上。因此，所有表都必须包含主键。如果没有显示指定主键，会自动创建一个长度为6个字节的long类型的隐藏字段作为主键。</p>
<p>​    主键选择原则：</p>
<ul>
<li>满足唯一和非空约束</li>
<li>优先考虑使用最经常被当作查询条件的字段或自增字段</li>
<li>字段值基本不会被修改</li>
<li>尽可能使用短的字段。</li>
</ul>
<p>​    除主键外，其他索引都叫作辅助索引或者二级索引。二级索引会指向主索引，并通过主索引获取最终的数据。</p>
<h4 id="4-存储方式"><a href="#4-存储方式" class="headerlink" title="4.存储方式"></a>4.存储方式</h4><p>​    两种：</p>
<ul>
<li>使用共享表空间存储：表结构放在.frm文件中，数据和索引保存在inno_data_home_dir和inno_data_file_path定义的表空间中，可以使多个文件。</li>
<li>使用多表空间存储：这种方式创建的表的表结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中。如果是一个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区时指定每个分区的数据文件的位置，以此分布IO在不同的多个磁盘上。</li>
</ul>
<p>​    共享表空间时，随着数据增长，表空间维护会愈来愈困难。所以都建议使用多表空间。设置参数innodb_file_per_table，默认设置为ON。</p>
<h3 id="6-2-3-MEMORY"><a href="#6-2-3-MEMORY" class="headerlink" title="6.2.3 MEMORY"></a>6.2.3 MEMORY</h3><p>​    只对应一个文件.frm，索引默认使用HASH索引，一旦服务关闭，数据丢失。</p>
<p>​    在启动时选择使用的–init-file选项， 可以在服务启动时就从持久稳固的数据源装载表。</p>
<p>​    需要足够内存来维持所有在同一时间使用的MEMORY表，不需要就删除。</p>
<p>​    表大小收到max_heap_table_size系统变量约束，初始值是16MB，创建表通过MAX_ROWS指定表的最大行数。</p>
<p>​    主要用于变化不频繁的代码表，或者作为统计操作中间表。便于高效地对中间结果进行分析并得到最终的统计结果。</p>
<h3 id="6-2-4-MERGE"><a href="#6-2-4-MERGE" class="headerlink" title="6.2.4 MERGE"></a>6.2.4 MERGE</h3><p>​    暂略</p>
<h3 id="6-2-5-TokuDB"><a href="#6-2-5-TokuDB" class="headerlink" title="6.2.5 TokuDB"></a>6.2.5 TokuDB</h3><p>​    略</p>
<h2 id="6-3-如何选择合适的存储引擎"><a href="#6-3-如何选择合适的存储引擎" class="headerlink" title="6.3 如何选择合适的存储引擎"></a>6.3 如何选择合适的存储引擎</h2><p>​    暂略</p>
<h1 id="第7章-选择合适的数据类型"><a href="#第7章-选择合适的数据类型" class="headerlink" title="第7章 选择合适的数据类型"></a>第7章 选择合适的数据类型</h1><p>​    </p>
<h2 id="7-1-CHAR和VARCHAR"><a href="#7-1-CHAR和VARCHAR" class="headerlink" title="7.1 CHAR和VARCHAR"></a>7.1 CHAR和VARCHAR</h2><p>​    <img src="https://pic.imgdb.cn/item/5f49a6b7160a154a67e55484.jpg" alt=""></p>
<p>​    最后一行的值只用于MySQL，如果非严格模式，超过列长度的值将不会保存。如果是严格模式，则会提示错误。</p>
<p>​    CHAR是固定长度，所以处理速度会快很多，但是随着MySQL不断升级，VARCHAR类型的性能也在不断改进和提高，所以VARCHAR类型被更多地使用。</p>
<p>​    不同引擎使用的原则有所不同。</p>
<p>​    MyISAM：建议使用CHAR</p>
<p>​    MEMORY：都使用固定长度的数据航，所以没区别，都当成CHAR处理。</p>
<p>​    InnoDB：建议使用VARCHAR。内部行存储格式没有区别固定长度和可变长度，所以固定长度不一定比使用可变长度VARCHAR列性能要好。</p>
<h2 id="7-2-TEXT和BLOB"><a href="#7-2-TEXT和BLOB" class="headerlink" title="7.2 TEXT和BLOB"></a>7.2 TEXT和BLOB</h2><p>​    BLOB能用来保存二进制数据，比如照片，TEXT只能保存字符数据，比如一篇文章或者日记。</p>
<p>​    TEXT和BLOB又分为TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT</p>
<p>​    和TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB</p>
<p>​    1.两者删除会引起一些性能问题，特别是执行大量地删除操作的时候</p>
<p>​    会在数据表留下很大的空洞，以后填入这些空洞的记录在插入的性能上会有影响。为了提高性能，建议定期使用</p>
<p>​    OPTIMIZE TABLE功能对这类表进行碎片整理。</p>
<p>​    对于InnoDB，OPTIMIZE语句被优化为recreate+analyze语句。</p>
<p>​    2.可以使用合成的索引大大提高大文本的查询性能。</p>
<p>​    简单地说就是根据大文本的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过搜索散列值找到数据行了，只能用于精确匹配。</p>
<p>​    MySQL提供了前缀索引的功能，就是只为字段的前n列创建索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_blob on t(conext(100));</span><br></pre></td></tr></table></figure>

<p>​    查询时，%不能放在最前面，否则索引不可用、</p>
<p>​    3.在不必要时避免检索大型的BLOB和TEXT值。</p>
<p>​    例如 SELECT * 就不是很好的想法，除非能够确定WHERE子句只会找到所需要的行。</p>
<p>​    4.把BLOB和TEXT列分离到单独的表中</p>
<p>​    这会减少主表的碎片，显著减少主表的数据列从而获得性能优势。</p>
<h2 id="7-3-浮点数与定点数"><a href="#7-3-浮点数与定点数" class="headerlink" title="7.3 浮点数与定点数"></a>7.3 浮点数与定点数</h2><p>​    浮点数在插入时如果超过了该列定义的实际精度，会被四舍五入到实际定义的值。float和double(或real)来表示浮点数。</p>
<p>​    定点数不同于浮点数，实际上是以字符串形式存放的，可以更精确地表示数据。如果实际插入的精度大于定义的精度，会进行警告（默认的SQLMode下），但是数据库按照实际地精度四舍五入后插入；如果SQLMode是TRADITIONAL，则系统会保存。decimal(或numberic)用来表示定点数。</p>
<h2 id="7-4日期类型选择"><a href="#7-4日期类型选择" class="headerlink" title="7.4日期类型选择"></a>7.4日期类型选择</h2><ul>
<li>如果只存年，那么就用YEAR类型，可以提高效率</li>
<li>如果需要记录年月日时分秒，并且记录的年份比较久远，最少使用DATETIME</li>
<li>如果记录的日期需要让不同时区使用，最好使用TIMESTAMP</li>
</ul>
<h1 id="第8章-字符集"><a href="#第8章-字符集" class="headerlink" title="第8章 字符集"></a>第8章 字符集</h1><h2 id="8-1-字符集概述"><a href="#8-1-字符集概述" class="headerlink" title="8.1 字符集概述"></a>8.1 字符集概述</h2><p>​    字符集就是一套文字符号及其编码、比较规则的集合。</p>
<h2 id="8-2-Unicode简述"><a href="#8-2-Unicode简述" class="headerlink" title="8.2 Unicode简述"></a>8.2 Unicode简述</h2><p>​    为了统一字符编码，国际标准组织在1984年创造了UCS，标准编号则定位了ISO-10646，采用4字节(32bit)编码，因此简称UCS-4。</p>
<p>​    具体规则是将代码空间分为组，面，行，格。1到4字节分别代表组，面，行，格。并且规定第32位必须为0，每个面的最后两个码位FFFEh和FFFFh保留不用。因此共有128个群组，每个群组有256个面，每个面有256行，每行包括256格。发布后就遭到了部分美国公司反对。</p>
<p>​    1988年，Xerox公司提议指定新的以16位编码的统一字符集Unicode，并且联合各大公司成立Unicode协会，并成立Unicode技术委员会，专门负责Unicode文字收集、整理和编码，并于1991年推出了Unicode1.0。</p>
<p>​    两套编码不利，1991年10月达成协议，Unicode并入ISO-10646的0组0面。称之为基本多语言字面(BMP)。</p>
<p>​    大部分用户使用BMP就够用了。早期ISO标准只要求实现BMP字面，那么只需要两个字节来编码就够了，Unicode也就是这么做的，称为UCS-2。</p>
<p>​    绝大部分情况下，Unicode都能满足要求，而且在节省内存和处理时间上都有又是。</p>
<p>​    如果要使用BMP以外的文字怎么办，Unicode提出了名为UTF-16或代理法的解决方案。对BMP编码保持两字节不变，对其他字面的文字按一定规则将32位转换成两个16位的Unicode编码。</p>
<h2 id="8-3-汉字常见的一些字符集"><a href="#8-3-汉字常见的一些字符集" class="headerlink" title="8.3 汉字常见的一些字符集"></a>8.3 汉字常见的一些字符集</h2><ul>
<li>GB 2312-80: 6763个汉字和683个非汉字图形符号</li>
<li>GB 13000: 27484个汉字以及一些偏旁部首等，但是没有业界支持，形式上的标准。</li>
<li>GBK</li>
<li>GB 18030: 采用2或4字节编码，2字节部分与GBK一致，是GBK的超集。</li>
</ul>
<h2 id="8-4-选择合适的字符集"><a href="#8-4-选择合适的字符集" class="headerlink" title="8.4 选择合适的字符集"></a>8.4 选择合适的字符集</h2><p>​    Mysql5.7支持几十种字符集包括UCS-2, UTF-16, UFT-8, UTF-16LE, UTF-32等字符集。</p>
<ol>
<li>满足不同国家和地区的需求，应该选择Unicode字符集，最常用的就是UTF-8。更严谨的说法是编码规则是UTF-8， 其中utf8mb3和utf8mb4是最常用的两个字符集，MySQL8.0，默认字符集已经又latin1变为utf8mb4。</li>
<li>如果涉及到已有数据导入，就要充分考虑数据库字符集对已有数据的兼容性。</li>
<li>数据库只需要支持一般中文，而且数据量很大，性能要求也很高，可以使用GBK。如果应用主要处理英文字符，仅有少量汉字数据，那么UTF-8更好。</li>
<li>如果数据库需要做大量的字符运算，比如比较、排序，定长字符集更好。</li>
<li>如果所有客户端都支持相同的字符集，应该优先选择该字符集作为数据字符集。</li>
</ol>
<h2 id="8-5-MySQL支持的字符集简介"><a href="#8-5-MySQL支持的字符集简介" class="headerlink" title="8.5 MySQL支持的字符集简介"></a>8.5 MySQL支持的字符集简介</h2><p>​    支持多种字符集，同一台服务器、同一个数据库、甚至同一张表的不同字段都可以指定使用不同的字符集。</p>
<p>​    查看所有字符集的命令是show character set;</p>
<p>​    或者查看information_schema.character_set，可以显示所有的字符集和该字符集默认的排序规则。</p>
<p>​    MySQL字符集包括字符集和排序规则两个概念，字符集和排序规则是一对多的概念，支持30多种字符集和70多种排序规则。</p>
<p>​    每个字符集至少对应一个排序规则，可以使用SHOW COLLATION LIKE ‘***’命令或者通过系统表information_schema.COLLATIONS查看相关字符集的排序规则。</p>
<h2 id="8-6-MySQL数据集的设置"><a href="#8-6-MySQL数据集的设置" class="headerlink" title="8.6 MySQL数据集的设置"></a>8.6 MySQL数据集的设置</h2><h3 id="8-6-1-服务器字符集和排序规则"><a href="#8-6-1-服务器字符集和排序规则" class="headerlink" title="8.6.1 服务器字符集和排序规则"></a>8.6.1 服务器字符集和排序规则</h3><ul>
<li><p>在my.conf设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">character-set-server&#x3D;utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动项中指定</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --character-set-server&#x3D;utf8</span><br></pre></td></tr></table></figure>

<ul>
<li>或者在编译时指定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake . -DDEFAULT-CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<p>可以使用show variables like ‘character_set_server’</p>
<p>show variables like ‘collation_server’</p>
<p>查看当前服务器字符集和排序规则。</p>
<h3 id="8-6-2-数据库字符集和排序规则"><a href="#8-6-2-数据库字符集和排序规则" class="headerlink" title="8.6.2 数据库字符集和排序规则"></a>8.6.2 数据库字符集和排序规则</h3><ul>
<li>如果指定了字符集和排序规则，则使用指定的字符集和排序规则</li>
<li>如果都没有指定，则使用默认</li>
<li>如果只指定了字符集，则使用该字符的默认排序规则</li>
<li>如果只指定的排序规则，使用该规则对应的字符集</li>
</ul>
<p>​    推荐在创建数据库是明确指定字符集和排序规则，避免受到默认值影响。</p>
<p>​    显示当前数据库的字符集和排序规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;character_set_database&#39;</span><br><span class="line"></span><br><span class="line">show variables like &#39;collation_database&#39;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-3-表字符集和排序规则"><a href="#8-6-3-表字符集和排序规则" class="headerlink" title="8.6.3 表字符集和排序规则"></a>8.6.3 表字符集和排序规则</h3><p>创建表时，添加如下语句</p>
<p><img src="https://pic.imgdb.cn/item/5f49b76a160a154a67e9a32e.jpg" alt=""></p>
<h3 id="8-6-4-列字符集和校对规则"><a href="#8-6-4-列字符集和校对规则" class="headerlink" title="8.6.4 列字符集和校对规则"></a>8.6.4 列字符集和校对规则</h3><p>​    一般不设置，只是MySQL提供的灵活设置手段，可以在创建表时指定或者修改表时调整。</p>
<h3 id="8-6-5-连接字符集和校对规则"><a href="#8-6-5-连接字符集和校对规则" class="headerlink" title="8.6.5 连接字符集和校对规则"></a>8.6.5 连接字符集和校对规则</h3><p>​    以上4中设置方式，确定的是数据保存的字符集和校对隔着，对于实际应用访问，还存在客户端与服务器之间交互的字符集和校对规则的设置。</p>
<p>​    提供了3个不同的参数</p>
<p>​    character_set_client</p>
<p>​    character_set_connection</p>
<p>​    character_set_results。</p>
<p>​    代表客户端、连接和返回结果的字符集。</p>
<p>​    通常应该相同，才可以确保用户写入数据的正确读出。</p>
<h2 id="8-7-字符集的修改步骤"><a href="#8-7-字符集的修改步骤" class="headerlink" title="8.7 字符集的修改步骤"></a>8.7 字符集的修改步骤</h2><p>​    如果再开始阶段没有正确设置字符集，需要调整，不能直接通过</p>
<p>​    alter database character set ***或者 </p>
<p>​    alter table character set ***进行。</p>
<p>​    这两个命令都没有更新已有记录的字符集</p>
<p>​    以下是模拟latin1字符集修改成GBK字符集的过程</p>
<p>​    1.导出表结构</p>
<p>​    mysqldump -uroot -p –default-character-set=gbk -d databasename&gt;createtable.sql</p>
<p>​    -d代表只导出表结构不导出数据</p>
<p>​    2.手工修改createtable.sql中表结构定义中的字符集为新的字符集。</p>
<p>​    3.确保记录不再更新，导出所有记录</p>
<pre><code>mysqldump -uroot -p --quick --no- create- info --extended- insert --default- character- set= latin1 databasename&gt; data. sql</code></pre><p><img src="https://pic.imgdb.cn/item/5f49ba1d160a154a67ea5a4c.jpg" alt=""></p>
<p>4.打开data.sql， 将SET NAMES latin1修改为 SET NAMES gbk</p>
<p>5.使用新的数据集创建新的数据库</p>
<pre><code>create database databasename default charset gbk;</code></pre><p>6.创建表，执行createtab.sql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p databasename &lt; createtab. sql</span><br></pre></td></tr></table></figure>

<p>7.导入数据，执行data.sql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p databasename &lt; data. sql</span><br></pre></td></tr></table></figure>

<h1 id="第9章-索引的设计和使用"><a href="#第9章-索引的设计和使用" class="headerlink" title="第9章 索引的设计和使用"></a>第9章 索引的设计和使用</h1><h2 id="9-1-索引概述"><a href="#9-1-索引概述" class="headerlink" title="9.1 索引概述"></a>9.1 索引概述</h2><p>​    根据引擎可以定义每个表的最大索引数和最大索引长度，每种引擎对每个表至少支持16个索引，总索引长度至少为256字节。大多数存储索引有更高的限制。</p>
<p>​    MyISAM和InnoDB默认创建的都是BTREE索引。MySQL5.7以后可以通过虚拟列索引来实现函数索引的功能，通识MySQL也支持前缀索引，即对索引字段的前N个字符创建索引。</p>
<p>​    对于MyISAM引擎，索引长度可以到达1000字节长，而InnoDB，最长是3072字节。注意，前缀的限制应该以字节为单位进行测量。CREATE TABLE语句中的前缀长度解释为字符数。</p>
<p>​    还支持全文本索引，该索引可以用于全文搜索，MySQL5.6之后，以上两个引擎都支持FUULTEXT索引，但只限于CHAR,VARCHAR和TEXT列。索引总是对整个列进行的，不支持局部索引。</p>
<p>​    也可以对空间列类型创建索引，MySQL5.7之前只有MyISAM支持，后面版本InnoDB也支持，索引以R-Trees的数据结构保存。</p>
<p>​    默认情况下,MEMORY存储引擎使用HASH索引，但也支持BTREE索引。</p>
<p>​    可以在新建表是设置索引，也可以单独添加。</p>
<p><img src="https://pic.imgdb.cn/item/5f49c157160a154a67ec6d28.jpg" alt=""></p>
<p>​    也可以通过ALTER TABLE的形式进行添加。</p>
<h2 id="9-2-设计索引的原则"><a href="#9-2-设计索引的原则" class="headerlink" title="9.2 设计索引的原则"></a>9.2 设计索引的原则</h2><ul>
<li>在条件列上创建索引</li>
<li>尽量使用唯一索引，索引值分布越大，效果越好。例如性别等只有F和M的列，不需要索引。</li>
<li>使用短索引，对字符串进行索引，应该指定一个索引长度，如果一个CHAR(200)列，如果只在前10个到20个字符内，多数值是唯一的，就不要对整个列进行索引。也会使查询更快，占用空间更小，索引高速缓存中的块能容纳更多的键值。</li>
<li>利用最左前缀。创建一个n列的索引，实际创建了看MySQL可利用的n个索引。可以起到几个索引的作用，因为可利用索引中最左边的列集来匹配行，这些列集称为最左前缀。比如创建了a,b,c的组合索引，那么a=?或a=? and b = ? 或者a=? and b = ? and c = ?都可以使用这个索引。</li>
<li>对于InnoDB引擎的表，尽量手工指定主键，因为会按主键顺序保存，如果没有，但是有唯一索引，就按唯一索引保存，如果都没有，就会生成一个内部列，按这个顺序保存。按照主键或者内部列访问最快，所以尽量指定主键。可以选择最长访问的列作为主键，而且主键尽量选择较短的数据类型的列，有效减少索引的磁盘占用，提高索引缓存效果。</li>
</ul>
<h2 id="9-3-索引设计的误区"><a href="#9-3-索引设计的误区" class="headerlink" title="9.3 索引设计的误区"></a>9.3 索引设计的误区</h2><ul>
<li>不是所有表都需要创建索引，常见的代码表、配置表等数据量很小的表，除了主键，再创建表没有太大的意义。</li>
<li>不要过度索引，会给查询带来负担</li>
<li>谨慎创建低选择索引，对于选择性低并且数据分布均匀的列，索引效果不好。（MySQL8.0之后有一个直方图可以）</li>
</ul>
<h2 id="9-4-索引设计的一般步骤"><a href="#9-4-索引设计的一般步骤" class="headerlink" title="9.4 索引设计的一般步骤"></a>9.4 索引设计的一般步骤</h2><ul>
<li>整理表上所有SQL的WHERE条件所用到的列组合、关联查询的关联条件</li>
<li>整理所有SQL的预期执行频率</li>
<li>整理所有涉及列的选择度</li>
<li>遵照之前提到的设计原则，给表选择合适的主键</li>
<li>优先给那么执行频率最高的SQL创建索引。</li>
<li>按执行频率排序，检查是否有必要为每个SQL创建索引</li>
<li>索引和并，利用复合索引降低索引的总数</li>
<li>上线之后，通过慢查询分析、执行计划分析、索引使用统计，来确定索引的使用情况。</li>
</ul>
<h2 id="9-5-BTREE索引与HASH索引"><a href="#9-5-BTREE索引与HASH索引" class="headerlink" title="9.5 BTREE索引与HASH索引"></a>9.5 BTREE索引与HASH索引</h2><p>​    HASH索引有一些重要特征：</p>
<ul>
<li>只用于=或者&lt;=&gt;操作符的等式比较</li>
<li>优化器不能使用HASH索引来加速ORDER BY等操作</li>
<li>MySQL不能确定两个值之间大约有多少行。如果将一个MyISAM的表改为HASH索引的MEMORY表，会影响一些查询效率</li>
<li>只能使用整个关键字来索索一行。</li>
</ul>
<p>​    对于BTREE，当使用&gt;, &lt;, &gt;=, &lt;=, BETWEEN、!=或者&lt;&gt;，或者LIKE操作符时，都可以使用相关列上的索引。</p>
<h2 id="9-6-索引在MySQL8-0中的改进"><a href="#9-6-索引在MySQL8-0中的改进" class="headerlink" title="9.6 索引在MySQL8.0中的改进"></a>9.6 索引在MySQL8.0中的改进</h2><h3 id="9-6-1-不可见索引"><a href="#9-6-1-不可见索引" class="headerlink" title="9.6.1 不可见索引"></a>9.6.1 不可见索引</h3><p>​    可以创建索引时通过invisible设置不可见，这个就是对查询优化器不可见。</p>
<p>​    目的是为了减少对表上索引进行调整时的潜在风险。如果删除一个大表索引，应该设置为不可见，然后看是否有很大影响，就可以很方便地恢复回去。</p>
<h3 id="9-6-2-倒序索引"><a href="#9-6-2-倒序索引" class="headerlink" title="9.6.2  倒序索引"></a>9.6.2  倒序索引</h3><p>​    可以创建索引时指定倒序，相对于Oracle的倒序索引对查询的优化效果，MySQL的作用还是比较弱。由于引入倒序索引group by的隐式排序的特性取消了，要注意。</p>
<h1 id="第10章-开发常用数据库对象"><a href="#第10章-开发常用数据库对象" class="headerlink" title="第10章 开发常用数据库对象"></a>第10章 开发常用数据库对象</h1><h2 id="10-1-视图"><a href="#10-1-视图" class="headerlink" title="10.1 视图"></a>10.1 视图</h2><h3 id="10-1-1-什么是视图"><a href="#10-1-1-什么是视图" class="headerlink" title="10.1.1 什么是视图"></a>10.1.1 什么是视图</h3><pre><code>视图是一种虚拟存在的表。</code></pre><ul>
<li>简单：使用视图的用户不需要管理后面对应表的结构</li>
<li>安全：使用视图的用户只能访问他们被允许查询的结果集</li>
<li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列可以通过修改视图来解决，不会造成访问者的影响</li>
</ul>
<h3 id="10-1-2-视图操作"><a href="#10-1-2-视图操作" class="headerlink" title="10.1.2 视图操作"></a>10.1.2 视图操作</h3><pre><code>包括创建、修改、删除和查看视图定义。</code></pre><h3 id="10-1-3-创建或修改视图"><a href="#10-1-3-创建或修改视图" class="headerlink" title="10.1.3 创建或修改视图"></a>10.1.3 创建或修改视图</h3><p>如果要用CREATE OR REPLACE 或者ALTER，还需要有DROP视图的权限。</p>
<p><img src="https://pic.imgdb.cn/item/5f4af50e160a154a674d3812.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4af534160a154a674d453b.jpg" alt=""></p>
<pre><code>5.7.7版本之前，FROM关键字后面不能包含子查询。

视图可更新性和视图中查询定义有关：</code></pre><ul>
<li>包含以下关键字的SQL语句，聚合函数,DISTINCT,GROUP BY, HAVING, UNION, UNION ALL</li>
<li>常量视图</li>
<li>JOIN</li>
<li>FROM一个不能更新的视图</li>
<li>WHERE的子查询应用了FROM语句中的表。</li>
</ul>
<p>其中WITH [CASCADED | LOCAL] CHECK OPTION决定了是否允许更新数据使记录不再满足视图的条件。</p>
<ul>
<li><p>LOCAL:只要满足本视图的条件就可以更新</p>
</li>
<li><p>CASCADED：必须满足所有针对盖世兔的所有视图的条件才可以更新。</p>
<p>  默认是CASCADED。</p>
</li>
</ul>
<h3 id="10-1-4-删除视图"><a href="#10-1-4-删除视图" class="headerlink" title="10.1.4 删除视图"></a>10.1.4 删除视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] view_ name [, view_ name] . .[RESTRICT | CASCADE]</span><br></pre></td></tr></table></figure>

<p>在使用SHOW TABLE STATUS，不仅可以显示表的信息，同时也可以显示视图的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS [FROM DB_NAME] [LIKE &#39;pattern&#39;]</span><br></pre></td></tr></table></figure>



<p>使用SHOW CREATE VIEW进行视图定义查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create view staff_list</span><br></pre></td></tr></table></figure>

<p>最后，通过查看系统表information_schema.views也可以查看视图的相关信息。</p>
<h2 id="10-2-存储过程和函数"><a href="#10-2-存储过程和函数" class="headerlink" title="10.2 存储过程和函数"></a>10.2 存储过程和函数</h2><p>​    5.0版本开始支持存储过程和函数。</p>
<h3 id="10-2-1-什么是存储过程和函数"><a href="#10-2-1-什么是存储过程和函数" class="headerlink" title="10.2.1 什么是存储过程和函数"></a>10.2.1 什么是存储过程和函数</h3><p>​    是事先经过编译并分出在数据库中的一段SQL语句的集合。</p>
<p>​    存储过程和函数的却别在于函数必须有返回值。</p>
<h3 id="10-2-2-存储过程和函数的相关操作"><a href="#10-2-2-存储过程和函数的相关操作" class="headerlink" title="10.2.2 存储过程和函数的相关操作"></a>10.2.2 存储过程和函数的相关操作</h3><p>​    创建存储过程和函数需要CREATE ROUNTE权限，修改删除需要 ALTER ROUTE权限。执行存储过程需要EXECUTE权限。</p>
<h3 id="10-2-3-创建、修改存储过程或者函数"><a href="#10-2-3-创建、修改存储过程或者函数" class="headerlink" title="10.2.3 创建、修改存储过程或者函数"></a>10.2.3 创建、修改存储过程或者函数</h3><p>​    创建存储过程或函数的语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE sp_ name </span><br><span class="line">([proc_ parameter[,. .]])</span><br><span class="line">	[characteristic . .] routine_ body CREATE FUNCTION sp_ name </span><br><span class="line">	([func_ parameter[,. .]]) </span><br><span class="line">	RETURNS type </span><br><span class="line">	[characteristic . .] routine_ body</span><br><span class="line">proc_ parameter:</span><br><span class="line">[ IN | OUT | INOUT ] param_ name type</span><br><span class="line">func_ parameter: </span><br><span class="line">param_ name type </span><br><span class="line">type: </span><br><span class="line">Any valid MySQL data type</span><br><span class="line">characteristic:</span><br><span class="line">LANGUAGE SQL </span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; </span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125; </span><br><span class="line">| COMMENT &#39;string&#39; </span><br><span class="line">routine_ body: Valid SQL procedure statement or statements</span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; sp_ name [characteristic . .] </span><br><span class="line">characteristic: </span><br><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| COMMENT &#39;string&#39;</span><br></pre></td></tr></table></figure>



<p>调用语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL sp_name([parameter[,.  .]])</span><br></pre></td></tr></table></figure>



<p>MySQL的存储过程和函数允许DDL语句，也允许在存储过程中执行提交或者回滚，但是存储过程和函数中不允许执行LOAD DATA INFILE语句。其中可以调用其他的存储过程或函数。</p>
<p><img src="https://pic.imgdb.cn/item/5f4b998b160a154a677a8cf2.jpg" alt=""></p>
<p>​    通常在创建存储过程和函数之前，都会通过DELIMITER $$命令将语句的结束符从;修改为其他符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL film_ in_ stock( 2, 2,@ a);</span><br><span class="line">SELECT @a;</span><br></pre></td></tr></table></figure>



<p>characteristic特征值的部分进行简单的说明：</p>
<ul>
<li><p>LANGUAGE SQL: 说明下面的BODY是SQL编写的，为MySQL以后支持其他语言做准备</p>
</li>
<li><p>[NOT] DETERMINISTIC:  DETERMINISTIC确定的，即每次输入一样那么输出一样的程序，NOT DETERMINISTIC是不确定的，默认是非确定的。当前，这个值还没有被优化程序使用。</p>
</li>
<li><p>{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}: 这个特征值提供子程序使用数据的内在信息，这些特征值目前知识提供给服务器。CONTAINS SQL 表示 子程序 不 包含 读 或 写 数据 的 语句。NO SQL 表示 子程序 不 包含 SQL 语句。 READS SQL DATA 表示 子程序 包含 读 数据 的 语句，但不 包含 写 数据 的 语句。 MODIFIES SQL DATA 表示 子程序 包含 写 数据 的 语句。</p>
<p> 如果 这些 特征 没有 明确 给定， 默认 使 用的 值 是 CONTAINS SQL。</p>
</li>
</ul>
<ul>
<li>SQL SECURITY { DEFINER | INVOKER }： 可以 用来 指定 子程序 该 用 创建 子程序 者 的 许可 来 执行， 还是 使用 调 用者 的 许可 来 执行。 默认值 是 DEFINER。 *</li>
<li>COMMENT ‘string’： 存储 过程 或者 函数 的 注释 信息。</li>
</ul>
<h3 id="10-2-4-删除存储过程或函数"><a href="#10-2-4-删除存储过程或函数" class="headerlink" title="10.2.4 删除存储过程或函数"></a>10.2.4 删除存储过程或函数</h3><p><img src="https://pic.imgdb.cn/item/5f4b9e49160a154a677c186a.jpg" alt=""></p>
<h3 id="10-2-5-查看存储过程或者函数"><a href="#10-2-5-查看存储过程或者函数" class="headerlink" title="10.2.5 查看存储过程或者函数"></a>10.2.5 查看存储过程或者函数</h3><h4 id="1-查看存储过程或者函数的状态"><a href="#1-查看存储过程或者函数的状态" class="headerlink" title="1.查看存储过程或者函数的状态"></a>1.查看存储过程或者函数的状态</h4><p><img src="https://pic.imgdb.cn/item/5f4b9e9b160a154a677c2e3c.jpg" alt=""></p>
<h4 id="2-查看存储过程或函数的定义"><a href="#2-查看存储过程或函数的定义" class="headerlink" title="2.查看存储过程或函数的定义"></a>2.查看存储过程或函数的定义</h4><p><img src="https://pic.imgdb.cn/item/5f4b9eb0160a154a677c335b.jpg" alt=""></p>
<h4 id="3-通过information-schema-Rounties了解存储过程和函数的信息"><a href="#3-通过information-schema-Rounties了解存储过程和函数的信息" class="headerlink" title="3.通过information_schema.Rounties了解存储过程和函数的信息"></a>3.通过information_schema.Rounties了解存储过程和函数的信息</h4><h3 id="10-2-6-变量的使用"><a href="#10-2-6-变量的使用" class="headerlink" title="10.2.6 变量的使用"></a>10.2.6 变量的使用</h3><h4 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1.变量的定义"></a>1.变量的定义</h4><p>​    通过DECLARE 声明</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba05e160a154a677ca559.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE last_ month_ start DATE;</span><br></pre></td></tr></table></figure>

<h4 id="2-变量的赋值"><a href="#2-变量的赋值" class="headerlink" title="2.变量的赋值"></a>2.变量的赋值</h4><p><img src="https://pic.imgdb.cn/item/5f4ba0c0160a154a677cc272.jpg" alt=""></p>
<h3 id="10-2-7-定义条件和处理"><a href="#10-2-7-定义条件和处理" class="headerlink" title="10.2.7 定义条件和处理"></a>10.2.7 定义条件和处理</h3><h4 id="1-条件的定义"><a href="#1-条件的定义" class="headerlink" title="1.条件的定义"></a>1.条件的定义</h4><p><img src="https://pic.imgdb.cn/item/5f4ba10f160a154a677cd658.jpg" alt=""></p>
<h4 id="2-条件的处理"><a href="#2-条件的处理" class="headerlink" title="2.条件的处理"></a>2.条件的处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DECLARE handler_ type HANDLER FOR condition_ value[,. .] sp_ statement </span><br><span class="line">handler_ type: </span><br><span class="line">CONTINUE </span><br><span class="line">| EXIT </span><br><span class="line">| UNDO </span><br><span class="line">condition_ value: </span><br><span class="line">SQLSTATE [VALUE] sqlstate_ value </span><br><span class="line">| condition_ name </span><br><span class="line">| SQLWARNING </span><br><span class="line">| NOT FOUND</span><br></pre></td></tr></table></figure>

<p>1.当没有条件处理时结果如下</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba2a5160a154a677d433d.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba2b2160a154a677d469f.jpg" alt=""></p>
<p>2.对主键冲突进行异常处理时</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba220160a154a677d228d.jpg" alt=""></p>
<p>​    hanlder_type现在只支持CONTINUE和EXIT两种。</p>
<p>​    condition_value的值既可以是DECLARE定义的condition_name，也可以是SQLSTATE值或者mysql-error-code的值或者SQLWARNING, NOT FOUND, SQLEXCEPTION。这3个值是定义好的错误类别。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f4ba3c5160a154a677d954d.jpg" alt=""></p>
<p>上面例子还可以写成以下几种方式：</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba3e6160a154a677d9dcc.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba3f3160a154a677da103.jpg" alt=""></p>
<h3 id="10-2-8-光标的使用"><a href="#10-2-8-光标的使用" class="headerlink" title="10.2.8 光标的使用"></a>10.2.8 光标的使用</h3><p>​    在存储过程和函数中，可以使用光标对结果集进行循环的处理。</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba4ea160a154a677de33d.jpg" alt=""></p>
<p>​    以下是一个例子，对payment表按照行进行循环处理。处理， 按照 staff_ id 值 的 不同 累加 amount 的 值， 判断 循环 结束 的 条件 是 捕获 NOT FOUND 的 条件， 当 FETCH 光标 找 不到 下一 条 记录 的 时候， 就会 关闭 光标 然后 退出 过程。</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba5bc160a154a677e2334.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba5dc160a154a677e2cbd.jpg" alt=""></p>
<p>注意：变量、 条件、 处理 程序、 光标 都是 通过 DECLARE 定义 的， 它们 之间 是有 先后 顺序 要求 的。 变量 和 条件 必须 在最 前面 声明， 然后 才能 是 光标 的 声明， 最后 才 可以 是 处理 程序 的 声明。</p>
<h3 id="10-2-9-流程控制"><a href="#10-2-9-流程控制" class="headerlink" title="10.2.9 流程控制"></a>10.2.9 流程控制</h3><h4 id="1-IF-语句"><a href="#1-IF-语句" class="headerlink" title="1.IF 语句"></a>1.IF 语句</h4><p><img src="https://pic.imgdb.cn/item/5f4ba69f160a154a677e5fd7.jpg" alt=""></p>
<h4 id="2-CASE语句"><a href="#2-CASE语句" class="headerlink" title="2.CASE语句"></a>2.CASE语句</h4><p><img src="https://pic.imgdb.cn/item/5f4ba6b2160a154a677e64a3.jpg" alt=""></p>
<p>或</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba6c3160a154a677e6a17.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba6d0160a154a677e6f73.jpg" alt=""></p>
<h4 id="3-LOOP语句"><a href="#3-LOOP语句" class="headerlink" title="3.LOOP语句"></a>3.LOOP语句</h4><p><img src="https://pic.imgdb.cn/item/5f4ba6f3160a154a677e796f.jpg" alt=""></p>
<h4 id="4-LEAVE语句"><a href="#4-LEAVE语句" class="headerlink" title="4.LEAVE语句"></a>4.LEAVE语句</h4><p>​    从标注的流程构造中退出，通常和BEGIN和END或循环一起使用</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba71f160a154a677e8603.jpg" alt=""></p>
<h4 id="5-ITERATE语句"><a href="#5-ITERATE语句" class="headerlink" title="5. ITERATE语句"></a>5. ITERATE语句</h4><p>​    必须用在循环中，作用类似于CONITNUE</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba783160a154a677ea36c.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba78e160a154a677ea848.jpg" alt=""></p>
<h4 id="6-REPEAT语句"><a href="#6-REPEAT语句" class="headerlink" title="6.REPEAT语句"></a>6.REPEAT语句</h4><p>​    有条件的循环控制语句，满足条件时退出循环</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba7bc160a154a677eb7f4.jpg" alt=""></p>
<h4 id="7-WHILE语句"><a href="#7-WHILE语句" class="headerlink" title="7.WHILE语句"></a>7.WHILE语句</h4><p><img src="https://pic.imgdb.cn/item/5f4ba7d1160a154a677ebea3.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4ba7e2160a154a677ec42e.jpg" alt=""></p>
<p>​    和REPEAT循环区别在于WHILE要满足条件才执行循环，REPEAT是满足条件才退出。</p>
<h3 id="10-2-10-事件调度器"><a href="#10-2-10-事件调度器" class="headerlink" title="10.2.10 事件调度器"></a>10.2.10 事件调度器</h3><p>​    5.1版本之后新增的功能，按自定义的时间周期触发某种操作，可以理解为时间调度器。</p>
<p>​    最简单的一个事件调度器</p>
<p>​    在其实时间的基础上，每隔一个小时触发一次。</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba8ff160a154a677f1f3f.jpg" alt=""></p>
<p>​    通过下面命令打开调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL event_ scheduler &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>禁用或者删除调度器</p>
<p><img src="https://pic.imgdb.cn/item/5f4ba99b160a154a677f489a.jpg" alt=""></p>
<h2 id="10-3-触发器"><a href="#10-3-触发器" class="headerlink" title="10.3 触发器"></a>10.3 触发器</h2><h3 id="10-3-1-创建触发器"><a href="#10-3-1-创建触发器" class="headerlink" title="10.3.1 创建触发器"></a>10.3.1 创建触发器</h3><p><img src="https://pic.imgdb.cn/item/5f4ba9f2160a154a677f61f5.jpg" alt=""></p>
<p>​    只能创建在永久表上，不能对临时表创建触发器。</p>
<p>​    其中trigger_time是触发器的触发时间，可以使BEFORE或者AFTER，BEFORE指在检查约束前触发。</p>
<p>​    trigger_event就是触发器的触发条件，可以使INSERT, UPDATE或DELETE。</p>
<p>​    同一个表相同触发时间的相同触发时间，只能定义一个触发器。使用别名OLD和NEW来引用触发器中发生变化的内容。目前还支持行级触发，不支持语句级触发。</p>
<h3 id="10-3-2-删除触发器"><a href="#10-3-2-删除触发器" class="headerlink" title="10.3.2 删除触发器"></a>10.3.2 删除触发器</h3><p><img src="https://pic.imgdb.cn/item/5f4baad4160a154a677fa31c.jpg" alt=""></p>
<h3 id="10-3-3-查看触发器"><a href="#10-3-3-查看触发器" class="headerlink" title="10.3.3 查看触发器"></a>10.3.3 查看触发器</h3><p>​    用show triggeres命令查看触发器状态，语法等信息</p>
<p>​    也可以查看information_schema.triggers</p>
<h3 id="10-3-4-触发器的使用"><a href="#10-3-4-触发器的使用" class="headerlink" title="10.3.4 触发器的使用"></a>10.3.4 触发器的使用</h3><p>​    触发程序不能调用将数据返回客户端的存储程序，也不能使用采用CALL语句的动态SQL语句，但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或函数通过OUT或INPUT类型的参数将数据触发器是可以的。</p>
<p>​    不能再触发器中显示或隐式方式开始或结束事务的语句。比如 START TRANS-ACTION,</p>
<p>COMMIT, ROLLBACK</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f4bab9e160a154a677fe8a4.jpg" alt=""></p>
<h1 id="第11章-事务控制和锁定语句"><a href="#第11章-事务控制和锁定语句" class="headerlink" title="第11章 事务控制和锁定语句"></a>第11章 事务控制和锁定语句</h1><h2 id="11-1-LOCK-TABLES和UNLOCKE-TABLES"><a href="#11-1-LOCK-TABLES和UNLOCKE-TABLES" class="headerlink" title="11.1 LOCK TABLES和UNLOCKE TABLES"></a>11.1 LOCK TABLES和UNLOCKE TABLES</h2><p>​    LOCK TABLES可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。</p>
<p>​    UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个LOCK TABLES时，或当服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES tbl_ name </span><br><span class="line">[AS alias] &#123;READ [LOCAL] | [LOW_ PRIORITY] WRITE&#125;</span><br><span class="line">[, tbl_ name [AS alias] &#123;READ [LOCAL] | [LOW_ PRIORITY] WRITE&#125;] . . </span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>



<p><img src="https://pic.imgdb.cn/item/5f4cf151160a154a67fa62f3.jpg" alt=""></p>
<p>注意: LOCK TABLES/UNLOCK TABLES 与 LOCK TABLE/UNLOCK TABLE 同义</p>
<h2 id="11-2-事务控制"><a href="#11-2-事务控制" class="headerlink" title="11.2 事务控制"></a>11.2 事务控制</h2><p>​    MySQL通过SET AUTOCOMMIT、START TRANSACTION、COMMIT、ROLLBACK等语句支持本地事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION </span><br><span class="line">| BEGIN [WORK] COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] </span><br><span class="line">ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] </span><br><span class="line">SET AUTOCOMMIT &#x3D; &#123;0 | 1&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，MySQL是自动提交的。</p>
<p>START TRANSACTION 或 BEGIN 语句 可以 开始 一项 新的 事务。 </p>
<p>COMMIT 和 ROLLBACK 用来 提交 或者 回 滚 事务。 </p>
<p>CHAIN 和 RELEASE 子句 分别 用来 定义 在 事务 提交 或者 回 滚 之后 的 操作， CHAIN 会 立即 启动 一个 新事物， 并且 和 刚才 的 事务 具有 相同 的 隔离 级别，</p>
<p>RELEASE 则 会 断开 和 客户 端 的 连接。</p>
<p> SET AUTOCOMMIT 可以 修改 当前 连接 的 提交 方式， 如果 设置 了 SET AUTOC- OMMIT= 0， 则 设置 之后 的 所有 事务 都 需要 通过 明确 的 命令 进行 提交 或者 回 滚。</p>
<p><img src="https://pic.imgdb.cn/item/5f4cf38b160a154a67fc6ab9.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4cf39d160a154a67fc759f.jpg" alt=""></p>
<p>​    在锁表期间，开始一个事务会造成一个隐含的UNLOCK TABLE在里面</p>
<p><img src="https://pic.imgdb.cn/item/5f4cf5bb160a154a67fe690c.jpg" alt=""></p>
<p>​    在同一个事务中，最好使用相同存储引擎的表，否则ROLLBACK时需要对非事务类型的表进行特别的处理，因为COMMIT, ROLLBACK只能对事务类型的表进行提交或者回滚。</p>
<p>​    通常情况，只对提交的事务记录到二进制的日志中，但是如果一个事务中包含非事务类型的表，那么回滚操作也会被记录到二进制日志中，以确保非事务类型的更新可以被复制到从数据库中。</p>
<p>​    所有DDL语句是不能回滚的，部分DDL语句会造成隐式的提交。</p>
<p>​    事务中可以通过定义SAVEPOINT，指定回滚事务的一个部分，但不能指定提交事务的一个部分。</p>
<p>​    可以定义多个SAVEPOINT,满足不同条件时，回滚不同的SAVEPOINT。需要注意的是，定义了相同名字的SAVEPOINT，会覆盖。可以通过RELEASE SAVEPOINT进行删除SAVEPOINT。</p>
<p><img src="https://pic.imgdb.cn/item/5f4cf728160a154a67ffca79.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4cf733160a154a67ffd50b.jpg" alt=""></p>
<h2 id="11-3-分布式事务的使用"><a href="#11-3-分布式事务的使用" class="headerlink" title="11.3 分布式事务的使用"></a>11.3 分布式事务的使用</h2><p>​    5.0.3版本起开始支持分布式事务，InnoDB才能支持。</p>
<h3 id="11-3-1-分布式事务的原理"><a href="#11-3-1-分布式事务的原理" class="headerlink" title="11.3.1 分布式事务的原理"></a>11.3.1 分布式事务的原理</h3><p>​    使用一个或多个资源管理器和一个事务管理器。</p>
<ul>
<li>资源管理器(RM)用于提供通向实物资源的途径，数据库服务器时一种资源管理器，该管理器必须可以提交或回滚RM管理的事务。</li>
<li>事务管理器(TM)用于协调作为一个分布式事务一部分的事务。TM与管理的每个事物的RMs进行通信。在一个分布事务中，各个单个事务均是分布式事务的分支事务。</li>
</ul>
<p>​    MySQL执行XA MySQL时，MySQL服务器相当于一个用于管理分布式事务中的XA事务的资源管理器。</p>
<p>​    要执行一个分布式事务，必须知道这个分布式事务设计哪些资源管理器，并把每个资源管理器的事务执行到事务可以被提交或回滚时。根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子操作全部提交或回滚。必须要考虑任何组件或者连接网络可能会出现的异常。</p>
<p>​    执行分布式事务使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后。</p>
<ul>
<li>在第一阶段中，所有分支都预备好，即他们被TM告知要准备提交。通常，这意味着用于管理分支的各个RM会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做，这些结果被用于第二阶段。</li>
<li>在第二阶段中，TM告知RMs是否要提交或回滚。如果在预备分支时，所有的分支指示它们能够提交，则所有被告知要提交。在预备时，有任何分支指示它们将不能提交，则所有分支被告知回滚。</li>
</ul>
<h3 id="11-3-2-分布式事务的语法"><a href="#11-3-2-分布式事务的语法" class="headerlink" title="11.3.2 分布式事务的语法"></a>11.3.2 分布式事务的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA &#123;START| BEGIN&#125; xid [JOIN| RESUME]</span><br></pre></td></tr></table></figure>

<p>​    XA START xid用于启动一个带给定xid值的XA事务。每个事务必须有一个唯一的xid，因此该值不能被其他的XA事务使用。</p>
<p>​    xid是一个XA事务标识符，用来唯一表示一个分布式事务。由客户端提供或由MySQL服务器生成。</p>
<p>​    xid: gtrid [, bqual [, formatID]]</p>
<p>​    gtrid是一个分布式事务标识符，相同分布式事务应该使用相同的gtrid，这样可以明确知道XA事务属于哪个分布式事务。</p>
<p>​    bqual是一个分支限定符，默认值是空串 。对于一个分布式事务中的每个分支事务，bqual值必须是唯一的。</p>
<p>​    formatID是一个数字，用于表示由gtride和bqual值使用的格式，默认值是1。</p>
<p>​    下面其他XA语法用到的xid必须和START操作使用的xid相同。</p>
<p>​    XA END xid [SUSPEND [FOR MIGRATE]] </p>
<p>​    XA PREPARE xid </p>
<p>​    使 事务 进入 PREPARE 状态， 也就是 两 阶段 提交 的 第一个 提交 阶段。</p>
<p>​     XA COMMIT xid [ONE PHASE] </p>
<p>​    XA ROLLBACK xid </p>
<p>​    这 两个 命令 用来 提交 或者 回 滚 具体 的 分支 事务。</p>
<p>​     也就是 两 阶段 提交 的 第二个 提交 阶段， 分支 事务 被 实际 地 提交 或者 回 滚。 </p>
<p>​    XA RECOVER</p>
<p>​     XA RECOVER 返回 当前 数据库 中 处于 PREPARE 状态 的 分支 事务 的 详细信息。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f4e5a36160a154a67a7f01a.jpg" alt=""></p>
<h3 id="11-3-3-存在的问题"><a href="#11-3-3-存在的问题" class="headerlink" title="11.3.3 存在的问题"></a>11.3.3 存在的问题</h3><p>​    在5.5之前的版本，如果分支事务到达prepare状态，数据库异常重启，重启后，可以选择对分支事务进行提交或回滚操作，但是即使选择提交事务，该事务也不会被写入BINLOG。可能导致使用BINLOG恢复时丢失部分数据。如果存在复制的从库，则有可能导致主从数据库的数据不一致。一下演示了这个过程。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f4e5b8f160a154a67a84940.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f4e5baa160a154a67a85056.jpg" alt="">、</p>
<p>​    在MySQL5.7中，已经解决了XA事务严格持久化的问题，在session断开和实例崩溃的情况下，事务都不会自动回滚，在XA PREPARE时，之前的事务信息就会被写入BINLOG并同步到备库中。</p>
<p>​    5.7中，在XA事务在结束之后，提交之后，不允许进行查询。</p>
<p>​    总之，MySQL的分布式事务还存在一些问题，在数据库或应用异常的情况下，可能会导致分布式事务的不完整或需要人工介入处理。</p>
<h1 id="第12章-SQL中的安全问题"><a href="#第12章-SQL中的安全问题" class="headerlink" title="第12章 SQL中的安全问题"></a>第12章 SQL中的安全问题</h1><h2 id="12-1-SQL注入简介"><a href="#12-1-SQL注入简介" class="headerlink" title="12.1 SQL注入简介"></a>12.1 SQL注入简介</h2><p>​    SQL注入就是利用某些数据库外部接口将用户信息插入到实际的数据库操作语言当中，从而达到入侵数据库乃至操作系统的目的，甚至可以获得数据库管理员权限。而且SQL注入也很难防范。</p>
<p>​    SQL注入例子</p>
<p>（1） 创建 用户 表 user：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user ( </span><br><span class="line">userid int( 11) NOT NULL auto_ increment, </span><br><span class="line">username varchar( 20) NOT NULL default &#39;&#39;, </span><br><span class="line">password varchar( 20) NOT NULL default &#39;&#39;, </span><br><span class="line">PRIMARY KEY (userid) ) </span><br><span class="line">TYPE&#x3D; MyISAM AUTO_ INCREMENT&#x3D; 3 ;</span><br></pre></td></tr></table></figure>

<p>（2） 给用户 表 user 添加 一条 用户 记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &#96; user&#96; VALUES (1, &#39;angel&#39;, &#39;mypass&#39;);</span><br></pre></td></tr></table></figure>

<p>（3） 验证 用户 root 登录 localhost 服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php $ servername &#x3D; &quot;localhost&quot;; </span><br><span class="line">	$ dbusername &#x3D; &quot;root&quot;; </span><br><span class="line">	$ dbpassword &#x3D; &quot;&quot;;</span><br><span class="line">	$ dbname &#x3D; &quot;injection&quot;; </span><br><span class="line">	mysql_ connect($ servername,$ dbusername,$ dbpassword) or die (&quot;数据库 连接 失败&quot;); </span><br><span class="line">	$ sql &#x3D; &quot;SELECT * FROM user WHERE username&#x3D;&#39;$ username&#39; AND password&#x3D; &#39;$password&#39;&quot;;</span><br><span class="line">	$ result &#x3D; mysql_ db_ query($ dbname, $ sql); </span><br><span class="line">	$ userinfo &#x3D; mysql_ fetch_ array($ result); </span><br><span class="line">	if (empty($ userinfo)) &#123; echo &quot;登录 失败&quot;; &#125; else &#123; echo &quot;登录 成功&quot;; &#125; echo &quot;&lt;p&gt; SQL Query:$ sql&lt; p&gt;&quot;; ?&gt;</span><br></pre></td></tr></table></figure>

<p>（4） 然后 提交 如下 URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F; 127. 0. 0. 1&#x2F; injection&#x2F; user. php? username&#x3D; angel&#39; or &#39;1&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>​    发现这个URL可以登录系统。同样也可以利用SQL的注释语句实现SQL注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F; 127. 0. 0. 1&#x2F; injection&#x2F; user. php? username&#x3D; angel&#39;&#x2F;*</span><br><span class="line">http:&#x2F;&#x2F; 127. 0. 0. 1&#x2F; injection&#x2F; user. php? username&#x3D; angel&#39;#</span><br></pre></td></tr></table></figure>

<p>​    将后面的局语句都注释掉，只根据用户名没有根据密码的URL都成功进行了登录。利用or和朱师傅不同在于，前者是利用逻辑运算，后者是MySQL的特性，比逻辑运算简单得多。</p>
<h2 id="12-2-应用开发中可以采取的措施"><a href="#12-2-应用开发中可以采取的措施" class="headerlink" title="12.2 应用开发中可以采取的措施"></a>12.2 应用开发中可以采取的措施</h2><h3 id="12-2-1-PrepareStatemen-Bind-Variables"><a href="#12-2-1-PrepareStatemen-Bind-Variables" class="headerlink" title="12.2.1 PrepareStatemen+Bind-Variables"></a>12.2.1 PrepareStatemen+Bind-Variables</h3><p>​    MySQL不存在共享池的概念，所以再MySQL上绑定变量的最大好处主要就是避免SQL注入。</p>
<h3 id="12-2-2-使用应用程序提供的转换函数"><a href="#12-2-2-使用应用程序提供的转换函数" class="headerlink" title="12.2.2 使用应用程序提供的转换函数"></a>12.2.2 使用应用程序提供的转换函数</h3><p>​    很多应用程序的接口都提供了对特殊字符的转换函数。恰当地使用这些函数，可以防止应用程序用户输入生成非期望的语句。</p>
<h3 id="12-2-3-自定义函数进行校验。"><a href="#12-2-3-自定义函数进行校验。" class="headerlink" title="12.2.3 自定义函数进行校验。"></a>12.2.3 自定义函数进行校验。</h3><ul>
<li>整理 数据 使之 变得 有效；</li>
<li>拒绝 已知 的 非法 输入； </li>
<li>只 接受 已知 的 合法 输入。</li>
</ul>
<p>下面的正则表达式可以提供一个验证函数：</p>
<p>已知 非法 符号 有：“’ ”、“;”、“=”、“(”、“)”、“/<em>”、“</em>/”、“%”、“+”、“”、“&gt;”、“&lt;”、“–”、“[” 和“]”。</p>
<p>由此， 可以 构造 如下 正 则 表达式：</p>
<p> (|&#39;|(%27)|;|(% 3b)|=|(% 3d)|(|(% 28)|)|(% 29)|(/<em>)|(% 2f% 2a)|(\</em>/)|(% 2a% 2f)|+| (%2b)|&lt;|(% 3c)|&gt;|(% 3e)|(–))|[|% 5b|]|% 5d)</p>
<h1 id="第13章-SQL-Mode及相关问题"><a href="#第13章-SQL-Mode及相关问题" class="headerlink" title="第13章 SQL Mode及相关问题"></a>第13章 SQL Mode及相关问题</h1><h2 id="13-1-MySQL-SQL-Mode简介"><a href="#13-1-MySQL-SQL-Mode简介" class="headerlink" title="13.1 MySQL SQL Mode简介"></a>13.1 MySQL SQL Mode简介</h2><ul>
<li>通过设置SQL Mode，可以完成不同严格程度的数据校验，有效地保护数据准确性。</li>
<li>通过设置SQL Mode为ANSI模式，来保证大多数SQL符合标准的SQL语法，这样应用在不同数据库之间进行迁移时，则不需要对业务SQL进行较大修改</li>
<li>在不同数据库之间进行数据迁移之前，通过设置SQL Mode可以使MySQL上的数据更方便地迁移到目标数据库中。</li>
</ul>
<p>​    在MySQL5.7中，SQL Mode有了较大的变化，查询默认SQLMode为ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ZEOR_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER和NO_ENGINE_SUBSTITUTION（不同小版本可能略有区别)。</p>
<table>
<thead>
<tr>
<th>sql_mode值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ONLY_FULL_GROUP_BY</strong></td>
<td>group by中没出现的列，在select， having， order by中会被拒绝</td>
</tr>
<tr>
<td><strong>STRICT_TRANS_TABLES</strong></td>
<td>非法日期，超过字段长度的值插入时，会报错</td>
</tr>
<tr>
<td><strong>NO_ZEOR_IN_DATE</strong></td>
<td>日期中针对月份和日期部分，如果为0，有不同执行逻辑<br />1.disable：可以正常插入<br />2.enable:可以正常插入，有警告，如果mode中包含STRICT_TRANS_TABLES，但是可以通过ignore关键字写入’000-00-00’</td>
</tr>
<tr>
<td><strong>NO_ZERO_DATE</strong></td>
<td>针对日期’0000-00-00’<br />1.disable：可以正常插入<br />2.enable:可以正常插入，有警告，如果mode中包含STRICT_TRANS_TABLES，但是可以通过ignore关键字写入’000-00-00’，有警告</td>
</tr>
<tr>
<td><strong>ERROR_FOR_DIVISION_BY_ZERO</strong></td>
<td>除数为0，包括模运算<br />1.disable:插入NULL，没有警告<br />2.enable:插入NULL，有警告，如果mode中包含STRICT_TRANS_TABLES，则拒绝写入，可以通过ignore子句写入NULL，有警告</td>
</tr>
<tr>
<td><strong>NO_AUTO_CREATE_USER</strong></td>
<td>防止使用不带密码的子句来创建一个用户</td>
</tr>
<tr>
<td><strong>NO_ENGINE_SUBSTITUTION</strong></td>
<td>执行create table或altertable，如果指定了不支持的(包括disable或者未编译)的存储引擎，是否自动替换为默认引擎<br />1.disable:craete table自动替换后执行，alter table不会执行，都有警告<br />2.enable：两个命令直接报错</td>
</tr>
</tbody></table>
<p>​    5.7.5版本之后，最大区别是在SQL Mode设置中，加了严格的事物表模式。</p>
<p>(1) 查看SQLMode命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@sql_mode</span><br></pre></td></tr></table></figure>

<h2 id="13-2-SQL-Mode常见功能"><a href="#13-2-SQL-Mode常见功能" class="headerlink" title="13.2 SQL Mode常见功能"></a>13.2 SQL Mode常见功能</h2><p>(1) 校验日期合法性。</p>
<p><img src="https://pic.imgdb.cn/item/5f4f9b0a160a154a67f57c8d.jpg" alt=""></p>
<p>​    ANSI模式下可以插入非法日期，但是插入值变为’0000-00-00’,TRADITIONAL模式不可以。</p>
<p>（2）启用NO_BACKSLASH_ESCAPES模式，使\变成普通字符。</p>
<p>（3）启用PIPES_AS_CONCAT模式，将’||’视为字符串连接符号。</p>
<h2 id="13-3-常用SQL-MODE"><a href="#13-3-常用SQL-MODE" class="headerlink" title="13.3 常用SQL MODE"></a>13.3 常用SQL MODE</h2><p><img src="https://pic.imgdb.cn/item/5f4f9d21160a154a67f6251b.jpg" alt=""></p>
<h2 id="13-4-SQL-Mode在迁移中如何使用"><a href="#13-4-SQL-Mode在迁移中如何使用" class="headerlink" title="13.4 SQL Mode在迁移中如何使用"></a>13.4 SQL Mode在迁移中如何使用</h2><p><img src="https://pic.imgdb.cn/item/5f4f9d50160a154a67f63886.jpg" alt=""></p>
<h1 id="第14章-MySQL分区"><a href="#第14章-MySQL分区" class="headerlink" title="第14章 MySQL分区"></a>第14章 MySQL分区</h1><h2 id="14-1-分区概述"><a href="#14-1-分区概述" class="headerlink" title="14.1 分区概述"></a>14.1 分区概述</h2><p>​    有利于管理非常大的表，采用分而治之的逻辑。引入了分区键的概念。分区间根据某个区间值（或范围值）、特定值列表或者HASH函数执行数据的聚集，让数据规则地分布在不同的分区中，让一个大对象变成一些小对象。</p>
<p>​    优点：</p>
<ul>
<li>和单个磁盘或文件系统分区相比，可以存储更多数据</li>
<li>优化数据查询。在Where语句中包含分区条件时，可以只扫描必要的一个或多个分区来提高效率；在涉及SUM()和COUNT()这类聚合函数时，可以容易地在每个分区并行处理，注最终只需要汇总所有分区得到的数据。在5.7版本中，可以通过类似于SELECT * FROM T PARTITION(p0, p1)来显示地指定查询分区。</li>
<li>对于已经过期或不需要存储的数据，可以通过删除与这些数据有关的分区来快速删除数据</li>
<li>跨多个磁盘来分散查询数据，提高吞吐量。</li>
</ul>
<p>5.7中，通过二进制包安装会默认包含分区支持，通过源代码编译安装，需要在编译时指定参数DWITH_PARTITION_STORAGE_ENGINE。</p>
<p>​    通过SHOW PLUGINS命令或查询PLUGINS字典表来确认当前MYSQL是否支持分区。</p>
<p>​    支持大部分存储引擎(比如MyISAM、InnoDB、Memory等)创建分区表，不支持MERGE, CSV和FEDERRATED这三种引擎。</p>
<p>​    5.7版本中，同一个分区表的分区必须使用相同的存储引擎，分区数量不超过8192.</p>
<p>​    分区表设置存储引擎，只能使用[STORAGE]ENGINE子句，必须列在CREATE TABLE其他任何分区选项之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp </span><br><span class="line">(empid INT, </span><br><span class="line">salary DECIMAL( 7, 2), </span><br><span class="line">birth_ date DATE) </span><br><span class="line">-&gt;ENGINE&#x3D; INNODB </span><br><span class="line">-&gt; PARTITION BY HASH( MONTH( birth_ date) )</span><br><span class="line">-&gt; PARTITIONS 6;</span><br></pre></td></tr></table></figure>

<p>注意：MySQL分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区。反过来也一样。MySQL分区表上创建的索引一定是本地索引。</p>
<h2 id="14-2-分区类型"><a href="#14-2-分区类型" class="headerlink" title="14.2 分区类型"></a>14.2 分区类型</h2><p>​    5.7主要有以下6种：</p>
<ul>
<li>RANGE分区：基于一个连续区间范围，把数据分配到不同的分区</li>
<li>LIST分区：基于枚举出的值列表分区，RANGE是基于给定的连续区间分区</li>
<li>COLUMNS：分区键可以是多了，也可以是非整数。</li>
<li>HASH: 基于给定的分区个数，把数据取模分配到不同的分区。</li>
<li>KEY分区：类似于HASH分区，但使用MySQL提供的hash函数。</li>
<li>子分区：也叫符复合分区或组合分区，即在主分区下再做一层分区，将数据再次分割。</li>
</ul>
<p>​    5.7中RANGE,LIST,HASH分区的分区键必须是INT类型，或者通过表达式返回INT类型，KEY和COLUMNS出来，可以使用其他类型的列（BLOB和TEXT除外）作为分区键。</p>
<p>​    如果希望在RANGE或LIST类型分区上使用非INT键做分区键，可以选择COLUMNS分区。无论哪种MySQL分区类型，要么分区表上没有唯一键/主键，要么主键/唯一键包含分区间。</p>
<p>​    分区名字基本上遵循MySQL标识符的原则。在MySQL中，对于库名和表明是否大小写铭感，可以通过下面的方法进行查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%lower_case%&#39;</span><br></pre></td></tr></table></figure>

<p>​    查询出的lower_case_file_system是一个不可修改的变量，代表操作系统是否大小写敏感，OFF代表敏感，ON代表不敏感。如果操作系统大小写敏感，那么库名和表名是否大小写敏感就由lower_case_table_names变量决定，1不敏感。</p>
<p><img src="https://pic.imgdb.cn/item/5f50e568160a154a673d02c2.jpg" alt=""></p>
<p>​    注意，列名，别名，分区名这些是不区分大小写的。</p>
<h3 id="14-2-1-RANGE分区"><a href="#14-2-1-RANGE分区" class="headerlink" title="14.2.1 RANGE分区"></a>14.2.1 RANGE分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp ( </span><br><span class="line">-&gt;　 id INT NOT NULL, </span><br><span class="line">-&gt;　 ename VARCHAR( 30), </span><br><span class="line">-&gt;　 hired DATE NOT NULL DEFAULT &#39;1970- 01- 01&#39;, </span><br><span class="line">-&gt;　 separated DATE NOT NULL DEFAULT &#39;9999- 12- 31&#39;, </span><br><span class="line">-&gt;　 job VARCHAR( 30) NOT NULL, </span><br><span class="line">-&gt;　 store_ id INT NOT NULL </span><br><span class="line">-&gt; )</span><br><span class="line">-&gt; PARTITION BY RANGE (store_ id) ( </span><br><span class="line">-&gt;　 PARTITION p0 VALUES LESS THAN (10), </span><br><span class="line">-&gt;　 PARTITION p1 VALUES LESS THAN (20), </span><br><span class="line">-&gt;　 PARTITION p2 VALUES LESS THAN (30) </span><br><span class="line">-&gt; );</span><br></pre></td></tr></table></figure>

<p>​    此时，插入store_id大于30的行，就会出现错误。可以在分区时使用VALUES LESS THAN MAXVALUE，提供给所有大于明确最高值的值，MAXVALUE表示最大的可能整数值。</p>
<p>​    支持在VALUES LESS THAN子句中使用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp_ date ( </span><br><span class="line">-&gt;　 id INT NOT NULL, </span><br><span class="line">-&gt;　 ename VARCHAR( 30), </span><br><span class="line">-&gt;　 hired DATE NOT NULL DEFAULT &#39;1970- 01- 01&#39;, </span><br><span class="line">-&gt;　 separated DATE NOT NULL DEFAULT &#39;9999- 12- 31&#39;, </span><br><span class="line">-&gt;　 job VARCHAR( 30) NOT NULL, </span><br><span class="line">-&gt;　 store_ id INT NOT NULL </span><br><span class="line">-&gt; )</span><br><span class="line">-&gt; PARTITION BY RANGE (YEAR( separated)) ( </span><br><span class="line">-&gt;　 PARTITION p0 VALUES LESS THAN (1995), </span><br><span class="line">-&gt;　 PARTITION p1 VALUES LESS THAN (2000), </span><br><span class="line">-&gt;　 PARTITION p2 VALUES LESS THAN (2005) -&gt; );</span><br></pre></td></tr></table></figure>

<p>​    从5.5版本开始，提供了RANGE COLUMNS支持非整数分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp_ date( </span><br><span class="line">-&gt;　 id INT NOT NULL, </span><br><span class="line">-&gt;　 ename VARCHAR( 30), </span><br><span class="line">-&gt;　 hired DATE NOT NULL DEFAULT &#39;1970- 01- 01&#39;, </span><br><span class="line">-&gt;　 separated DATE NOT NULL DEFAULT &#39;9999- 12- 31&#39;, </span><br><span class="line">-&gt;　 job VARCHAR( 30) NOT NULL, </span><br><span class="line">-&gt;　 store_ id INT NOT NULL -&gt; ) </span><br><span class="line">-&gt; PARTITION BY RANGE COLUMNS (separated) (</span><br><span class="line">-&gt;　 PARTITION p0 VALUES LESS THAN (&#39;1996- 01- 01&#39;),</span><br><span class="line">-&gt;　 PARTITION p1 VALUES LESS THAN (&#39;2001- 01- 01&#39;), </span><br><span class="line">-&gt;　 PARTITION p2 VALUES LESS THAN (&#39;2006- 01- 01&#39;) -&gt; );</span><br></pre></td></tr></table></figure>

<p>​    RANGE分区特别适用于以下两种情况：</p>
<ul>
<li>当删除过期数据时，只需要简单的ALTER TABLE DROP PARTITION p0来删除p0分区中的数据。</li>
<li>经常运行包含分区键的查询，MySQL可以很快确定只有某一个或者某些分区需要扫描，因为其他分区不可能包含符合该WHERE子句的任何记录。</li>
</ul>
<h3 id="14-2-2-LIST分区"><a href="#14-2-2-LIST分区" class="headerlink" title="14.2.2 LIST分区"></a>14.2.2 LIST分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE expenses ( </span><br><span class="line">-&gt;　 expense_ date DATE NOT NULL, </span><br><span class="line">-&gt;　 category INT, </span><br><span class="line">-&gt;　 amount DECIMAL (10, 3) </span><br><span class="line">-&gt; )PARTITION BY LIST( category) ( </span><br><span class="line">-&gt;　 PARTITION p0 VALUES IN (3, 5), </span><br><span class="line">-&gt;　 PARTITION p1 VALUES IN (1, 10), </span><br><span class="line">-&gt;　 PARTITION p2 VALUES IN (4, 9), </span><br><span class="line">-&gt;　 PARTITION p3 VALUES IN (2), </span><br><span class="line">-&gt;　 PARTITION p4 VALUES IN (6) -&gt; );</span><br></pre></td></tr></table></figure>

<p>​    支持非整数值，使用LIST COLUMNS。</p>
<h3 id="14-2-3-COLUMNS分区"><a href="#14-2-3-COLUMNS分区" class="headerlink" title="14.2.3 COLUMNS分区"></a>14.2.3 COLUMNS分区</h3><p>​    5.5引入的。</p>
<p>​    支持整数、字符串、日期时间三大类型。</p>
<p>注意：5.7中，分区仅支持一个或多个字段名作为分区间，不支持表达式作为分区键。</p>
<p>​    COLUMNS还支持多列分区。</p>
<p><img src="https://pic.imgdb.cn/item/5f50e97a160a154a673e6bff.jpg" alt=""></p>
<h3 id="14-2-4-HASH分区"><a href="#14-2-4-HASH分区" class="headerlink" title="14.2.4 HASH分区"></a>14.2.4 HASH分区</h3><p>​    支持两种HASH分区，常规HASH分区和线性HASH分区(LINEAR HASH)分区。常规HASH使用取模，线性HASH使用的是一个线性的2的幂的运算法则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp ( </span><br><span class="line">-&gt;　 id INT NOT NULL, </span><br><span class="line">-&gt;　 ename VARCHAR( 30),</span><br><span class="line">-&gt;　 hired DATE NOT NULL DEFAULT &#39;1970- 01- 01&#39;, </span><br><span class="line">-&gt;　 separated DATE NOT NULL DEFAULT &#39;9999- 12- 31&#39;, </span><br><span class="line">-&gt;　 job VARCHAR( 30) NOT NULL, </span><br><span class="line">-&gt;　 store_ id INT NOT NULL-&gt; ) </span><br><span class="line">-&gt; PARTITION BY HASH (store_ id) PARTITIONS 4;</span><br></pre></td></tr></table></figure>

<p>​    表达式expr可以使MySQL中有效的任何函数或其他表达式，只要它们返回一个非常数也非随机的整数。每当插入/更新/删除/一行数据，这个表达式都需要计算一次，这意味着非常复杂的表达式可能会引发性能问题，也不推荐涉及多列的哈希分区。</p>
<p>​    常规HASH看上去不错，但是调整分区个数时的代价很大。为了减少这个待见，提供了线性HASH。</p>
<p>​    唯一区别就是HASH前添加关键字 LINEAR。</p>
<p>​    优点是，在维护分区时，MySQL能够处理得更加迅速，缺点是分布不太均匀。</p>
<h3 id="14-2-5-KEY分区"><a href="#14-2-5-KEY分区" class="headerlink" title="14.2.5 KEY分区"></a>14.2.5 KEY分区</h3><p>​    非常类似于HASH分区，不过HASH分区允许使用用户自定义的表达式，而KEY分区不可以，而KEY分区支持除BLOB和Text外其他类型的列作为分区键。</p>
<p>​    使用PARTITION BY KEY(expr)来创建一个KEY分区，expr可以使0个或多个字段名的列表。不指定分区键，默认说先选择主键进行分区，如果没有主键，会选择非空唯一键作为分区键。没有主键和唯一键情况下，不能指定分区键。</p>
<p>​    和HASH一样，可以使用LINEAW关键字。</p>
<h3 id="14-2-6-子分区"><a href="#14-2-6-子分区" class="headerlink" title="14.2.6 子分区"></a>14.2.6 子分区</h3><p>​    对分区表每个分区再次分割，又被人称为复合分区。</p>
<p>​    5.7支持对已经通过RANGE或LIST分区了的表再进行分区。子分区支持HASH或KEY分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (</span><br><span class="line">id INT, purchased DATE) </span><br><span class="line">-&gt;　 PARTITION BY RANGE( YEAR( purchased)) </span><br><span class="line">-&gt;　 SUBPARTITION BY HASH( TO_ DAYS( purchased)) </span><br><span class="line">-&gt;　 SUBPARTITIONS 2 -&gt;　( </span><br><span class="line">-&gt;　 　 PARTITION p0 VALUES LESS THAN (1990), </span><br><span class="line">-&gt;　 　 PARTITION p1 VALUES LESS THAN (2000), </span><br><span class="line">-&gt;　 　 PARTITION p2 VALUES LESS THAN MAXVALUE </span><br><span class="line">-&gt;　);</span><br></pre></td></tr></table></figure>

<p>​    复合分区适用于保存非常大量的数据记录：</p>
<ul>
<li>每个分区必须具有相同数量的子分区；</li>
<li>如果要显示指定子分区，则每个分区都要显示指定；</li>
<li>子分区的名称在表中是唯一的</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/5f50f18e160a154a674091a7.jpg" alt=""></p>
<h3 id="14-2-7-MySQL分区处理NULL值的方式"><a href="#14-2-7-MySQL分区处理NULL值的方式" class="headerlink" title="14.2.7 MySQL分区处理NULL值的方式"></a>14.2.7 MySQL分区处理NULL值的方式</h3><p>​    MySQL不禁止分区键值上使用NULL值，一般情况下把NULL当成0值或者最小值进行处理。</p>
<ul>
<li>RANGE分区中，NULL被当做最小值来处理；LIST分区，NULL值必须出现在枚举列表中；HASH或KEY分区中，NULL值会被当成零值来处理。</li>
</ul>
<h2 id="14-3-分区管理"><a href="#14-3-分区管理" class="headerlink" title="14.3 分区管理"></a>14.3 分区管理</h2><h3 id="14-3-1-RANGE和LIST分区管理"><a href="#14-3-1-RANGE和LIST分区管理" class="headerlink" title="14.3.1 RANGE和LIST分区管理"></a>14.3.1 RANGE和LIST分区管理</h3><p>​    在添加、删除和重新定义分区的处理上，RANGE分区和LIST分区非常相似。</p>
<p>​    删除可以用ALTER TABLE DROP PARTITION语句来实现，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE emp_date drop partition p2</span><br></pre></td></tr></table></figure>

<p>​    增加分区可以用ALTER TABLE ADD PARTITION语句来实现。对于RANGE分区来说，只能通过ADD PARTITION方式添加新分区到分区列表的最大一端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE emp_date add partition(partition p5 values less than (2025));</span><br><span class="line"></span><br><span class="line">alter table expenses add partition(partition p6 values in (6, 11));</span><br></pre></td></tr></table></figure>

<p>也提供了在不丢失数据的情况，通过重新定义分区的语句ALTER TABLE REORGANIZE PARTITION INTO重新定义分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table emp_date reorganize partition p3 into(</span><br><span class="line">	partition p2 values less than (2005),</span><br><span class="line">	partition p3 values less than (2015)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>也可以合并分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table emp_date reorganize partition p3,p4 into(</span><br><span class="line">	partition p2 values less than (2005)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意：类似于重定义RANGE分区，重定义LIST分区时，只能够重新定义相邻的分区，不能跳过LSIT分区进行重新定义，通识重新定义的分区区间必须和原分区区间覆盖相同的区间。也不能修改分区类型。</p>
<h3 id="14-3-2-HASH和KEY分区管理"><a href="#14-3-2-HASH和KEY分区管理" class="headerlink" title="14.3.2 HASH和KEY分区管理"></a>14.3.2 HASH和KEY分区管理</h3><p>​    不能以之前的方式进行删除，而可以通过ALTER TABLE COALESCE PARTITION的语句来合并HASH分区或KEY分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TBALE emp COALESCE partition 2</span><br></pre></td></tr></table></figure>

<p>​    COALESCE 不能用来增加数量。</p>
<p>​    要增加分区用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TBALE emp add partition 8;&#x2F;&#x2F;最终变成2+8 &#x3D; 10个</span><br></pre></td></tr></table></figure>

<h3 id="14-3-3-交换分区"><a href="#14-3-3-交换分区" class="headerlink" title="14.3.3 交换分区"></a>14.3.3 交换分区</h3><p>​    5.6版本添加了交换分区功能，使用ALTER TABLE pt EXCHANGE PARTITION p WITH TABLE nt命令，可以实现将分区表pt中的一个分区或者子分区p中的数据与普通表nt中的数据进行交换。</p>
<ul>
<li><p>表nt不能是分区表，由于交换分区不能通过分区对分区的方式进行，如果有这种需求，可以用一个普通表作为中间表，通过交换两次分区来实现；</p>
</li>
<li><p>表nt不能是临时表</p>
</li>
<li><p>表pt和nt的结构，除了分区要一致，包括索引。</p>
</li>
<li><p>nt上不能有外键，也不能有其他表的外键依赖nt</p>
</li>
<li><p>nt表的所有数据，都应该在分区定义的范围内。</p>
<p>5.7版本如果确定都在范围内，可以增加WITHOUT VALIDATION来跳过。</p>
</li>
</ul>
<h1 id="第15章-SQL优化"><a href="#第15章-SQL优化" class="headerlink" title="第15章 SQL优化"></a>第15章 SQL优化</h1><h2 id="15-1-优化SQL语句的一般步骤"><a href="#15-1-优化SQL语句的一般步骤" class="headerlink" title="15.1 优化SQL语句的一般步骤"></a>15.1 优化SQL语句的一般步骤</h2><h3 id="15-1-1-通过show-status命令了解各种SQL的执行效率"><a href="#15-1-1-通过show-status命令了解各种SQL的执行效率" class="headerlink" title="15.1.1 通过show status命令了解各种SQL的执行效率"></a>15.1.1 通过show status命令了解各种SQL的执行效率</h3><p>​    通过show [session|global]status 可以提供服务器状态信息，默认使用session级。</p>
<p>​    <img src="https://pic.imgdb.cn/item/5f56247c160a154a6760d5a1.jpg" alt=""></p>
<p>​    Com_xxx表示每个xxx语句执行的次数，通常比较关心:</p>
<p>​    Com_select, Com_insert, Com_update, Com_delete.</p>
<p>​    下面的只针对InnoDB：</p>
<ul>
<li>Innodb_rows_read: select查询返回的行数</li>
<li>Innodb_rows_insert：插入的行数</li>
<li>Innodb_rows_update：更新的行数</li>
<li>Innodb_rows_delete：删除的行数</li>
</ul>
<p>​    对于事务性的应用，Com_commit和Com_rollback可以了解事务提交和回滚的情况。</p>
<p>​    此外，以下参数便于用户了解数据库的情况</p>
<ul>
<li>Connection：实录连接MySQL服务器的次数</li>
<li>UpTime：服务器工作时间</li>
<li>Slow_queries:慢查询次数</li>
</ul>
<h3 id="15-1-2-定位执行效率较低的SQL语句"><a href="#15-1-2-定位执行效率较低的SQL语句" class="headerlink" title="15.1.2 定位执行效率较低的SQL语句"></a>15.1.2 定位执行效率较低的SQL语句</h3><ul>
<li>将slow-query-log设置为1，会将所有执行时间超过long_query_time参数所设定的阈值SQL，写入slow_query_log_file参数指定的文件中。</li>
<li>慢查询日志在查询结束后才会结束，可以使用show processlist命令查看当前MySQL在进行的线程。</li>
</ul>
<h3 id="15-1-3-通过EXPLAIN分析低效SQL的执行计划"><a href="#15-1-3-通过EXPLAIN分析低效SQL的执行计划" class="headerlink" title="15.1.3 通过EXPLAIN分析低效SQL的执行计划"></a>15.1.3 通过EXPLAIN分析低效SQL的执行计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">explain select sum(amount) from customer a, payment b where 1&#x3D;1 and a.customer_id &#x3D; b.customer_id and email &#x3D; &#39;JANE.BENNETT@sakilacustomer.org&#39;</span><br><span class="line">*************************** 1. row *************************** </span><br><span class="line">id: 1 </span><br><span class="line">select_type: SIMPLE </span><br><span class="line">table: a</span><br><span class="line">type: ALL </span><br><span class="line">possible_keys: PRIMARY </span><br><span class="line">key: NULL </span><br><span class="line">key_len: NULL </span><br><span class="line">ref: NULL </span><br><span class="line">rows: 583 </span><br><span class="line">Extra: Using where </span><br><span class="line">*************************** 2. row *************************** </span><br><span class="line">id: 1 </span><br><span class="line">select_ type: SIMPLE </span><br><span class="line">table: b </span><br><span class="line">type: ref </span><br><span class="line">possible_keys: idx_fk_customer_id </span><br><span class="line">key: idx_fk_customer_id </span><br><span class="line">key_len: 2 </span><br><span class="line">ref: sakila.a.customer_id </span><br><span class="line">rows: 12 </span><br><span class="line">Extra: </span><br><span class="line">2 rows in set (0. 00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>select_type: 表示SELECT的类型，常见取值有SIMPLE表(简单表，即不使用表连接或子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中第二个或后面的查询语句)、SUBQUERY(子查询的第一个SELECT)等。</li>
<li>table:输出结果的表</li>
<li>type：表示MySQL在表中找到所需行的方式，或叫访问类型。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/5f562917160a154a67622404.jpg" alt=""></p>
<p>​    以上是常见类型，性能最差到最好</p>
<ol>
<li>type=ALL, 全表扫描；</li>
<li>index:索引全扫描；</li>
<li>range:索引范围扫描，常见于&lt;、&lt;=、&gt;、&gt;=、between等操作符；</li>
<li>ref: 使用非唯一索引或唯一索引的前缀扫描，返回匹配某个单独值的行；</li>
<li>eq_ref：类似于ref，不过使用的是唯一索引；</li>
<li>const/system：单标中最多的一个匹配行，查询非常迅速，其他列的值可以被优化器当前查询中当成常量来处理，例如，跟住助教或唯一索引进行查询。</li>
<li>NULL：不用访问表或索引，直接就能够得到结果。</li>
</ol>
<p>​    除了以上，还有其他值:ref_or_null(与ref类似，包含NULL的查询)、index_merge(索引合并优化)、unique_subquery(in后面是一个查询主键字段的子查询), index_subquery</p>
<ul>
<li>possible_keys: 表示查询时可能用到的索引。</li>
<li>key：表示实际使用的索引</li>
<li>key_len：使用索引字段的长度</li>
<li>rows:扫描行的数量</li>
<li>Extra：执行情况的说明。</li>
</ul>
<p>​    5.1版本开始支持分区，通识explain也增加了对分区的支持。可以通过explain partions命令查看SQL所访问的分区。</p>
<h3 id="15-1-4-通过show-profile分析SQL"><a href="#15-1-4-通过show-profile分析SQL" class="headerlink" title="15.1.4 通过show profile分析SQL"></a>15.1.4 通过show profile分析SQL</h3><p>​    从5.0.37版本增加了对show profiles和show profile语句支持。通过have_profiling参数，查看当前MySQL是否支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @have_profiling</span><br></pre></td></tr></table></figure>

<p>​    默认关闭，可以通过set语句在Session级别开启profiling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profilling&#x3D;1</span><br></pre></td></tr></table></figure>

<p>​    通过profile，用户能更清楚地了解SQL的执行过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profiles</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/5f56317b160a154a676427d9.jpg" alt=""></p>
<p>通过show profile for query 语句可以查看执行过程中线程的每个状态和消耗时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile for query 4;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/5f5632e0160a154a676494ec.jpg" alt=""></p>
<p>为了更清晰地看到排序结果，可以查询information_schema.profiling表，并按照时间做个DESC排序。</p>
<p>​    在获取最消耗时间的线程状态后，MySQL进一步支持all、cpu、block io、context switch、page faults等明细类型查看MySQL在使用什么资源上耗费了过高的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile cpu for query 4</span><br></pre></td></tr></table></figure>

<p>​    如果对源代码感兴趣，还可以使用show profile source for query查看SQL解析执行过程中每个步骤对应的源码的文件、函数名以及具体的源文件行数。</p>
<p>​    MySQL5.6之后则通过trace文件进一步向我们展示了优化器是如何选择执行计划的。</p>
<p>​    注意：5.7版本中，profile已经不建议使用，而使用performance schema中一系列性能视图来代替，详细参考第20章。</p>
<h3 id="15-1-5-通过trace分析优化器如何选择执行计划"><a href="#15-1-5-通过trace分析优化器如何选择执行计划" class="headerlink" title="15.1.5 通过trace分析优化器如何选择执行计划"></a>15.1.5 通过trace分析优化器如何选择执行计划</h3><p>​    5.6版本开始提供了对SQL的跟踪trace。</p>
<p>​    使用方式：首先打开trace，设置格式为JSON，设置trace最大能够使用的内存大小，避免解析过程中因默认内存过小而不能完整显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET OPTIMIZER&#x3D;&quot;enabled&#x3D;on&quot;, END_MARKERS_IN_JSON&#x3D;on;</span><br><span class="line">SET OPTIMIZER_TRACE_MAX_MEM_SIZE&#x3D;1000000;</span><br></pre></td></tr></table></figure>

<p>接下来执行想做trace的SQL语句</p>
<p>然后检查INFORMATION_SCHEMA.OPTIMIZER_TRACE就可以知道MySQL是如何执行SQL语句的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE</span><br></pre></td></tr></table></figure>

<p>会输出一个跟踪文件。</p>
<h3 id="15-1-6-确定问题并采取相应措施"><a href="#15-1-6-确定问题并采取相应措施" class="headerlink" title="15.1.6   确定问题并采取相应措施"></a>15.1.6   确定问题并采取相应措施</h3><p>​    比如如果全表扫描可以考虑加索引。</p>
<h2 id="15-2-索引问题"><a href="#15-2-索引问题" class="headerlink" title="15.2 索引问题"></a>15.2 索引问题</h2><h3 id="15-2-1-索引的存储分类"><a href="#15-2-1-索引的存储分类" class="headerlink" title="15.2.1  索引的存储分类"></a>15.2.1  索引的存储分类</h3><p>​    索引在MySQL的存储引擎层中实现的。</p>
<ul>
<li>B-Tree索引：最常见的索引类型，大部分引擎都支持B树索引；</li>
<li>HASH索引：只有Memory/NDB支持，使用场景简单；</li>
<li>R-Tree索引(空间索引)：空间索引时MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li>
<li>Full-text(全文索引)：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL5.6版本开始提供对全文索引的支持。</li>
</ul>
<p>​    8.0.11还不支持函数索引，但是可以通过两种实现函数索引的功能。</p>
<p>（1）前缀索引，即对列的前面某一部分进行索引，可以大大缩小索引文件的大小，但是也有缺点，orderBy和groupBy操作的时候无法使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_title on film(title(10));</span><br></pre></td></tr></table></figure>

<p>(2) 虚拟列索引。5.7版本后支持，可以通过创建虚拟列索引来实现函数索引的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table salaries add column salary_by_1k int generated always as (round(salary&#x2F;1000));</span><br><span class="line">alter table salaries add key idx_salary_by_1k(salary_by_1k);</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/5f564492160a154a67699ece.jpg" alt=""></p>
<h3 id="15-2-2-MySQL如何使用索引"><a href="#15-2-2-MySQL如何使用索引" class="headerlink" title="15.2.2 MySQL如何使用索引"></a>15.2.2 MySQL如何使用索引</h3><p>​    B-Tree索引是最常见的索引，构造类似二叉树，能根据键值提供一行或一个行集的快速访问。</p>
<p><img src="https://pic.imgdb.cn/item/5f577a2d160a154a67ac147b.jpg" alt=""></p>
<h4 id="1-MySQL中能够使用索引的经典场景"><a href="#1-MySQL中能够使用索引的经典场景" class="headerlink" title="1.MySQL中能够使用索引的经典场景"></a>1.MySQL中能够使用索引的经典场景</h4><p>(1) 匹配全值</p>
<p>(2) 匹配值的范围查找</p>
<p>(3) 匹配最左前缀</p>
<p>(4) 仅仅对索引进行查询</p>
<p>(5) 匹配列前缀</p>
<p>(6) 能够实现索引匹配部分精确而其他部分进行范围匹配</p>
<p>(7) 如果列名是索引</p>
<p>(8) 5.6引入了Index Condition Pushdown(ICP)特性，进一步优化了查询，Pushdown代表操作下方，某些情况下条件过滤下方到存储引擎。<img src="https://pic.imgdb.cn/item/5f577cc3160a154a67ad0ffe.jpg" alt=""></p>
<p><img src="https://pic.imgdb.cn/item/5f577cdc160a154a67ad17a2.jpg" alt=""></p>
<h4 id="2-存在索引但不能使用索引的典型场景"><a href="#2-存在索引但不能使用索引的典型场景" class="headerlink" title="2.存在索引但不能使用索引的典型场景"></a>2.存在索引但不能使用索引的典型场景</h4><p>(1) 以%开头的LIKE查询不能利用B-Tree索引；</p>
<p>一般采用轻量级的解决方式，一般情况系，索引会比表肖，扫描索引要比扫描表更快，而InnoDBInnoDB 表上 二级 索引 idx_ last_ name 实际上 存储 字段 last_ name 还 有主 键 actor_ id， 那么 理想 的 访问 方式 应该 是 首先 扫描 二级 索引 idx_ last_ name 获得 满足 条件 last_ name like ‘%NI%’ 的 主 键 actor_ id 列表， 之后 根据 主 键 回 表 去 检索 记录， 这样 访问 避 开了 全 表 扫描 演员 表 actor 产生 的 大量 IO 请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from (select actor_ id from actor where last_ name like &#39;%NI%&#39;) a, actor b where a. actor_ id &#x3D; b. actor_ id</span><br></pre></td></tr></table></figure>

<p>(2) 数据类型出现隐式转换也不会使用索引；</p>
<p>(3) 符合索引情况下，加入查询条不包含列最左边部分，不会使用符合索引；</p>
<p>(4) MySQL估计全表扫描更快。</p>
<h3 id="15-2-3-查看索引使用情况"><a href="#15-2-3-查看索引使用情况" class="headerlink" title="15.2.3 查看索引使用情况"></a>15.2.3 查看索引使用情况</h3><p>​    如果索引正在工作, Handler_read_key的值将很高，这个值代表了一个行被索引值读的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;Handler_read%&#39;</span><br></pre></td></tr></table></figure>

<h2 id="15-3-两个简单实用的优化方法"><a href="#15-3-两个简单实用的优化方法" class="headerlink" title="15.3 两个简单实用的优化方法"></a>15.3 两个简单实用的优化方法</h2><h3 id="15-3-1-定期分析表和检查表"><a href="#15-3-1-定期分析表和检查表" class="headerlink" title="15.3.1 定期分析表和检查表"></a>15.3.1 定期分析表和检查表</h3><p>​    分析表的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tal_nam[, tbl_name]...</span><br></pre></td></tr></table></figure>

<p>​    本语句用于分析和存储表的关键字分布，分析结果可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。分析期间，使用一个读取锁定对表进行锁定。这对MyISAM、BDB、InnoDB表有作用。对MyISAM，本语句与使用myisamchk -a相当。</p>
<p>​    检查表语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check TABLE tbl_name[, tbl_name] ... [option]... option&#x3D;&#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="15-3-2-定期优化表"><a href="#15-3-2-定期优化表" class="headerlink" title="15.3.2 定期优化表"></a>15.3.2 定期优化表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tal_nam[, tbl_name]...</span><br></pre></td></tr></table></figure>

<p>​    对于InnoDB的表，设置innodb_file_per_table参数，设置为独立表空间模式，每个数据库的每个表都会生成一个ibd文件，用于存储表的数据和索引，一定程度上减轻InnoDB表的空间回收问题。删除大量数据后，InnoDB表可以通过 alter table但是不该表引擎的方式来回收不用的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table payment engine&#x3D;innodb</span><br></pre></td></tr></table></figure>

<p>​    注意：ANALYZE, CHECK, OPTIMIZE, ALTER TABLE 执行期间将对表进行锁定，因此一定注意要在数据库不繁忙时使用。</p>
<h2 id="15-4-常用SQL的优化"><a href="#15-4-常用SQL的优化" class="headerlink" title="15.4 常用SQL的优化"></a>15.4 常用SQL的优化</h2><h3 id="15-4-1-大批量插入数据"><a href="#15-4-1-大批量插入数据" class="headerlink" title="15.4.1 大批量插入数据"></a>15.4.1 大批量插入数据</h3><p>​    当时用load命令导入数据时，适当设置可以提高导入速度。</p>
<p>​    如果MyISAM引擎表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tbl_name ENABLE KEYS;</span><br></pre></td></tr></table></figure>

<p>​    通过关闭MyISAM表非唯一索引的更新，来提高速度。注意导入空表时无须这样设置。</p>
<p>​    对于InnoDB的表</p>
<p>(1) InnoDB类型按主键存顺序保存，所以导入数据按主键的顺序排列，可以有效提高效率。</p>
<p>(2) 导入数据前执行 SET UNIQUE_CHECKS=0, 关闭唯一性校验，导入结束后，SET UNIQUE_CHECKS=1进行恢复</p>
<p>(3)SET AUTOCOMMIT=0关闭，导入结束后打开，SET AUTOCOMMIT=1</p>
<h3 id="15-4-2-优化INSERT语句"><a href="#15-4-2-优化INSERT语句" class="headerlink" title="15.4.2 优化INSERT语句"></a>15.4.2 优化INSERT语句</h3><p>​    考虑以下几种优化方式</p>
<ul>
<li><p>同时从同一客户插入很多行，尽量使用多个值表的INSERT语句，这种方式大大缩减客户端与数据库的连接、关闭等消耗，效率更高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into test values(1,2),(1,3)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同客户插入多行，可以使用INSERT DELAYED语句得到更高的速度。DELAYED语句是让INSERT语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，要更快。LOW_PRIORITY相反，在所有其他用户读写完成后，才进行插入。</p>
</li>
<li><p>将索引文件和数据文件放在不同的磁盘上</p>
</li>
<li><p>如果进行批量插入，可以通过增加bulk_insert_buffer_size变量的值来提高速度，只能对MyISAM使用</p>
</li>
<li><p>当一个文本文件装载一个表时，使用LOAD DATA INLINE。通常比使用很多INSERT语句快20倍。</p>
</li>
</ul>
<h3 id="15-4-3-优化ORDER-BY语句"><a href="#15-4-3-优化ORDER-BY语句" class="headerlink" title="15.4.3 优化ORDER BY语句"></a>15.4.3 优化ORDER BY语句</h3><h4 id="1-MySQL有两种排序方式"><a href="#1-MySQL有两种排序方式" class="headerlink" title="1.MySQL有两种排序方式"></a>1.MySQL有两种排序方式</h4><p>​    第一种通过有序所有顺序扫描直接返回有序数据，效率较高</p>
<p>​    第二种通过对返回的数据进行排序，也就是常说的Filesort排序，所有不是通过索引直接返回排序结果的排序都叫Filesort排序。</p>
<p>​    Filesort是通过相应的排序算法，将取得的数据在sort_buffer_size系统变量设置的内存排序区中进行排序，如果内存装载不下，它就会将磁盘上的数据进行分开，在对每个数据块进行排序，然后将各个块合并成有序的结果集。</p>
<p>​    优化目标：尽量减少额外的排序，通过索引直接返回有序数据。</p>
<p>​    以下情况不能使用索引：</p>
<ul>
<li>order by字段混合ASC和DESC</li>
<li>用于查询行的关键字与ORDER BY中使用的不同</li>
<li>对不同的关键字使用ORDER BY</li>
</ul>
<h4 id="2-Filesort的优化"><a href="#2-Filesort的优化" class="headerlink" title="2.Filesort的优化"></a>2.Filesort的优化</h4><p>​    对于Filesort，MySQL有两种排序算法</p>
<ul>
<li>两次扫描法(TWO Passes): 首先根据条件去除排序字段和行指针信息，之后再排序区sort buffer排序。如果sort buffer不够，则在临时表Temporary Table中存储排序结果。完成后根据行指针回表读读取数据。该算法是4.1之后采用的算法，需要两次访问数据，第一次获取排序字段和行指针信息，第二次根据行指针获取记录，尤其是第二次读取操作可能导致大量随机I/O操作；优点是排序时的内存开销比较小。</li>
<li>一次扫描算法(Single Pass):一次性读取满足条件的行的所有字段，然后在排序区sort buffer中排序后直接输出结果表。排序时候的内存开销比较大，但是排序效率比两次扫描算法高。</li>
</ul>
<p>​    MysQL通过比较系统变量max_lenth_for_sort_data大小和Query语句去除字段总大小来判断使用哪种算法，如果max_lenth_for_sort_data更大，使用第二种，否则使用第一种。</p>
<p>​    适当加大max_lenth_for_sort_data会提高效率。</p>
<h3 id="15-4-4-优化Group-By语句"><a href="#15-4-4-优化Group-By语句" class="headerlink" title="15.4.4 优化Group By语句"></a>15.4.4 优化Group By语句</h3><p>​    默认情况下，MySQL对所有 Group by字段排序。</p>
<p>​    如果查询Group By但用户想要避免排序结果的小号，则可以指定ORDER BY NULL禁止排序。</p>
<h3 id="15-4-5-优化JOIN操作"><a href="#15-4-5-优化JOIN操作" class="headerlink" title="15.4.5 优化JOIN操作"></a>15.4.5 优化JOIN操作</h3><p>​    MySQL对于多表JOIN目前只支持一种算法—Nested-Loop Join(NLJ)。原理分厂简单，就是内外两层循环，对于外循环的每条记录，都要在内循环中做一次检索。伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 matching range &#123;</span><br><span class="line">	for each row in t2 maching reference key &#123;</span><br><span class="line">		if row satisfied join condition, send to client</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其中t1和t2表进行join，t1通过范围扫描取每条记录作为外循环，t2通过关键字段在表中做扫描，满足条件则返回客户端；不断重复这个过程直到外循环结束。</p>
<p>​    NLJ性能高低主要取决于两方面：一是外循环结果集大小，二是内循环扫描数据的效率，常见的优化方案是在驱动表上尽可能where条件创建合适索引，是的外循环的结果集更小，读取效率更高；内循环换是为了提高扫描效率，通常需要在关联字段上加索引。</p>
<p>​    有两种情况，NLJ的性能会有比较明显的下降：</p>
<ul>
<li>外循环结果集打，导致访问内循环的io次数非常多</li>
<li>内循环的关联字段并不是唯一索引，而是普通的辅助索引。如果访问的数据列不再辅助索引上，此时通常需要再次回表，通过辅助索引的主键找到聚合索引实际的数据，而回表会导致大量随机io产生，导致性能下降明显。</li>
</ul>
<p>​    为了优化这两个为题，先后推出了两个NLJ的变种BNL(Block Nested-Loop Join)和BKA(Batched Key Access)</p>
<h4 id="1-BNL"><a href="#1-BNL" class="headerlink" title="1.BNL"></a>1.BNL</h4><p>​    在较早版本就引入，算法伪代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 maching range &#123;</span><br><span class="line">	for each row in t2 maching reference key &#123;</span><br><span class="line">		store used columns from t1, t2 in join buffer</span><br><span class="line">		if buffer in null &#123;</span><br><span class="line">			for each row in t3 &#123;</span><br><span class="line">				for each t1, t2 combinationin join buffer &#123;</span><br><span class="line">					if row satisfies join conditions, send to client</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for each row in t3 &#123;</span><br><span class="line">	for each t1, t2 combinationin join buffer &#123;</span><br><span class="line">		if row satisfies join conditions, send to client</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    通过缓存外层循环读的行，来降低内层表的读取次数。</p>
<p>​    5.7中，BNL优化器默认打开。</p>
<p>​    BNL性能虽然大幅提高，但是使用条件比较苛刻，只有当join类型是all/index/range时才可以，也就是内标不使用索引或索引效率很低时才不得不使用。buffer的大小由参数join_buffer_size进行设置。</p>
<h4 id="2-MRR-amp-BKA"><a href="#2-MRR-amp-BKA" class="headerlink" title="2. MRR &amp; BKA"></a>2. MRR &amp; BKA</h4><p>​    大多数情况join操作通常是通过效率较高的索引来做ref或eq_ref方式连接，这种情况下，BNL无法使用。为了优化这种更常见的join，MySQL引入了MRR和BKA。</p>
<p>​    MRR(Multi Range Read) 是MySQL5.6引入的特性。优化目的是减少磁盘随机访问。InnoDB由于是狙击索引的特性，如果查询使用辅助索引，并且用到表中非索引列，需要回表读取数据做后续处理。过于所及的回表会伴随大量的随机IO。MRR是通过范围扫描将数据存储read_rnd_buffer_size，然后对齐按照Primary Key(Row ID)进排序，最后使用排序好的数据进行顺序回表。</p>
<p>​    MRR特性在单表和多表join中都可以使用。单标通常通过范围查询；多表join方式如果是ref/eq_ref，则先通过BKA算法批量提取key到join buffer，然后将buffer中的key作为参数传入MRR的调用接口。</p>
<p>​    如果要打开MRR，需要设置以下两个优化器参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_switch&#x3D;&#39;mmr&#x3D;on,mmr_cose_based&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>

<p>​    mmr参数控制是否打开，默认为on；mrr_cost_based控制是否根据优化器的计算成本来使用mrr特性，默认是on；如果希望尽可能使用mrr，可以设置为off。</p>
<p>​    如果执行计划的Extra部分存在Using MRR，就是使用了该特性。</p>
<p>​    BKA(Batch Key Access)是5.6引入的新算法,结合MRR特性进行高效join操作。</p>
<ul>
<li>将外循环中相关的列放入Join Buffer中。</li>
<li>批量将Key(索引键值)发送到MRR接口</li>
<li>MRR通过收到的Key，根据对应的Primary Key(RowID)进行排序，然后再根据排序后的Primary Key(RowID)顺序读取聚集特性，得到需要的列数据。</li>
<li>返回结果集给客户端。</li>
</ul>
<p>​    5.7以后, BKA默认是打开的，由优化器中的参数batched_key_access来控制。如果要使用BKA，则需要先打开MRR特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_switch&#x3D;&#39;mrr&#x3D;on,mrr_cost_based&#x3D;off,batch_key_access&#x3D;on&#39;;</span><br></pre></td></tr></table></figure>

<p>​    判断是否使用了BKA算法，需要查看执行计划中extra部分是否含有”Using join buffer”字符串。</p>
<p>​    BKA很多情况下可以提高廉洁效率，但是对Join有一定条件限制，一个条件时连接的列要求是唯一索引或普通索引，但是不能是主键；另一个是有对非主键列的查询操作，否则优化器就通过覆盖索引等方式直接得到需要的数据，而不需要回表。</p>
<h3 id="15-4-6-优化嵌套查询"><a href="#15-4-6-优化嵌套查询" class="headerlink" title="15.4.6 优化嵌套查询"></a>15.4.6 优化嵌套查询</h3><p>​    4.1版本开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个查询结果作为过滤条件用在另一个查询中。有些情况下，可以用JOIN替代。</p>
<p>​    连接之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p>
<h3 id="15-4-7-MySQL如何优化OR条件"><a href="#15-4-7-MySQL如何优化OR条件" class="headerlink" title="15.4.7 MySQL如何优化OR条件"></a>15.4.7 MySQL如何优化OR条件</h3><p>​    对于含有OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，如果没有索引，则应该考虑增加索引。</p>
<h3 id="15-4-8-优化分页查询"><a href="#15-4-8-优化分页查询" class="headerlink" title="15.4.8 优化分页查询"></a>15.4.8 优化分页查询</h3><p>​    一般分页查询，通过创建覆盖索引能够比较好地提高性能。常见又头疼的场景是 limit 1000,20。 前1000条记录都会被抛弃，查询和排序的代价非常高</p>
<h4 id="1-第一种优化思路"><a href="#1-第一种优化思路" class="headerlink" title="1. 第一种优化思路"></a>1. 第一种优化思路</h4><p>​    在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<h4 id="2-第二种优化思路"><a href="#2-第二种优化思路" class="headerlink" title="2. 第二种优化思路"></a>2. 第二种优化思路</h4><p>​    把Limit转换成某个位置的查询，列入假设每页10条数据，和开发人员协商一下，反野过程中，通过增加一个参数 last_page_record,用来记录上一页最后一行的租赁编号rental_id，加入是15460，那么在翻页到42页时，可以根据最后一条记录向后追述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from payment where rental_id &lt; 15640 order by rental_id desc limit 10</span><br></pre></td></tr></table></figure>

<p>注意：这种思路只会出现在排序字段不会出现重复值的特定环境。</p>
<h3 id="15-4-9-使用SQL提示"><a href="#15-4-9-使用SQL提示" class="headerlink" title="15.4.9 使用SQL提示"></a>15.4.9 使用SQL提示</h3><p>​    SQL提示是优化数据库的一个重要手段，简单地就是在SQL语句中增加一些人为的提示来达到优化操作的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_BUFFER_RESULSTS * FROM ...</span><br></pre></td></tr></table></figure>

<p>​    这个语句强制MySQL生成一个临时结果表，只要临时结果集生成后，所有表上的锁定均被释放，可以尽快释放锁资源。</p>
<p>​    下面是常用的SQL提示。</p>
<h4 id="1-USE-INDEX"><a href="#1-USE-INDEX" class="headerlink" title="1. USE INDEX"></a>1. USE INDEX</h4><p>​    希望MySql去参考的索引列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from rental use index(idx_rental_date)</span><br></pre></td></tr></table></figure>

<h4 id="2-IGNORE-INDEX"><a href="#2-IGNORE-INDEX" class="headerlink" title="2. IGNORE INDEX"></a>2. IGNORE INDEX</h4><p>​    单纯想让MySQL忽略1个或者多个索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from rental ignore index(idx_rental_date)</span><br></pre></td></tr></table></figure>

<h4 id="3-FORCE-INDEX"><a href="#3-FORCE-INDEX" class="headerlink" title="3. FORCE INDEX"></a>3. FORCE INDEX</h4><p>​    强制MySQL使用一个特定的所有，可在查询中使用FORCE INDEX作为HINT。例如当不强制使用时，以为大部分库存inventory_id都是大于1，因此会默认进行全表扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from rental force index(idx_fk_inventory_id) where inventory_id &gt; 1</span><br></pre></td></tr></table></figure>

<h2 id="15-5-直方图"><a href="#15-5-直方图" class="headerlink" title="15.5 直方图"></a>15.5 直方图</h2><p>​    8.0引入的新功能。可以对一张表的一列做数据分布的统计，特别是针对没有索引的字段，可以帮助优化器找到更优的执行计划。主要场景就是用来计算字段选择性，即过滤效率。</p>
<h3 id="15-5-1-什么是直方图"><a href="#15-5-1-什么是直方图" class="headerlink" title="15.5.1 什么是直方图"></a>15.5.1 什么是直方图</h3><p>​    在数据库中，查询优化器负责将SQL转换为最有效的执行计划。有时候一些字段分布不均匀，导致优化器对某些值不会选择最优的执行计划，使得效率低。为了能做出更准确的选择，优化器需要了解条件列中具体的数据分布情况，而直方图的引入就是为了统计这些信息。</p>
<p>​    主要操作命令有以下两个：</p>
<ul>
<li>生成直方图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE tbl_name update HISTOGRAM ON col_name[, col_name] with N BUCKETS;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除直方图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE tbl_name DROP HISTOGRAM ON col_name[, col_name]</span><br></pre></td></tr></table></figure>

<p>​    比如过滤性别字段，执行计划中的filtered值都是50%，即优化器不知道数据实际分布情况，只是按照值的个数来进行平均分配，如果再gender上创建了直方图，则执行计划就会按照实际的数据分布进行过滤。</p>
<h3 id="15-5-2-直方图的分类"><a href="#15-5-2-直方图的分类" class="headerlink" title="15.5.2 直方图的分类"></a>15.5.2 直方图的分类</h3><p>​    目前支持两种：等宽直方图(singleton)和登高直方图(equi-height)。共同点是，都将数据分到一系列的buckets中；区别在于如果列中不同值的个数小于buckets数，则为等宽直方图，反之则为登高直方图。会自动将数据滑到不同的bucket中，也会自动决定创建那种类型的直方图。</p>
<p>​    直方图的统计信息存放在information_schema库的column_statistics视图中。</p>
<p>​    具体每个值代表什么含义略，见原书252页。</p>
<h3 id="15-5-3-直方图实例应用"><a href="#15-5-3-直方图实例应用" class="headerlink" title="15.5.3 直方图实例应用"></a>15.5.3 直方图实例应用</h3><p>​    略</p>
<h2 id="15-6-使用查询重写"><a href="#15-6-使用查询重写" class="headerlink" title="15.6 使用查询重写"></a>15.6 使用查询重写</h2><p>​    5.7中，提供了Query Rewrite Plugin，可以通过规则匹配的方式，将符合条件的SQL进行重写，从而达到调整执行计划或其他目标。</p>
<p>​    在$mysqlhome/share目录下执行安装脚本，创建query_rewrite数据库和rewrite_rules规则表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; install_rewrite.sql</span><br><span class="line">mysql&gt; show databases like &#39;query%&#39;</span><br><span class="line">mysql&gt; use query_rewrite</span><br><span class="line">mysql&gt; show tables</span><br><span class="line">mysql&gt; SHOW GLOBAL VARIBALES LIKE &#39;rewriter_enabled&#39;</span><br></pre></td></tr></table></figure>

<p>​    SQL重写插件安装之后，即使关闭插件，仍然会有一定的额外开销，考虑到插件可以动态安装和打开，因此如果不是确定要使用这一插件，没有必要重新安装</p>
<p>(1) 增加匹配规则，将”select ?”全部重写为 “select ? + 1”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO query_rewrite_rules(partten, replacement) values(&#39;select ?&#39;, &#39;select ? + 1&#39;);</span><br></pre></td></tr></table></figure>

<p>(2) 刷新使规则生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure>

<p>​    注意，改写对函数无效</p>
<p>​    在使用这一特性时，需要做好充分的测试。</p>
<h2 id="15-7-常用SQL技巧"><a href="#15-7-常用SQL技巧" class="headerlink" title="15.7 常用SQL技巧"></a>15.7 常用SQL技巧</h2><h3 id="15-7-1-正则表达式的使用"><a href="#15-7-1-正则表达式的使用" class="headerlink" title="15.7.1 正则表达式的使用"></a>15.7.1 正则表达式的使用</h3><p><img src="https://pic.imgdb.cn/item/5f5a1334160a154a67c70de8.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_ name, email from customer where email regexp &quot;@163[,.] com$&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="15-7-2-巧用RAND-提取随机行"><a href="#15-7-2-巧用RAND-提取随机行" class="headerlink" title="15.7.2 巧用RAND()提取随机行"></a>15.7.2 巧用RAND()提取随机行</h3><p>​    ORDER BY rand() 能够把数据随机排序</p>
<h3 id="15-7-3-利用-GROUP-BY-的-WITH-ROLLUP语句"><a href="#15-7-3-利用-GROUP-BY-的-WITH-ROLLUP语句" class="headerlink" title="15.7.3 利用 GROUP BY 的 WITH ROLLUP语句"></a>15.7.3 利用 GROUP BY 的 WITH ROLLUP语句</h3><p>​    使用WITH ROLLUP语句可以检索出更多分组聚合信息。完成用户想要得到任何一个分组以及分组组合的聚合信息值。</p>
<p>​    注意：当使用ROLLUP时，不能同时使用ORDER BY 子句进行结果排序。此外LIMIT用在ROLLUP后面。</p>
<h3 id="15-7-4-用BIT-GROUP-FUNCTIONS做统计"><a href="#15-7-4-用BIT-GROUP-FUNCTIONS做统计" class="headerlink" title="15.7.4 用BIT GROUP FUNCTIONS做统计"></a>15.7.4 用BIT GROUP FUNCTIONS做统计</h3><p>​    略</p>
<h3 id="15-7-5-数据库名、表名大小写问题"><a href="#15-7-5-数据库名、表名大小写问题" class="headerlink" title="15.7.5 数据库名、表名大小写问题"></a>15.7.5 数据库名、表名大小写问题</h3><p>​    数据库每个表至少对应数据库目录中的一个或多个文件，所以操作系统大小写敏感决定了数据库名和表名大小写敏感。</p>
<p>​    在MySQL中，如何在硬盘上保存、使用表名和数据库名是由lower_case_tables_name系统变量决定，用户可以在启动MySQL服务时设置这个系统变量</p>
<p><img src="https://pic.imgdb.cn/item/5f5a1660160a154a67c871f9.jpg" alt=""></p>
<p>​    注意：在UNIX中将lower_case_tables_name 设置为1并且重启mysqld之前，必须先将数据库名和表名转换成小写。</p>
<h3 id="15-7-6-使用外键需要注意的问题"><a href="#15-7-6-使用外键需要注意的问题" class="headerlink" title="15.7.6 使用外键需要注意的问题"></a>15.7.6 使用外键需要注意的问题</h3><p>​    InnoDB存储引擎支持对外部关键字约束条件的检查。</p>
<h1 id="第16章-锁问题"><a href="#第16章-锁问题" class="headerlink" title="第16章 锁问题"></a>第16章 锁问题</h1><h2 id="16-1-MySQL锁概述"><a href="#16-1-MySQL锁概述" class="headerlink" title="16.1 MySQL锁概述"></a>16.1 MySQL锁概述</h2><p>​    不同引擎支持不同的锁机制。MyISAM和MEMORY采用表级锁，BDB采用页面锁，但也支持行锁，InnoDB既支持行级锁，也支持表级锁，但是默认是行级锁。</p>
<ul>
<li>表级锁：开销小，加锁块；不会出现死锁；锁粒度打，锁冲突概率高；</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度最高；</li>
<li>页面锁：开销和加锁时间介于以上两者间，会出现死锁，锁粒度介于两者之间。</li>
</ul>
<p>​    重点介绍表锁和行锁</p>
<h2 id="16-2-MyISAM的表锁"><a href="#16-2-MyISAM的表锁" class="headerlink" title="16.2 MyISAM的表锁"></a>16.2 MyISAM的表锁</h2><h3 id="16-2-1-查询表级锁征用情况"><a href="#16-2-1-查询表级锁征用情况" class="headerlink" title="16.2.1 查询表级锁征用情况"></a>16.2.1 查询表级锁征用情况</h3><p>​    可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上表锁定争用情况。</p>
<h3 id="16-2-2-MySQL表级锁"><a href="#16-2-2-MySQL表级锁" class="headerlink" title="16.2.2 MySQL表级锁"></a>16.2.2 MySQL表级锁</h3><p>​    有两种模式：表共享读锁和表独占写锁。</p>
<p>​    MySQL中表锁兼容性</p>
<table>
<thead>
<tr>
<th></th>
<th>None</th>
<th>读锁</th>
<th>写锁</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>写锁</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>​        MyISAM的读操作，不会阻塞其他用户对同一表的读请求，但是会阻塞同意表的写请求；写请求会阻塞读写请求。</p>
<h3 id="16-2-3-如果加表锁"><a href="#16-2-3-如果加表锁" class="headerlink" title="16.2.3 如果加表锁"></a>16.2.3 如果加表锁</h3><p>​    MyISAM在执行查询语句前，会自动给设计所有表加读锁；在执行更新操作前，会自动给涉及表加写锁。显示加锁只是为了说明为题，并非必须如此。</p>
<p>​    给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock tables read local, order_detail read local;</span><br><span class="line">select statement...</span><br><span class="line">Unlock tables;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例加了 local 选项，是为了满足MyISAM表并发插入的条件下，允许其他用户在表尾并发插入记录。</li>
<li>在LOCK TABLES显示加表锁时，必须同时取得所有涉及表的锁，并且不支持锁升级。加锁有，只能访问显示加锁的这些表，而不能访问其他表；同时加的读锁，只能执行查询操作。在自动加锁的情况下也是如此。这也正是MyISAM不会出现死锁的原因。</li>
</ul>
<h3 id="16-2-4-并发插入"><a href="#16-2-4-并发插入" class="headerlink" title="16.2.4 并发插入"></a>16.2.4 并发插入</h3><p>​    MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为</p>
<ul>
<li>0：不允许并发阿插入；</li>
<li>1：如果表中没有空洞（中间没有被删除的行），MyISAM允许在一个进行读表的同事，另一个进行从表尾插入记录，是默认设置；</li>
<li>2：无论有没有空洞，都允许插入。</li>
</ul>
<p>​    可以利用这个特性来解决查询和插入的锁争用，设置为2，然后定期优化表。</p>
<h3 id="16-2-5-MyISAM的锁调度"><a href="#16-2-5-MyISAM的锁调度" class="headerlink" title="16.2.5 MyISAM的锁调度"></a>16.2.5 MyISAM的锁调度</h3><p>​    MyISAM的读写互斥，是串行的。同时请求读写锁时，优先获得写锁。这是它不适合有大量的更新和查询操作应用的原因。可能会导致查询操作很难获得锁。不过可以来调节该行为</p>
<ul>
<li>指定启动参数low_priority_updates,默认给读请求优先权利；</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATE=1，使该连接发出更新请求优先级降低；</li>
<li>通过指定INSERT,UPDATE,DELETE语句的LOW_PRIORITY属性，降低该局域的优先级。</li>
</ul>
<p>​    另外，提供了一个这种办法来调节读写冲突，即给系统参数设置max_write_lock_count，设置一个合适的值，当一个表达到这个值后，MySQL暂时将写请求优先级降低，给读进程一些获得锁的。</p>
<p>​    一些需要长时间的查询操作，也会使写进程”饿死”，因此避免长时间查询操作，不要总想用一条SELECT语句来解决问题。</p>
<h2 id="16-3-InnoDB锁问题"><a href="#16-3-InnoDB锁问题" class="headerlink" title="16.3 InnoDB锁问题"></a>16.3 InnoDB锁问题</h2><p>​    与MyISAM最大不同有两点，一是支持事务，而是行级锁。</p>
<h3 id="16-3-1-背景知识"><a href="#16-3-1-背景知识" class="headerlink" title="16.3.1 背景知识"></a>16.3.1 背景知识</h3><h4 id="1-事务及其ACID属性"><a href="#1-事务及其ACID属性" class="headerlink" title="1. 事务及其ACID属性"></a>1. 事务及其ACID属性</h4><p>​    事务是由一组SQL语句组成的逻辑处理单元，有4个属性，简称为ACID属性。</p>
<ul>
<li>原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行；</li>
<li>一致性(Consistent)： 在事务开始和完成时，数据都必须保持一致状态。意味着所有相关的数据规则都必须应用于书屋的修改，以保持数据的完整性；事务结束时，所有的内部数据（比如B树或双向链表）也都必须是正确的。</li>
<li>隔离性(Isolation)：数据库系统提供一定的隔离机制，保证 事务不受外部并发操作影响的独立环境执行。</li>
<li>持久性(Durable)：事务完成之后，对数据的修改时永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h4 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2. 并发事务带来的问题"></a>2. 并发事务带来的问题</h4><ul>
<li>更新丢失：当两个事务或多个事务选择同一行，然后基于最初选定的值更新改行，由于不知道互相存在，就会发生丢失更新问题。</li>
<li>脏读：一个事务正在对一条记录做修改，在这个事务完成并提交前，另外一个事务来读取同一条记录，如果不加控制，就读取了脏数据。</li>
<li>不可重复读：一个事务正在读取某个数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除了。</li>
<li>幻读(Phantom Read)： 一个事务按相同的查询条件重新查询已经检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li>
</ul>
<h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h4><p>​    上面讲的问题，更新丢失通常应该是完全避免的，但防止丢失更新，并不能单靠数据库事务控制器来解决，需要应用程序对更新数据加必要的锁来解决。</p>
<p>​    脏读、不可重复读、幻读，其实都输数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，基本上分为两种。</p>
<ul>
<li>一种是在读取数据前，加锁</li>
<li>一种是不加任何锁，通过一定机制胜一个数据请求时间点一致性数据快照，并且用这个快照提供一定级别的一致性读取。这个技术叫做数据多版本并发控制，也叫作多版本数据库。</li>
</ul>
<p>​    ISO/ANSI SQL92定义了4个事务隔离级别。</p>
<p><img src="https://pic.imgdb.cn/item/5f5a3811160a154a67d4ff4a.jpg" alt=""></p>
<p>​    各具体数据库不一定完全提供上述4个隔离级别，例如Oracle提供Read commited和Serializable两个标准隔离级别，另外还提供自己定义的Read Only隔离级别，SQL Server除了支持以上隔离级别，还支持一个叫做“快照”的隔离级别，是一个用MVCC实现的Serializable隔离级别。MySQL支持全部4个，但有一些MySQL自己的特点，比如在一些隔离级别下采用MVCC一致读，但某些情况下又不是，后面进一步介绍。</p>
<p>​    </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/mysql/" rel="tag"># mysql</a>
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/01/%E9%B8%9F%E5%93%A5%E7%9A%84linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%AD%A6%E4%B9%A0/" rel="next" title="鸟哥的linux私房菜学习">
                <i class="fa fa-chevron-left"></i> 鸟哥的linux私房菜学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpg"
                alt="宋梓立 sorie" />
            
              <p class="site-author-name" itemprop="name">宋梓立 sorie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ewasong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:819294006@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一部分-基础篇"><span class="nav-number">1.</span> <span class="nav-text">第一部分 基础篇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-MySQL的安装与配置"><span class="nav-number">2.</span> <span class="nav-text">第1章 MySQL的安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-MySQL的下载"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 MySQL的下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-在Window平台下下载MySQL"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1.1 在Window平台下下载MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-在Linux平台下下载Mysql"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.1.2 在Linux平台下下载Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-通过网页直接下载"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">1.通过网页直接下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-通过命令行方式下载"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">2.通过命令行方式下载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-MySQL的安装"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 MySQL的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-在Wiindows平台下安装MySQL"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 在Wiindows平台下安装MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-在Linux平台下安装MySQL"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 在Linux平台下安装MySQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-MySQL的配置"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 MySQL的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-Windows平台下配置MySQL"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.3.1 Windows平台下配置MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-Linux平台下配置MySQL"><span class="nav-number">2.3.2.</span> <span class="nav-text">1.3.2 Linux平台下配置MySQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-启动和关闭MySQL服务"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 启动和关闭MySQL服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-在Windows平台下启动和关闭MySQL服务"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.4.1 在Windows平台下启动和关闭MySQL服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-在Linux平台下启动和关闭MySQL服务"><span class="nav-number">2.4.2.</span> <span class="nav-text">1.4.2 在Linux平台下启动和关闭MySQL服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-命令行方式"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">1.命令行方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-服务的方式"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">2.服务的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章-SQL基础"><span class="nav-number">2.5.</span> <span class="nav-text">第2章 SQL基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-SQL简介"><span class="nav-number">2.6.</span> <span class="nav-text">2.1 SQL简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-MySQL使用入门"><span class="nav-number">2.7.</span> <span class="nav-text">2.2 MySQL使用入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-SQL分类"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.2.1 SQL分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-DDL语句"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.2.2 DDL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建数据库"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">1.创建数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-删除数据库"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">2.删除数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-创建表"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">3.创建表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-删除表"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">4.删除表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-修改表"><span class="nav-number">2.7.2.5.</span> <span class="nav-text">5.修改表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-DML语句"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.2.3 DML语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-插入记录"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">1.插入记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-更新语句"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">2. 更新语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-删除记录"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">3.删除记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-查询记录"><span class="nav-number">2.7.3.4.</span> <span class="nav-text">4.查询记录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-DCL语句"><span class="nav-number">2.7.4.</span> <span class="nav-text">2.2.4 DCL语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-帮助的使用"><span class="nav-number">2.8.</span> <span class="nav-text">2.3 帮助的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-按照层次看帮助"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.3.1 按照层次看帮助</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-快速查阅帮助"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.3.2 快速查阅帮助</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-常用网络资源"><span class="nav-number">2.8.3.</span> <span class="nav-text">2.3.3 常用网络资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-查询元数据信息"><span class="nav-number">2.9.</span> <span class="nav-text">2.4 查询元数据信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-MySQL-支持的数据类型"><span class="nav-number">3.</span> <span class="nav-text">第3章 MySQL 支持的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-数值类型"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 数值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-日期时间类型"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 日期时间类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-字符串类型"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 字符串类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-CHAR和VARCHAR型"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 CHAR和VARCHAR型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-BINARY和VARBINARY类型"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 BINARY和VARBINARY类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-ENUM类型"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 ENUM类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-SET类型"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 SET类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-JSON类型"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 JSON类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-MySQL中的运算符"><span class="nav-number">4.</span> <span class="nav-text">第4章 MySQL中的运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-算术运算符"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-比较运算符"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 比较运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-逻辑运算符"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-位运算符"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 位运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-运算符优先级"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-常用函数"><span class="nav-number">5.</span> <span class="nav-text">第5章 常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-字符串函数"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 字符串函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-数值函数"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 数值函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-日期和时间函数"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 日期和时间函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-流程函数"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 流程函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-JSON函数"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 JSON函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-窗口函数"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 窗口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-其他常用函数"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 其他常用函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二部分-开发篇"><span class="nav-number">6.</span> <span class="nav-text">第二部分 开发篇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-表类型-存储引擎-的选择"><span class="nav-number">7.</span> <span class="nav-text">第6章 表类型(存储引擎)的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-MySQL存储引擎概述"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 MySQL存储引擎概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-各种存储引擎的特性"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 各种存储引擎的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-MyISAM"><span class="nav-number">7.2.1.</span> <span class="nav-text">6.2.1 MyISAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-InnoDB"><span class="nav-number">7.2.2.</span> <span class="nav-text">6.2.2 InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-自动增长列"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">1.自动增长列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-外键约束"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">2.外键约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-主键和索引"><span class="nav-number">7.2.2.3.</span> <span class="nav-text">3.主键和索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-存储方式"><span class="nav-number">7.2.2.4.</span> <span class="nav-text">4.存储方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-MEMORY"><span class="nav-number">7.2.3.</span> <span class="nav-text">6.2.3 MEMORY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-MERGE"><span class="nav-number">7.2.4.</span> <span class="nav-text">6.2.4 MERGE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-TokuDB"><span class="nav-number">7.2.5.</span> <span class="nav-text">6.2.5 TokuDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-如何选择合适的存储引擎"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 如何选择合适的存储引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-选择合适的数据类型"><span class="nav-number">8.</span> <span class="nav-text">第7章 选择合适的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-CHAR和VARCHAR"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 CHAR和VARCHAR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-TEXT和BLOB"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 TEXT和BLOB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-浮点数与定点数"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 浮点数与定点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4日期类型选择"><span class="nav-number">8.4.</span> <span class="nav-text">7.4日期类型选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第8章-字符集"><span class="nav-number">9.</span> <span class="nav-text">第8章 字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-字符集概述"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 字符集概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Unicode简述"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 Unicode简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-汉字常见的一些字符集"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 汉字常见的一些字符集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-选择合适的字符集"><span class="nav-number">9.4.</span> <span class="nav-text">8.4 选择合适的字符集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-MySQL支持的字符集简介"><span class="nav-number">9.5.</span> <span class="nav-text">8.5 MySQL支持的字符集简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-MySQL数据集的设置"><span class="nav-number">9.6.</span> <span class="nav-text">8.6 MySQL数据集的设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-服务器字符集和排序规则"><span class="nav-number">9.6.1.</span> <span class="nav-text">8.6.1 服务器字符集和排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-数据库字符集和排序规则"><span class="nav-number">9.6.2.</span> <span class="nav-text">8.6.2 数据库字符集和排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-3-表字符集和排序规则"><span class="nav-number">9.6.3.</span> <span class="nav-text">8.6.3 表字符集和排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-4-列字符集和校对规则"><span class="nav-number">9.6.4.</span> <span class="nav-text">8.6.4 列字符集和校对规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-5-连接字符集和校对规则"><span class="nav-number">9.6.5.</span> <span class="nav-text">8.6.5 连接字符集和校对规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-字符集的修改步骤"><span class="nav-number">9.7.</span> <span class="nav-text">8.7 字符集的修改步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第9章-索引的设计和使用"><span class="nav-number">10.</span> <span class="nav-text">第9章 索引的设计和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-索引概述"><span class="nav-number">10.1.</span> <span class="nav-text">9.1 索引概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-设计索引的原则"><span class="nav-number">10.2.</span> <span class="nav-text">9.2 设计索引的原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-索引设计的误区"><span class="nav-number">10.3.</span> <span class="nav-text">9.3 索引设计的误区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-索引设计的一般步骤"><span class="nav-number">10.4.</span> <span class="nav-text">9.4 索引设计的一般步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-BTREE索引与HASH索引"><span class="nav-number">10.5.</span> <span class="nav-text">9.5 BTREE索引与HASH索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-索引在MySQL8-0中的改进"><span class="nav-number">10.6.</span> <span class="nav-text">9.6 索引在MySQL8.0中的改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-1-不可见索引"><span class="nav-number">10.6.1.</span> <span class="nav-text">9.6.1 不可见索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-2-倒序索引"><span class="nav-number">10.6.2.</span> <span class="nav-text">9.6.2  倒序索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第10章-开发常用数据库对象"><span class="nav-number">11.</span> <span class="nav-text">第10章 开发常用数据库对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-视图"><span class="nav-number">11.1.</span> <span class="nav-text">10.1 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-1-什么是视图"><span class="nav-number">11.1.1.</span> <span class="nav-text">10.1.1 什么是视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-2-视图操作"><span class="nav-number">11.1.2.</span> <span class="nav-text">10.1.2 视图操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-3-创建或修改视图"><span class="nav-number">11.1.3.</span> <span class="nav-text">10.1.3 创建或修改视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-4-删除视图"><span class="nav-number">11.1.4.</span> <span class="nav-text">10.1.4 删除视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-存储过程和函数"><span class="nav-number">11.2.</span> <span class="nav-text">10.2 存储过程和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-什么是存储过程和函数"><span class="nav-number">11.2.1.</span> <span class="nav-text">10.2.1 什么是存储过程和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-存储过程和函数的相关操作"><span class="nav-number">11.2.2.</span> <span class="nav-text">10.2.2 存储过程和函数的相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-创建、修改存储过程或者函数"><span class="nav-number">11.2.3.</span> <span class="nav-text">10.2.3 创建、修改存储过程或者函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-删除存储过程或函数"><span class="nav-number">11.2.4.</span> <span class="nav-text">10.2.4 删除存储过程或函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-5-查看存储过程或者函数"><span class="nav-number">11.2.5.</span> <span class="nav-text">10.2.5 查看存储过程或者函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-查看存储过程或者函数的状态"><span class="nav-number">11.2.5.1.</span> <span class="nav-text">1.查看存储过程或者函数的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-查看存储过程或函数的定义"><span class="nav-number">11.2.5.2.</span> <span class="nav-text">2.查看存储过程或函数的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-通过information-schema-Rounties了解存储过程和函数的信息"><span class="nav-number">11.2.5.3.</span> <span class="nav-text">3.通过information_schema.Rounties了解存储过程和函数的信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-6-变量的使用"><span class="nav-number">11.2.6.</span> <span class="nav-text">10.2.6 变量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-变量的定义"><span class="nav-number">11.2.6.1.</span> <span class="nav-text">1.变量的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-变量的赋值"><span class="nav-number">11.2.6.2.</span> <span class="nav-text">2.变量的赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-7-定义条件和处理"><span class="nav-number">11.2.7.</span> <span class="nav-text">10.2.7 定义条件和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-条件的定义"><span class="nav-number">11.2.7.1.</span> <span class="nav-text">1.条件的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-条件的处理"><span class="nav-number">11.2.7.2.</span> <span class="nav-text">2.条件的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-8-光标的使用"><span class="nav-number">11.2.8.</span> <span class="nav-text">10.2.8 光标的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-9-流程控制"><span class="nav-number">11.2.9.</span> <span class="nav-text">10.2.9 流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-IF-语句"><span class="nav-number">11.2.9.1.</span> <span class="nav-text">1.IF 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CASE语句"><span class="nav-number">11.2.9.2.</span> <span class="nav-text">2.CASE语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LOOP语句"><span class="nav-number">11.2.9.3.</span> <span class="nav-text">3.LOOP语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-LEAVE语句"><span class="nav-number">11.2.9.4.</span> <span class="nav-text">4.LEAVE语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ITERATE语句"><span class="nav-number">11.2.9.5.</span> <span class="nav-text">5. ITERATE语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-REPEAT语句"><span class="nav-number">11.2.9.6.</span> <span class="nav-text">6.REPEAT语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-WHILE语句"><span class="nav-number">11.2.9.7.</span> <span class="nav-text">7.WHILE语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-10-事件调度器"><span class="nav-number">11.2.10.</span> <span class="nav-text">10.2.10 事件调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-触发器"><span class="nav-number">11.3.</span> <span class="nav-text">10.3 触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-1-创建触发器"><span class="nav-number">11.3.1.</span> <span class="nav-text">10.3.1 创建触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-2-删除触发器"><span class="nav-number">11.3.2.</span> <span class="nav-text">10.3.2 删除触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-3-查看触发器"><span class="nav-number">11.3.3.</span> <span class="nav-text">10.3.3 查看触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-4-触发器的使用"><span class="nav-number">11.3.4.</span> <span class="nav-text">10.3.4 触发器的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第11章-事务控制和锁定语句"><span class="nav-number">12.</span> <span class="nav-text">第11章 事务控制和锁定语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-LOCK-TABLES和UNLOCKE-TABLES"><span class="nav-number">12.1.</span> <span class="nav-text">11.1 LOCK TABLES和UNLOCKE TABLES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-事务控制"><span class="nav-number">12.2.</span> <span class="nav-text">11.2 事务控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-分布式事务的使用"><span class="nav-number">12.3.</span> <span class="nav-text">11.3 分布式事务的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-分布式事务的原理"><span class="nav-number">12.3.1.</span> <span class="nav-text">11.3.1 分布式事务的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-分布式事务的语法"><span class="nav-number">12.3.2.</span> <span class="nav-text">11.3.2 分布式事务的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-3-存在的问题"><span class="nav-number">12.3.3.</span> <span class="nav-text">11.3.3 存在的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第12章-SQL中的安全问题"><span class="nav-number">13.</span> <span class="nav-text">第12章 SQL中的安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-SQL注入简介"><span class="nav-number">13.1.</span> <span class="nav-text">12.1 SQL注入简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-应用开发中可以采取的措施"><span class="nav-number">13.2.</span> <span class="nav-text">12.2 应用开发中可以采取的措施</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-1-PrepareStatemen-Bind-Variables"><span class="nav-number">13.2.1.</span> <span class="nav-text">12.2.1 PrepareStatemen+Bind-Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-2-使用应用程序提供的转换函数"><span class="nav-number">13.2.2.</span> <span class="nav-text">12.2.2 使用应用程序提供的转换函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-3-自定义函数进行校验。"><span class="nav-number">13.2.3.</span> <span class="nav-text">12.2.3 自定义函数进行校验。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第13章-SQL-Mode及相关问题"><span class="nav-number">14.</span> <span class="nav-text">第13章 SQL Mode及相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-MySQL-SQL-Mode简介"><span class="nav-number">14.1.</span> <span class="nav-text">13.1 MySQL SQL Mode简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-SQL-Mode常见功能"><span class="nav-number">14.2.</span> <span class="nav-text">13.2 SQL Mode常见功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-常用SQL-MODE"><span class="nav-number">14.3.</span> <span class="nav-text">13.3 常用SQL MODE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-SQL-Mode在迁移中如何使用"><span class="nav-number">14.4.</span> <span class="nav-text">13.4 SQL Mode在迁移中如何使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第14章-MySQL分区"><span class="nav-number">15.</span> <span class="nav-text">第14章 MySQL分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-分区概述"><span class="nav-number">15.1.</span> <span class="nav-text">14.1 分区概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-分区类型"><span class="nav-number">15.2.</span> <span class="nav-text">14.2 分区类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-1-RANGE分区"><span class="nav-number">15.2.1.</span> <span class="nav-text">14.2.1 RANGE分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-2-LIST分区"><span class="nav-number">15.2.2.</span> <span class="nav-text">14.2.2 LIST分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-3-COLUMNS分区"><span class="nav-number">15.2.3.</span> <span class="nav-text">14.2.3 COLUMNS分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-4-HASH分区"><span class="nav-number">15.2.4.</span> <span class="nav-text">14.2.4 HASH分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-5-KEY分区"><span class="nav-number">15.2.5.</span> <span class="nav-text">14.2.5 KEY分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-6-子分区"><span class="nav-number">15.2.6.</span> <span class="nav-text">14.2.6 子分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-7-MySQL分区处理NULL值的方式"><span class="nav-number">15.2.7.</span> <span class="nav-text">14.2.7 MySQL分区处理NULL值的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-分区管理"><span class="nav-number">15.3.</span> <span class="nav-text">14.3 分区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-1-RANGE和LIST分区管理"><span class="nav-number">15.3.1.</span> <span class="nav-text">14.3.1 RANGE和LIST分区管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-2-HASH和KEY分区管理"><span class="nav-number">15.3.2.</span> <span class="nav-text">14.3.2 HASH和KEY分区管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-3-交换分区"><span class="nav-number">15.3.3.</span> <span class="nav-text">14.3.3 交换分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第15章-SQL优化"><span class="nav-number">16.</span> <span class="nav-text">第15章 SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-优化SQL语句的一般步骤"><span class="nav-number">16.1.</span> <span class="nav-text">15.1 优化SQL语句的一般步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-1-通过show-status命令了解各种SQL的执行效率"><span class="nav-number">16.1.1.</span> <span class="nav-text">15.1.1 通过show status命令了解各种SQL的执行效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-2-定位执行效率较低的SQL语句"><span class="nav-number">16.1.2.</span> <span class="nav-text">15.1.2 定位执行效率较低的SQL语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-3-通过EXPLAIN分析低效SQL的执行计划"><span class="nav-number">16.1.3.</span> <span class="nav-text">15.1.3 通过EXPLAIN分析低效SQL的执行计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-4-通过show-profile分析SQL"><span class="nav-number">16.1.4.</span> <span class="nav-text">15.1.4 通过show profile分析SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-5-通过trace分析优化器如何选择执行计划"><span class="nav-number">16.1.5.</span> <span class="nav-text">15.1.5 通过trace分析优化器如何选择执行计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-6-确定问题并采取相应措施"><span class="nav-number">16.1.6.</span> <span class="nav-text">15.1.6   确定问题并采取相应措施</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-索引问题"><span class="nav-number">16.2.</span> <span class="nav-text">15.2 索引问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-1-索引的存储分类"><span class="nav-number">16.2.1.</span> <span class="nav-text">15.2.1  索引的存储分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-2-MySQL如何使用索引"><span class="nav-number">16.2.2.</span> <span class="nav-text">15.2.2 MySQL如何使用索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-MySQL中能够使用索引的经典场景"><span class="nav-number">16.2.2.1.</span> <span class="nav-text">1.MySQL中能够使用索引的经典场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-存在索引但不能使用索引的典型场景"><span class="nav-number">16.2.2.2.</span> <span class="nav-text">2.存在索引但不能使用索引的典型场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-3-查看索引使用情况"><span class="nav-number">16.2.3.</span> <span class="nav-text">15.2.3 查看索引使用情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-两个简单实用的优化方法"><span class="nav-number">16.3.</span> <span class="nav-text">15.3 两个简单实用的优化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-1-定期分析表和检查表"><span class="nav-number">16.3.1.</span> <span class="nav-text">15.3.1 定期分析表和检查表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-2-定期优化表"><span class="nav-number">16.3.2.</span> <span class="nav-text">15.3.2 定期优化表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4-常用SQL的优化"><span class="nav-number">16.4.</span> <span class="nav-text">15.4 常用SQL的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-1-大批量插入数据"><span class="nav-number">16.4.1.</span> <span class="nav-text">15.4.1 大批量插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-2-优化INSERT语句"><span class="nav-number">16.4.2.</span> <span class="nav-text">15.4.2 优化INSERT语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-3-优化ORDER-BY语句"><span class="nav-number">16.4.3.</span> <span class="nav-text">15.4.3 优化ORDER BY语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-MySQL有两种排序方式"><span class="nav-number">16.4.3.1.</span> <span class="nav-text">1.MySQL有两种排序方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Filesort的优化"><span class="nav-number">16.4.3.2.</span> <span class="nav-text">2.Filesort的优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-4-优化Group-By语句"><span class="nav-number">16.4.4.</span> <span class="nav-text">15.4.4 优化Group By语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-5-优化JOIN操作"><span class="nav-number">16.4.5.</span> <span class="nav-text">15.4.5 优化JOIN操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-BNL"><span class="nav-number">16.4.5.1.</span> <span class="nav-text">1.BNL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-MRR-amp-BKA"><span class="nav-number">16.4.5.2.</span> <span class="nav-text">2. MRR &amp; BKA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-6-优化嵌套查询"><span class="nav-number">16.4.6.</span> <span class="nav-text">15.4.6 优化嵌套查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-7-MySQL如何优化OR条件"><span class="nav-number">16.4.7.</span> <span class="nav-text">15.4.7 MySQL如何优化OR条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-8-优化分页查询"><span class="nav-number">16.4.8.</span> <span class="nav-text">15.4.8 优化分页查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-第一种优化思路"><span class="nav-number">16.4.8.1.</span> <span class="nav-text">1. 第一种优化思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-第二种优化思路"><span class="nav-number">16.4.8.2.</span> <span class="nav-text">2. 第二种优化思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-9-使用SQL提示"><span class="nav-number">16.4.9.</span> <span class="nav-text">15.4.9 使用SQL提示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-USE-INDEX"><span class="nav-number">16.4.9.1.</span> <span class="nav-text">1. USE INDEX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-IGNORE-INDEX"><span class="nav-number">16.4.9.2.</span> <span class="nav-text">2. IGNORE INDEX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-FORCE-INDEX"><span class="nav-number">16.4.9.3.</span> <span class="nav-text">3. FORCE INDEX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-5-直方图"><span class="nav-number">16.5.</span> <span class="nav-text">15.5 直方图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-1-什么是直方图"><span class="nav-number">16.5.1.</span> <span class="nav-text">15.5.1 什么是直方图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-2-直方图的分类"><span class="nav-number">16.5.2.</span> <span class="nav-text">15.5.2 直方图的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-3-直方图实例应用"><span class="nav-number">16.5.3.</span> <span class="nav-text">15.5.3 直方图实例应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-6-使用查询重写"><span class="nav-number">16.6.</span> <span class="nav-text">15.6 使用查询重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-常用SQL技巧"><span class="nav-number">16.7.</span> <span class="nav-text">15.7 常用SQL技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-1-正则表达式的使用"><span class="nav-number">16.7.1.</span> <span class="nav-text">15.7.1 正则表达式的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-2-巧用RAND-提取随机行"><span class="nav-number">16.7.2.</span> <span class="nav-text">15.7.2 巧用RAND()提取随机行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-3-利用-GROUP-BY-的-WITH-ROLLUP语句"><span class="nav-number">16.7.3.</span> <span class="nav-text">15.7.3 利用 GROUP BY 的 WITH ROLLUP语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-4-用BIT-GROUP-FUNCTIONS做统计"><span class="nav-number">16.7.4.</span> <span class="nav-text">15.7.4 用BIT GROUP FUNCTIONS做统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-5-数据库名、表名大小写问题"><span class="nav-number">16.7.5.</span> <span class="nav-text">15.7.5 数据库名、表名大小写问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7-6-使用外键需要注意的问题"><span class="nav-number">16.7.6.</span> <span class="nav-text">15.7.6 使用外键需要注意的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第16章-锁问题"><span class="nav-number">17.</span> <span class="nav-text">第16章 锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-MySQL锁概述"><span class="nav-number">17.1.</span> <span class="nav-text">16.1 MySQL锁概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-MyISAM的表锁"><span class="nav-number">17.2.</span> <span class="nav-text">16.2 MyISAM的表锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-1-查询表级锁征用情况"><span class="nav-number">17.2.1.</span> <span class="nav-text">16.2.1 查询表级锁征用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-2-MySQL表级锁"><span class="nav-number">17.2.2.</span> <span class="nav-text">16.2.2 MySQL表级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-3-如果加表锁"><span class="nav-number">17.2.3.</span> <span class="nav-text">16.2.3 如果加表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-4-并发插入"><span class="nav-number">17.2.4.</span> <span class="nav-text">16.2.4 并发插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-5-MyISAM的锁调度"><span class="nav-number">17.2.5.</span> <span class="nav-text">16.2.5 MyISAM的锁调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-InnoDB锁问题"><span class="nav-number">17.3.</span> <span class="nav-text">16.3 InnoDB锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-1-背景知识"><span class="nav-number">17.3.1.</span> <span class="nav-text">16.3.1 背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-事务及其ACID属性"><span class="nav-number">17.3.1.1.</span> <span class="nav-text">1. 事务及其ACID属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-并发事务带来的问题"><span class="nav-number">17.3.1.2.</span> <span class="nav-text">2. 并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-事务隔离级别"><span class="nav-number">17.3.1.3.</span> <span class="nav-text">3. 事务隔离级别</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宋梓立 sorie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  









  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'XTY8e76465N8ugbyhpCoS88f-gzGzoHsz',
        appKey: 'dwWTNcurePtzzBdMO62hSRMy',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
